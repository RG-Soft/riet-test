
// См. описание этой же процедуры в модуле ОбновлениеИнформационнойБазыБСП.
Процедура ПриДобавленииПодсистемы(Описание) Экспорт
	
	Описание.Имя    = "БухгалтерияПредприятия";
	Описание.Версия = "2.3.2.40";
	
	Описание.ТребуемыеПодсистемы.Добавить("СтандартныеПодсистемы");
	
КонецПроцедуры

// Позволяет переопределить режим обновления данных информационной базы.
// Для использования в редких (нештатных) случаях перехода, не предусмотренных в
// стандартной процедуре определения режима обновления.
//
// Параметры:
//   РежимОбновленияДанных - Строка - в обработчике можно присвоить одно из значений:
//              "НачальноеЗаполнение"     - если это первый запуск пустой базы (области данных);
//              "ОбновлениеВерсии"        - если выполняется первый запуск после обновление конфигурации базы данных;
//              "ПереходСДругойПрограммы" - если выполняется первый запуск после обновление конфигурации базы данных, 
//                                          в которой изменилось имя основной конфигурации.
//
//   СтандартнаяОбработка  - Булево - если присвоить Ложь, то стандартная процедура
//                                    определения режима обновления не выполняется, 
//                                    а используется значение РежимОбновленияДанных.
//
Процедура ПриОпределенииРежимаОбновленияДанных(РежимОбновленияДанных, СтандартнаяОбработка) Экспорт
 
КонецПроцедуры

// Добавляет в список процедуры-обработчики обновления данных ИБ
// для всех поддерживаемых версий библиотеки или конфигурации.
// Вызывается перед началом обновления данных ИБ для построения плана обновления.
//
//  Обработчики - ТаблицаЗначений - описание полей, см. в процедуре.
//                ОбновлениеИнформационнойБазы.НоваяТаблицаОбработчиковОбновления.
//
// Пример добавления процедуры-обработчика в список:
//  Обработчик = Обработчики.Добавить();
//  Обработчик.Версия              = "1.1.0.0";
//  Обработчик.Процедура           = "ОбновлениеИБ.ПерейтиНаВерсию_1_1_0_0";
//  Обработчик.РежимВыполнения     = "Монопольно";
//
Процедура ПриДобавленииОбработчиковОбновления(Обработчики) Экспорт
		
	//Обработчик = Обработчики.Добавить();
	//Обработчик.Версия = "*";
	//Обработчик.НачальноеЗаполнение = Истина;
	//Обработчик.Процедура = "";
		
КонецПроцедуры

// См. описание этой же процедуры в модуле ОбновлениеИнформационнойБазыБСП.
Процедура ПередОбновлениемИнформационнойБазы() Экспорт
	
КонецПроцедуры

// См. описание этой же процедуры в модуле ОбновлениеИнформационнойБазыБСП.
Процедура ПослеОбновленияИнформационнойБазы(Знач ПредыдущаяВерсия, Знач ТекущаяВерсия,
		Знач ВыполненныеОбработчики, ВыводитьОписаниеОбновлений, МонопольныйРежим) Экспорт
	
КонецПроцедуры

// См. описание этой же процедуры в модуле ОбновлениеИнформационнойБазыБСП.
Процедура ПриПодготовкеМакетаОписанияОбновлений(Знач Макет) Экспорт
	
КонецПроцедуры

// Заполняет обработчик разделенных данных, зависимый от изменения неразделенных данных (Обработчик.Версия = "*" поддерживается).
//
// Параметры:
//   Обработчики - ТаблицаЗначений, Неопределено - см. описание 
//    функции НоваяТаблицаОбработчиковОбновления общего модуля 
//    ОбновлениеИнформационнойБазы..
//    В случае прямого вызова (не через механизм обновления 
//    версии ИБ) передается Неопределено.
// 
Процедура ЗаполнитьОбработчикиРазделенныхДанных(Параметры = Неопределено) Экспорт
		
КонецПроцедуры

// { RGS EParshina 29.12.2018 15:17:55 - SLI-0007797
Функция ПолучитьСтавкуНДСОтПериода(Период) Экспорт
	Если Период<Дата(2019,01,01) Тогда
		Возврат 0.18
	Иначе Возврат 0.2
	КонецЕсли;	
КонецФункции

// { RGS EParshina 29.12.2018 15:17:55 - SLI-0007797
Функция ПолучитьСсылкуСтавкаНДСОтПериода(Период, Обратная = Ложь) Экспорт
	Если Не Обратная Тогда
		Если Период<Дата(2019,01,01) Тогда
			Возврат ПредопределенноеЗначение("Перечисление.СтавкиНДС.НДС18");
		Иначе 
			Возврат ПредопределенноеЗначение("Перечисление.СтавкиНДС.НДС20")
		КонецЕсли;
	Иначе
		Если Период<Дата(2019,01,01) Тогда
			Возврат ПредопределенноеЗначение("Перечисление.СтавкиНДС.НДС18_118");
		Иначе 
			Возврат ПредопределенноеЗначение("Перечисление.СтавкиНДС.НДС20_120")
		КонецЕсли;
	КонецЕсли;
КонецФункции

// { RGS EParshina 29.12.2018 15:17:55 - SLI-0007797
Функция ПолучитьСтавкуНДСОтСуммы(СуммаНДС, ИтоговаяСумма) Экспорт
	Если Не ЗначениеЗаполнено(СуммаНДС) Или Не ЗначениеЗаполнено(ИтоговаяСумма) Тогда
		Возврат ПредопределенноеЗначение("Перечисление.СтавкиНДС.БезНДС");
	ИначеЕсли СуммаНДС/ИтоговаяСумма<0.19 Тогда
		Возврат ПредопределенноеЗначение("Перечисление.СтавкиНДС.НДС18");
	Иначе	
		Возврат ПредопределенноеЗначение("Перечисление.СтавкиНДС.НДС20");
	КонецЕсли;	
КонецФункции


/////////////////////////////////////////////////////////////////////////////////
// РАБОТА С ЗАПРОСАМИ

Функция ПолучитьСтруктуруРезультатовТекстовЗапросов(СтруктураТекстовЗапросов, СтруктураПараметровЗапросов=Неопределено) Экспорт
	
	// Принимает структуру с текстами запросов и структуру с параметрами запросов,
	// сооружает из них пакет запросов,
	// из массива результатов формирует структуру результатов с теми же ключами, что и в структуре текстов запросов
	
	Если СтруктураТекстовЗапросов.Количество() = 0 Тогда
		Возврат Новый Структура;
	КонецЕсли; 
	
	Запрос = Новый Запрос;
	
	// Установим текст пакета запросов
	Запрос.Текст = "";
	ы = 0;
	Для Каждого КлючИЗначение Из СтруктураТекстовЗапросов Цикл
		
		ы = ы + 1;
		Если ы <> 1 Тогда
			
			Запрос.Текст = Запрос.Текст + "
				|;
				|
				|////////////////////////////////////////////////////////////////////////////////
				|
				|";
					
		КонецЕсли;
			
		Запрос.Текст = Запрос.Текст + КлючИЗначение.Значение;
		
	КонецЦикла;
	
	// Установим параметры запросов
	Если СтруктураПараметровЗапросов <> Неопределено Тогда
		
		Для Каждого КлючИЗначение Из СтруктураПараметровЗапросов Цикл
			
			Запрос.УстановитьПараметр(КлючИЗначение.Ключ, КлючИЗначение.Значение);
			
		КонецЦикла;
		
	КонецЕсли;
	
	МассивРезультатов = Запрос.ВыполнитьПакет();
	
	// Засунем результаты в структуру
	СтруктураРезультатов = Новый Структура;	
	ы = 0;
	Для Каждого КлючИЗначение Из СтруктураТекстовЗапросов Цикл
		
		СтруктураРезультатов.Вставить(КлючИЗначение.Ключ, МассивРезультатов[ы]);
		ы = ы + 1;
		
	КонецЦикла;
	
	Возврат СтруктураРезультатов; 
	
КонецФункции

Функция ПолучитьВыборку(ТипОбъекта, ИмяОбъекта, ВыбираемыеПоля, СтруктураОтборов=Неопределено, ПривилегированныйРежим=Ложь) Экспорт
	
	// Принимает описание запроса, возвращает выборку из результата запроса
	// ТипОбъекта: "Cправочник", "Документ" и т. д.
	// ИмяОбъекта: "Валюты", "РеализацияТоваровУслуг.Услуги" и т. д.
	// ВыбиремыеПоля: имена выбираемых полей, перечисленных через запятую
	// СтруктураОтбора: ключ - имя параметра, значение - значение параметра
	
	Запрос = Новый Запрос;
	
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	" + ВыбираемыеПоля + "
		|ИЗ
		|	" + ТипОбъекта + "." + ИмяОбъекта + " КАК Таблица";
	
	Если СтруктураОтборов <> Неопределено Тогда
		
		Запрос.Текст = Запрос.Текст + "
			|ГДЕ
			|	ИСТИНА";
			
		Для Каждого КлючИЗначение Из СтруктураОтборов Цикл
			
			Запрос.Текст = Запрос.Текст + "
				|	И Таблица." + КлючИЗначение.Ключ + " = &" + КлючИЗначение.Ключ;
				
			Запрос.УстановитьПараметр(КлючИЗначение.Ключ, КлючИЗначение.Значение);
			
		КонецЦикла;
		
	КонецЕсли;
	
	Если ПривилегированныйРежим Тогда
		УстановитьПривилегированныйРежим(Истина);
	КонецЕсли;
	
	Возврат Запрос.Выполнить().Выбрать();
	
КонецФункции

Функция НайтиСсылку(ТипОбъекта, ИмяОбъекта, ПолеПоиска, ЗначениеПоля) Экспорт
	
	// Если значение, по которому будем искать, не заполнено - значит бесполезно уходить на СУБД - возвращаем Неопределено
	Если НЕ ЗначениеЗаполнено(ЗначениеПоля) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Запрос = Новый Запрос;	
	Запрос.УстановитьПараметр("ЗначениеПоля", ЗначениеПоля);	
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	Таблица.Ссылка
		|ИЗ
		|	" + ТипОбъекта + "." + ИмяОбъекта + " КАК Таблица
		|ГДЕ
		|	Таблица." + ПолеПоиска + " = &ЗначениеПоля
		|	И НЕ Таблица.ПометкаУдаления";		
	Выборка = Запрос.Выполнить().Выбрать();
	
	// Если ничего не нашли или нашли больше одного элемента - возвращаем неопределено
	Если Выборка.Количество() <> 1 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Выборка.Следующий();
	Возврат Выборка.Ссылка;
	
КонецФункции


/////////////////////////////////////////////////////////////////////////////////
// ПОИСК ПОДЧИНЕННЫХ И ГОЛОВНЫХ ОБЪЕКТОВ

Функция ПолучитьТекстЗапросаПроведенностиОбъектов(ТипОбъектаПроверки, ИмяЗависимогоОбъекта, ИмяРеквизита) Экспорт
	
	Возврат
		"ВЫБРАТЬ
		|	Объект.Ссылка КАК Объект,
		|	Объект.Представление КАК ПредставлениеСсылки,
		|   Объект."
		+ ?(ТипОбъектаПроверки = "Документ", "Проведен", "Проверен") + " КАК Статус
		|ИЗ
		|	" + ТипОбъектаПроверки + "." + ИмяЗависимогоОбъекта + " КАК Объект
		|ГДЕ
		|	Объект." + ИмяРеквизита + " В(&Ссылка)";
	
КонецФункции

Функция ПодготовитьТаблицуПроведенностиОбъектов(ТипОбъектаПроверки, ИмяЗависимогоОбъекта, ИмяРеквизита, Ссылка) Экспорт
	
	// Функция предназначена для подготовки таблицы проведенности зависимых объектов.
	// 
	// Параметры:
	//   ТипОбъектаПроверки			- Строка, используется два значения: "Документ" или "Справочник".
	//   ИмяЗависимогоОбъекта		- Строка, название документа или справочника верхнего уровня,
	//	 							  например: "Поставка".
	//   ИмяРеквизита				- Строка, имя реквизита с учетом имени табличной части, в которой
	//	 						      осуществляется поиск нашего реквизита, например:
	//	 						      "УпаковочныеЛисты.УпаковочныйЛист" для табличной части и 
	//								  "УпаковочныйЛист" для реквизита шапки.
	//   Ссылка						- Ссылка (или Массив ссылок) на проверяемый объект.
	//
	// Возвращаемое значение:
	//	 ТаблицаЗначений.
	//
	// Поля возвращаемой таблицы:
	//   Объект						- Ссылка на  зависимый объект.
	//	 ПредставлениеСсылки		- Представление ссылки.
	//	 Статус						- Булево, Проведен или Не проведен документ по указанной ссылке.
	//
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Ссылка", Ссылка);	
	Запрос.Текст = ПолучитьТекстЗапросаПроведенностиОбъектов(ТипОбъектаПроверки, ИмяЗависимогоОбъекта, ИмяРеквизита);	
	Возврат Запрос.Выполнить().Выгрузить();
		
КонецФункции

Функция ПолучитьТекстЗапросаУникальностиДокумента(МетаданныеДокумента) Экспорт
	
	Текст =  
		"ВЫБРАТЬ
		|	Таблица.Представление
		|ИЗ
		|	Документ." + МетаданныеДокумента.Имя + " КАК Таблица
		|ГДЕ
		|	Таблица.Номер = &Номер
		|	И Таблица.Ссылка <> &Ссылка
		|	И (НЕ Таблица.ПометкаУдаления)";
		
	Если МетаданныеДокумента.Реквизиты.Найти("Отменен") <> Неопределено Тогда
		Текст = Текст + "
			|	И (НЕ Таблица.Отменен)";
	КонецЕсли;
		
	Возврат Текст;	
	
КонецФункции


/////////////////////////////////////////////////////////////////////////////////
// МЕХАНИЗМ СИНХРОНИЗАЦИИ СТРОКИ ТАБЛИЦЫ ЗНАЧЕНИЙ С БАЗОЙ ДАННЫХ
 
Процедура СинхронизироватьСтрокиТаблицыСБазойДанных(ТаблицаБазы, ТаблицаДокумента, СправочникМенеджер, Отказ, Заголовок=Неопределено) Экспорт
	
	// синхронизирует таблицу документа с базой данных
	//
	// Параметры:
	//  ТаблицаБазы  		- ТаблицаЗначений. Обязательно присутствие реквизита Ссылка.
	//  ТаблицаДокумента	- ТаблицаЗначений. Обязательно присутствие реквизита Ссылка.
	//	СправочникМенеджер	- Справочник-менеджер для создания новых объектов. 
	//						  Например "Справочники.СтрокиИнвойса"
	
	ОписаниеТиповЧ = Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(1,0));
	
	// получим и подготовим рабочую ТЗ
	ТаблицаРабочая = ТаблицаБазы.Скопировать();
	ТаблицаРабочая.Колонки.Добавить("Показатель", ОписаниеТиповЧ);
	ТаблицаРабочая.ЗаполнитьЗначения(-1, "Показатель");
		
	// объединим две таблицы
	Для каждого Стр из ТаблицаДокумента Цикл
		НовСтр = ТаблицаРабочая.Добавить();
		ЗаполнитьЗначенияСвойств(НовСтр, Стр);
		НовСтр.Показатель = 1;
	КонецЦикла;
	
	// подготовим имена колонок для свертки таблицы
	ИменаКолонокСвертки = "";
	Для каждого Колонка ИЗ ТаблицаБазы.Колонки Цикл
		ИменаКолонокСвертки = ИменаКолонокСвертки + "," + Колонка.Имя;
	КонецЦикла;
	ИменаКолонокСвертки = Сред(ИменаКолонокСвертки, 2);
	
	// свернем вновь образованную таблицу
	ТаблицаРабочая.Свернуть(ИменаКолонокСвертки, "Показатель");
	ТаблицаРабочая.Сортировать("Показатель");
	ТаблицаРабочая.Индексы.Добавить("Ссылка");
	
	// для отслеживания, что строка просто изменилась
	ТаблицаСсылок = ТаблицаРабочая.Скопировать(, "Ссылка, Показатель");
	ТаблицаСсылок.Свернуть("Ссылка", "Показатель");
	ТаблицаСсылок.Индексы.Добавить("Ссылка");
	
	// обработаем полученную таблицу
	Для Каждого Стр Из ТаблицаРабочая Цикл
		
		Если ЗначениеЗаполнено(Стр.Ссылка) Тогда
						
			Если Стр.Показатель = 1 Тогда
				
				// строка изменилась, обработаем это
				Объект = Стр.Ссылка.ПолучитьОбъект();
				ЗаполнитьЗначенияСвойств(Объект, Стр);
				Объект.ПометкаУдаления = Ложь;
				
				СтрокаТаблицыСсылок = ТаблицаСсылок.Найти(Стр.Ссылка, "Ссылка");
				Если СтрокаТаблицыСсылок <> Неопределено И СтрокаТаблицыСсылок.Показатель = 0 Тогда
					Объект.ДополнительныеСвойства.Вставить("РазрешитьИзменениеFinalБрокером");
				КонецЕсли;
				
				ОбщегоНазначения.ПопыткаЗаписиОбъекта(Объект, Отказ);
				
			ИначеЕсли Стр.Показатель = -1 Тогда
				
				// Показатель = -1, строку удалили или изменили
				// Пометим на удаление элемент справочника
				// Если его не удалили, а изменили, то пометка удаления потом снимется
				// Кажется, что в случаи изменения, помечать на удаление не надо, однако это нужно для контроля уникальности
					
				Объект = Стр.Ссылка.ПолучитьОбъект();
				Объект.ПометкаУдаления = Истина;
				
				СтрокаТаблицыСсылок = ТаблицаСсылок.Найти(Стр.Ссылка, "Ссылка");
				Если СтрокаТаблицыСсылок <> Неопределено И СтрокаТаблицыСсылок.Показатель = 0 Тогда
					Объект.ДополнительныеСвойства.Вставить("РазрешитьИзменениеFinalБрокером");
				КонецЕсли;
				
				ОбщегоНазначения.ПопыткаЗаписиОбъекта(Объект, Отказ);
			
			КонецЕсли;
			
		Иначе
			
			// строка добавлена
			Объект = СправочникМенеджер.СоздатьЭлемент();
			ЗаполнитьЗначенияСвойств(Объект, Стр);
			ОбщегоНазначения.ПопыткаЗаписиОбъекта(Объект, Отказ);
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры


/////////////////////////////////////////////////////////////////////////////////
// КОМПОНОВКА ДАННЫХ

Функция НайтиВариантНастроекПоИмени(ВариантыНастроек, Имя) Экспорт
	
	Для Каждого ВариантНастроек Из ВариантыНастроек Цикл
		Если ВариантНастроек.Имя = Имя Тогда
			Возврат ВариантНастроек;
		КонецЕсли; 			 
	КонецЦикла; 
	
	Возврат Неопределено;
	
КонецФункции

// { RGS ASeryakov 28.02.2018 15:00:00 - вопрос S-I-0004726
Функция РасчитатьКоличествоРабочихДнейПериодаПоКалендарю(ТолькоРабочие, НачалоПериода, КонецПериода) Экспорт
	                                 
	Запрос = Новый Запрос;
	
	ЗапросТекстРабочие =
	"ВЫБРАТЬ
	|	ВЫБОР
	|		КОГДА ДанныеПроизводственногоКалендаря.ВидДня = ЗНАЧЕНИЕ(Перечисление.ВидыДнейПроизводственногоКалендаря.Рабочий)
	|				ИЛИ ДанныеПроизводственногоКалендаря.ВидДня = ЗНАЧЕНИЕ(Перечисление.ВидыДнейПроизводственногоКалендаря.Предпраздничный)
	|			ТОГДА 1
	|		ИНАЧЕ 0
	|	КОНЕЦ КАК Количество,
	|	ДанныеПроизводственногоКалендаря.Год КАК Год,
	|	ДанныеПроизводственногоКалендаря.Дата КАК Дата
	|ПОМЕСТИТЬ Календарь
	|ИЗ
	|	РегистрСведений.ДанныеПроизводственногоКалендаря КАК ДанныеПроизводственногоКалендаря
	|ГДЕ
	|	ДанныеПроизводственногоКалендаря.Дата МЕЖДУ &НачалоПериода И &КонецПериода
	|
	|СГРУППИРОВАТЬ ПО
	|	ДанныеПроизводственногоКалендаря.Год,
	|	ДанныеПроизводственногоКалендаря.Дата,
	|	ДанныеПроизводственногоКалендаря.ВидДня,
	|	ВЫБОР
	|		КОГДА ДанныеПроизводственногоКалендаря.ВидДня = ЗНАЧЕНИЕ(Перечисление.ВидыДнейПроизводственногоКалендаря.Рабочий)
	|				ИЛИ ДанныеПроизводственногоКалендаря.ВидДня = ЗНАЧЕНИЕ(Перечисление.ВидыДнейПроизводственногоКалендаря.Предпраздничный)
	|			ТОГДА 1
	|		ИНАЧЕ 0
	|	КОНЕЦ
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	СУММА(Календарь.Количество) КАК Количество
	|ИЗ
	|	Календарь КАК Календарь";
	
	ЗапросТекст =	
	"ВЫБРАТЬ
	|	ВЫБОР
	|		КОГДА НЕ ДанныеПроизводственногоКалендаря.ВидДня ЕСТЬ NULL
	|			ТОГДА 1
	|	КОНЕЦ КАК Количество,
	|	ДанныеПроизводственногоКалендаря.Год КАК Год,
	|	ДанныеПроизводственногоКалендаря.Дата КАК Дата
	|ПОМЕСТИТЬ Календарь
	|ИЗ
	|	РегистрСведений.ДанныеПроизводственногоКалендаря КАК ДанныеПроизводственногоКалендаря
	|ГДЕ
	|	ДанныеПроизводственногоКалендаря.Дата МЕЖДУ &НачалоПериода И &КонецПериода
	|
	|СГРУППИРОВАТЬ ПО
	|	ДанныеПроизводственногоКалендаря.Год,
	|	ДанныеПроизводственногоКалендаря.Дата,
	|	ДанныеПроизводственногоКалендаря.ВидДня,
	|	ВЫБОР
	|		КОГДА НЕ ДанныеПроизводственногоКалендаря.ВидДня ЕСТЬ NULL
	|			ТОГДА 1
	|	КОНЕЦ
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	СУММА(Календарь.Количество) КАК Количество
	|ИЗ
	|	Календарь КАК Календарь";
	
	Запрос.Текст = ?(ТолькоРабочие, ЗапросТекстРабочие, ЗапросТекст);
	
	Запрос.УстановитьПараметр("КонецПериода", КонецПериода);
	Запрос.УстановитьПараметр("НачалоПериода", НачалоПериода);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если НЕ РезультатЗапроса.Пустой() Тогда
		
		Выборка = РезультатЗапроса.Выбрать();
		Выборка.Следующий();
		
		Возврат Выборка.Количество;
	Иначе
		
		Возврат 0;
	КонецЕсли;

КонецФункции // РасчитатьКоличествоРабочихДнейПериодаПоКалендарю()

Функция ОпределитьСтатусDOC(DOC) Экспорт
	
	ManualStatuses = DOC.ManualStatuses;	
	
	//1. Ручных статусов нет
	КолВо = ManualStatuses.Количество() ;
	Если КолВо = 0 Тогда
		
		СтатусПоиска = DOC.CurrentStatus;
		
	ИначеЕсли КолВо >= 1 Тогда
		СтрокаПоиска = ManualStatuses[КолВо - 1];
		СтатусПоиска = СтрокаПоиска.Status;
		
	КонецЕсли;
	
	Возврат СтатусПоиска;
	
КонецФункции // ОпределитьСтатусDOC()

Функция ОпределитьДатуСтатусаDOC(DOC) Экспорт
	
	ManualStatuses = DOC.ManualStatuses;
	
	//1. Ручных статусов нет
	КолВо = ManualStatuses.Количество() ;
	Если КолВо = 0 Тогда
		
		//Возврат  DOC.CurrentStatus;
		ДатаСтатусаПоиска = DOC.CurrentStatusDate;
		СтатусПоискаПред  = DOC.CurrentStatus; 
	ИначеЕсли КолВо = 1 Тогда
		
		ДатаСтатусаПоиска = ManualStatuses[0].Date;
		СтатусПоискаПред  = ManualStatuses[0].Status;
		
		//2. ОдинаковыеСтатусы
	Иначе 
		
		СвернутаяПоСтатусам = ManualStatuses.Выгрузить(, "Status");
		СвернутаяПоСтатусам.Свернуть("Status");
		Если СвернутаяПоСтатусам.Количество() = 1  Тогда
			
			ДатаСтатусаПоиска = ManualStatuses[0].Date;
			СтатусПоискаПред  = ManualStatuses[0].Status;
			
		Иначе
			
			СтрокаПоиска = ManualStatuses[КолВо-1];
			
			СтатусПоиска = СтрокаПоиска.Status;
			ДатаСтатусаПоиска = СтрокаПоиска.Date;
			
			СтатусПоискаПредП = ManualStatuses[КолВо-2].Status;
			
			//3. ПервыйСтатусВГруппе
			Если СтатусПоиска = СтатусПоискаПредП Тогда
				
				СтрокаПоследняя = ManualStatuses[КолВо-1];
				ПоследнийСтатус = СтрокаПоследняя.Status;
				ДатаПоискаПред   = СтрокаПоследняя.Date;
				
				Пока КолВо <> 0 Цикл
					
					СтрокаПоискаПред = ManualStatuses[КолВо-1];
					СтатусПоискаПред = СтрокаПоискаПред.Status;
					
					Если  ПоследнийСтатус <> СтатусПоискаПред Тогда
						
						СтрокаПоискаПред = ManualStatuses[КолВо];
						ДатаПоискаПред   = СтрокаПоискаПред.Date;
						СтатусПоискаПред = СтрокаПоискаПред.Status;
						
						Прервать;
					КонецЕсли;
					
					КолВо = КолВо -1;
				КонецЦикла;
				
				// Вернуть Дату 
				ДатаСтатусаПоиска = ДатаПоискаПред;
				
			Иначе
				СтатусПоискаПред = СтатусПоиска;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Если СтатусПоискаПред = Перечисления.DOCStatuses.PendingHUB И  НачалоДня(ДатаСтатусаПоиска) > DOC.Received Тогда
		ДатаСтатусаПоиска = Дата('00010101');
	КонецЕсли;
	
	Возврат ДатаСтатусаПоиска;
	
	
КонецФункции // ОпределитьДатуСтатусаDOC()

Функция КоличествоРабочихДнейДляТекущегоСтатуса(Ссылка, ТолькоРабочие, КонецПериода) Экспорт

	ДатаСтатуса = НачалоДня(ОпределитьДатуСтатусаDOC(Ссылка));
	
	Возврат РасчитатьКоличествоРабочихДнейПериодаПоКалендарю(ТолькоРабочие,ДатаСтатуса, КонецПериода);
	
КонецФункции // КоличествоРабочихДнейДляТекущегостатуса()


// } RGS DKazanskiy 23.05.2018 14:05:18 - S-I-0005276

/////////////////////////////////////////////////////////////////////////////////
// ЭЛЕКТРОННАЯ ПОЧТА

Процедура ЗарегистрироватьПочтовоеСообщение(АдресПолучателя, Тема, Тело, Вложение=Неопределено, ТипТекста = Неопределено, Копия = Неопределено, АдресОтвета = Неопределено) Экспорт
	
	// { RGS AArsentev 07.05.2018 S-I-0005089
	УстановитьПривилегированныйРежим(Истина);
	// } RGS AArsentev 07.05.2018 S-I-0005089
	
	МенеджерЗаписи = РегистрыСведений.EMailQueue.СоздатьМенеджерЗаписи();
	МенеджерЗаписи.EMail = АдресПолучателя;
	МенеджерЗаписи.Date = ТекущаяДата();
	МенеджерЗаписи.Subject = Тема;
	МенеджерЗаписи.Body = СокрЛП(Тело);
	МенеджерЗаписи.ТипТекста = ТипТекста;
	МенеджерЗаписи.Copy = Копия;
	МенеджерЗаписи.Attachment = Вложение;
	// { RGS ASeryakov, 25.09.2018 S-I-0005867
	МенеджерЗаписи.КоличествоОтправок = 1;
	// } RGS ASeryakov, 25.09.2018 S-I-0005867
	
	// { RGS DKazanskiy 31.05.2018 15:09:03 - S-I-0005358
	// добавим в регистр адрес ответа
	Если АдресОтвета <> Неопределено Тогда 
		МенеджерЗаписи.АдресОтвета = АдресОтвета;
	КонецЕсли;
	// } RGS DKazanskiy 31.05.2018 15:09:15 - S-I-0005358
	
	// { RGS AARsentev 01.06.2018
	МенеджерЗаписи.GUID = Новый УникальныйИдентификатор();
	// } RGS AARsentev 01.06.2018
	
	МенеджерЗаписи.Записать();
	
	// { RGS AArsentev 07.05.2018 S-I-0005089
	УстановитьПривилегированныйРежим(Ложь);
	// } RGS AArsentev 07.05.2018 S-I-0005089
	
КонецПроцедуры


/////////////////////////////////////////////////////////////////////////////////
// ПАРАМЕТРЫ ВЫБОРА

Процедура ДобавитьПараметрВыбора(ПолеВвода, ПараметрВыбора) Экспорт
	
	// Добавляет в параметры выбора поля ввода новый параметр выбора
	
	ПараметрыВыбора = РГСофт.ПолучитьМассивИзФиксированного(ПолеВвода.ПараметрыВыбора);
	ПараметрыВыбора.Добавить(ПараметрВыбора);
	ПолеВвода.ПараметрыВыбора = Новый ФиксированныйМассив(ПараметрыВыбора);
	
КонецПроцедуры

Процедура ВставитьПараметрВыбора(ПолеВвода, ПараметрВыбора) Экспорт
	
	// Попробуем найти параметр по имени в фиксированном массиве поля ввода
	ФиксированныеПараметрыВыбора = ПолеВвода.ПараметрыВыбора;
	ИндексНайденногоПараметра = ИндексПараметраВыбораПоИмени(ФиксированныеПараметрыВыбора, ПараметрВыбора.Имя);
	
	Если ИндексНайденногоПараметра <> Неопределено Тогда
		
		СтарыйПараметрВыбора = ФиксированныеПараметрыВыбора[ИндексНайденногоПараметра];
		
		// Если параметр полностью соответствует требованиям - выходим
		Если СтарыйПараметрВыбора.Значение = ПараметрВыбора.Значение Тогда
			Возврат;
		КонецЕсли;
		
		// Удалим старый параметр и вставим новый
		ПараметрыВыбора = РГСофт.ПолучитьМассивИзФиксированного(ФиксированныеПараметрыВыбора);
		ПараметрыВыбора.Удалить(ИндексНайденногоПараметра);
		ПараметрыВыбора.Добавить(ПараметрВыбора);
		ПолеВвода.ПараметрыВыбора = Новый ФиксированныйМассив(ПараметрыВыбора);
		
	Иначе
		
		// Параметр не был найден - добавляем
		ДобавитьПараметрВыбора(ПолеВвода, ПараметрВыбора);
		
	КонецЕсли;	
	
КонецПроцедуры

Процедура УдалитьПараметрВыбора(ПолеВвода, Имя) Экспорт
	
	// Удаляет параметр выбора по имени
	
	ИндексНайденногоПараметра = ИндексПараметраВыбораПоИмени(ПолеВвода.ПараметрыВыбора, Имя);
	Если ИндексНайденногоПараметра = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ПараметрыВыбора = РГСофт.ПолучитьМассивИзФиксированного(ПолеВвода.ПараметрыВыбора);
	ПараметрыВыбора.Удалить(ИндексНайденногоПараметра);
	ПолеВвода.ПараметрыВыбора = Новый ФиксированныйМассив(ПараметрыВыбора);
	
КонецПроцедуры

Функция ИндексПараметраВыбораПоИмени(ПараметрыВыбора, Имя)
	
	Для Индекс = 0 По ПараметрыВыбора.ВГраница() Цикл
		
		Если ПараметрыВыбора[Индекс].Имя = Имя Тогда
			Возврат Индекс;	
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции


/////////////////////////////////////////////////////////////////////////////////
// ОСТАЛЬНОЕ

Функция ПровестиСсылку(ДокументСсылка, Отказ=Ложь) Экспорт
	
	ДокументОбъект = ДокументСсылка.ПолучитьОбъект();
	Возврат ПровестиОбъект(ДокументОбъект, Отказ);
	
КонецФункции

Функция ПровестиОбъект(ДокументОбъект, Отказ=Ложь) Экспорт
	
	Попытка
		ДокументОбъект.Записать(РежимЗаписиДокумента.Проведение);
		Возврат Истина;
	Исключение
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
			"Не удалось провести """ + ДокументОбъект + """. См. ошибки выше. " + ОписаниеОшибки(),
			ДокументОбъект,,, Отказ);
		Возврат Ложь;
	КонецПопытки;
	
КонецФункции

Функция ИзменитьРеквизитВСсылках(МассивСсылок, ИмяРеквизита, НовоеЗначение) Экспорт
	
	МассивИзмененныхСсылок = Новый Массив;
	
	Для Каждого Ссылка Из МассивСсылок Цикл
		
		НачатьТранзакцию(РежимУправленияБлокировкойДанных.Управляемый);
		
		Объект = Ссылка.ПолучитьОбъект();
		
		Если Ссылка[ИмяРеквизита] = НовоеЗначение Тогда
			ЗафиксироватьТранзакцию();
			МассивИзмененныхСсылок.Добавить(Ссылка);
			Продолжить;
		КонецЕсли;
		
		Объект[ИмяРеквизита] = НовоеЗначение;
		
		Попытка
			Объект.Записать();
		Исключение
			ОтменитьТранзакцию();
			Сообщить(
				"Failed to save " + СокрЛП(Объект) + "!
				|See errors above.
				|" + ОписаниеОшибки());
			Продолжить;
		КонецПопытки;
		
		ЗафиксироватьТранзакцию();
		МассивИзмененныхСсылок.Добавить(Ссылка);
		
	КонецЦикла;
	
	Возврат МассивИзмененныхСсылок;
	
КонецФункции

Функция ИзменитьРеквизитВСсылкахВПривилегированномРежиме(МассивСсылок, ИмяРеквизита, НовоеЗначение) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Возврат ИзменитьРеквизитВСсылках(МассивСсылок, ИмяРеквизита, НовоеЗначение);
	
КонецФункции

Функция ПолучитьЗначениеИзКолонкиТаблицы(ИмяКолонки, Таблица) Экспорт
	
	ТаблицаКолонки = Таблица.Скопировать(, ИмяКолонки);
	ТаблицаКолонки.Свернуть(ИмяКолонки);
	Возврат ?(ТаблицаКолонки.Количество() = 1, ТаблицаКолонки[0][ИмяКолонки], Неопределено); 
		
КонецФункции

Процедура ПроверитьЗаполнениеАвтоЗаполняемыхРеквизитов(Объект, СтруктураПроверяемыхРеквизитов, ИсточникДанныхРеквизитов, Отказ) Экспорт
	
	РеквизитыОбъекта = Объект.Метаданные().Реквизиты;
	Для Каждого ЭлементСтруктуры Из СтруктураПроверяемыхРеквизитов Цикл
		
		ИмяРеквизита = ЭлементСтруктуры.Ключ;
		Если НЕ ЗначениеЗаполнено(Объект[ИмяРеквизита]) Тогда
			
			ТекстОшибки = "Не удалось заполнить реквизит """ + РеквизитыОбъекта[ИмяРеквизита].Синоним + """: возможно он не заполнен или различается в """ + ИсточникДанныхРеквизитов + """";
			Если ЭлементСтруктуры.Значение = Ложь Тогда
				
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Non-critical err. " + ТекстОшибки,
					Объект, ИмяРеквизита);
				
			Иначе
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстОшибки,
					Объект, ИмяРеквизита, , Отказ);
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Процедура СообщитьИЗалоггировать(ИмяСобытия, Уровень, ОбъектМетаданных, Данные, Комментарий="") Экспорт
	
	Сообщить(ИмяСобытия + Символы.ПС + Комментарий);
	
	ЗаписьЖурналаРегистрации(
		ИмяСобытия,
		Уровень,
		ОбъектМетаданных,
		Данные,
		Комментарий);
	
КонецПроцедуры

Процедура УстановитьЕслиЗаполнено(Реквизит, Значение) Экспорт
	
	Если ЗначениеЗаполнено(Значение) Тогда
		Реквизит = Значение;
	КонецЕсли;
	
КонецПроцедуры

Функция ПолучитьМассивИзФиксированного(ФиксМассив) Экспорт
	
	НовМассив = Новый Массив;
	Для Каждого Элем Из ФиксМассив Цикл
		НовМассив.Добавить(Элем);	
	КонецЦикла;
	
	Возврат НовМассив;
	
КонецФункции

Функция ПроверитьWindowsАутентификацию() Экспорт
	
	//для монитора сопровождения - RIET-support
	
	РезультатСтруктура = Новый Структура;
	РезультатСтруктура.Вставить("ЕстьWindowsАутентификация", Ложь);
	РезультатСтруктура.Вставить("ОписаниеОшибки", "");	
	
	ТекущийПользователь = ПараметрыСеанса.ТекущийПользователь;
	ПользовательИБ = ПользователиИнформационнойБазы.ТекущийПользователь();
	    	  	
	Если ПользовательИБ.АутентификацияОС Тогда
		
		ИмяПользователя = ПользовательИБ.ПользовательОС;
		ПозицияНедопустимогоСимвола = НайтиНедопустимыеСимволыXML(ИмяПользователя);
		
		Пока ПозицияНедопустимогоСимвола > 0 Цикл
			НачалоИмени = ИмяПользователя + Лев(ИмяПользователя, ПозицияНедопустимогоСимвола - 1);
			КонецИмени = Сред(ИмяПользователя, ПозицияНедопустимогоСимвола + 1);
			ИмяПользователя = НачалоИмени + "_" + КонецИмени;
			ПозицияНедопустимогоСимвола = НайтиНедопустимыеСимволыXML(ИмяПользователя);	
		КонецЦикла;
		
		//+ Параметры для web-сервиса
		Пользователь = ИмяПользователя;
		ПолноеИмя = ПользовательИБ.ПолноеИмя;
		Пароль = ИмяПользователя + "pass!"; 
		АдресБазы = "http://89.188.108.154:6448/Monitor30";
		КлючПроекта = "hy2637Vgp25r17HKdqocxLkCp"; //уникальный ключ проекта - спросить у администратора Мониора Сопровождения
		Email = ТекущийПользователь.EMail; //любой уникальный email,  должен быть обязательно.
		//- Параметры для web-сервиса
		             		
		Попытка
			Определение = Новый WSОпределения(АдресБазы+"/ws/MonitorExt.1cws?wsdl", Пользователь, Пароль);
			Прокси =  Новый WSПрокси (Определение, "RemoteConnect", "RemoteConnect", "RemoteConnectSoap");
			
			РезультатСтруктура.Вставить("ЕстьWindowsАутентификация", Истина);
		Исключение
			Ошибка = ОписаниеОшибки();
			
			Если СтрНайти(Ошибка,"Аутентификация пользователя не выполнена.")<> 0 ИЛИ //ошибка аутентификации 
				 СтрНайти(Ошибка,"User authentication failed.")<> 0 Тогда
				 //Пытаемся создать нового с указанными параметрами
				 Попытка
					 Определение = Новый WSОпределения(АдресБазы+"_rs/ws/UserRegistration?wsdl");
					 Прокси =  Новый WSПрокси (Определение, "UserRegistration", "UserRegistration", "UserRegistrationSoap");
										 
					 ОписаниеОшибки = Прокси.RegisterWithoutPassCode(КлючПроекта, Пользователь, Пароль, Email, ПолноеИмя);
					 Если ОписаниеОшибки = "" Тогда	
						 //ОписаниеОшибки = НСтр("ru = 'В службе поддержки пользователей не найден пользователь с текущими параметрами аутентификации. Запущено создание нового пользователя.'; 
						 //|en = 'Failed to find user with current OS Authentication parameters. Creating new user for RIET-support is in process.'");
						 РезультатСтруктура.Вставить("ЕстьWindowsАутентификация", Истина);
					 Иначе
						 ОписаниеОшибки = НСтр("ru = 'Не удалось создать пользователя с указанными учетными данными автоматически!'; en = 'Failed to create a user with these logon credentials automatically! '");
					 КонецЕсли;
				 Исключение
					 ОписаниеОшибки =  НСтр("ru = 'Веб-сервис автоматической регистрации пользователя недоступен.'; en = ' Аutomatic user registration service is unavailable!'");
				 КонецПопытки;
				 
			Иначе
				ОписаниеОшибки =  НСтр("ru = 'Служба поддержки пользователей недоступна.'; en = 'RIET-support is unavailable.'");
				Сообщить(НСтр("ru = 'Пожалуйста сообщите в поддержку международных транзакций: riet-support@slb.com или локальных транзакций: riet-support-ld@slb.com.'; 
				|en = 'Please contact International transactions support: riet-support@slb.com or Domestic transactions support riet-support-ld@slb.com.'")); 
			КонецЕсли;
			
		КонецПопытки;
	Иначе
		ОписаниеОшибки = НСтр("ru = 'Для пользователя информационной базы отключена Windows аутентификация.'; en = 'OS Authentication is disabled for the user!'");
  	КонецЕсли;             

	РезультатСтруктура.Вставить("ОписаниеОшибки",ОписаниеОшибки);
	Возврат РезультатСтруктура;
	
КонецФункции // ()

//-> RG-Soft Vivanov 2015/02/18
Функция НайтиAU(Дата, Код) Экспорт
	
	AU = РегистрыСведений.СегментыКостЦентров.ПолучитьПоследнее(?(ЗначениеЗаполнено(Дата), Новый Граница(Дата, ВидГраницы.Включая), ТекущаяДата()), Новый Структура("Код", Код)).КостЦентр;
	Возврат AU;
	
КонецФункции

Функция ПолучитьДанныеДляПодбора(Текст, Дата = Неопределено, ПометкаУдаления = Ложь, Сегмент = Неопределено) Экспорт
	
	Если Дата = Неопределено Тогда
		Дата = ТекущаяДата();
	Конецесли;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	СегментыКостЦентровСрезПоследних.КостЦентр,
	|	СегментыКостЦентровСрезПоследних.Код
	|ИЗ
	|	РегистрСведений.СегментыКостЦентров.СрезПоследних(&Дата, ) КАК СегментыКостЦентровСрезПоследних
	|ГДЕ
	|	СегментыКостЦентровСрезПоследних.Код ПОДОБНО &Код
	|	И НЕ СегментыКостЦентровСрезПоследних.КостЦентр.ПометкаУдаления
	|	И СегментыКостЦентровСрезПоследних.КостЦентр.Segment = &Segment";
	Запрос.УстановитьПараметр("Дата", Дата);
	Запрос.УстановитьПараметр("Код", Текст + "%");
	Если Не ПометкаУдаления Тогда
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "И НЕ СегментыКостЦентровСрезПоследних.КостЦентр.ПометкаУдаления", "");
	КонецЕсли;
	Если ЗначениеЗаполнено(Сегмент) Тогда
		Запрос.УстановитьПараметр("Segment", Сегмент);
	Иначе
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "И СегментыКостЦентровСрезПоследних.КостЦентр.Segment = &Segment", "");
	КонецЕсли;
	Выборка = Запрос.Выполнить().Выбрать();
	ДанныеДляВыбора = Новый СписокЗначений;
	Пока Выборка.Следующий() Цикл
		ДанныеДляВыбора.Добавить(Выборка.КостЦентр);
	КонецЦикла;
	Возврат ДанныеДляВыбора;
	
КонецФункции
//<- RG-Soft VIvanov

// { RGS AGorlenko 03.03.2015 17:17:00 - для обхода косяка платформы, метод глобального контекста не всегда работает
Функция ПолучитьДанныеВыбораКостЦентров(Параметры) Экспорт
	Возврат Справочники.КостЦентры.ПолучитьДанныеВыбора(Параметры);
КонецФункции // } RGS AGorlenko 03.03.2015 17:17:25 - для обхода косяка платформы, метод глобального контекста не всегда работает

// { RGS LFedotova 14.09.2017 15:51:34 - вопрос SLI-0007356
Функция ПроверитьСоответствиеДатыПроведенияВТикетах(ДокОбъект, ДатаПроведения, Сообщать = Истина) Экспорт
	
	Если ДокОбъект.ПометкаУдаления Тогда
		Возврат Истина;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ РАЗЛИЧНЫЕ
		|	РеализацияТоваровУслугТовары.Ticket,
		|	РеализацияТоваровУслугТовары.Ticket.ДатаПроведения КАК ДатаПроведения
		|ИЗ
		|	Документ.РеализацияТоваровУслуг.Товары КАК РеализацияТоваровУслугТовары
		|ГДЕ
		|	РеализацияТоваровУслугТовары.Ссылка = &Ссылка
		|	И НЕ РеализацияТоваровУслугТовары.Ticket.ДатаПроведения = &ДатаПроведения
		|
		|ОБЪЕДИНИТЬ ВСЕ
		|
		|ВЫБРАТЬ
		|	РеализацияТоваровУслугУслуги.Ticket,
		|	РеализацияТоваровУслугУслуги.Ticket.ДатаПроведения
		|ИЗ
		|	Документ.РеализацияТоваровУслуг.Услуги КАК РеализацияТоваровУслугУслуги
		|ГДЕ
		|	РеализацияТоваровУслугУслуги.Ссылка = &Ссылка
		|	И НЕ РеализацияТоваровУслугУслуги.Ticket.ДатаПроведения = &ДатаПроведения";
	
	Запрос.УстановитьПараметр("Ссылка", ДокОбъект.Ссылка);
	Запрос.УстановитьПараметр("ДатаПроведения", ДатаПроведения);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
	
	Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
		Ticket = ВыборкаДетальныеЗаписи.Ticket;
		ТикетОбъект = Ticket.ПолучитьОбъект();
		Если ТикетОбъект.ПометкаУдаления Тогда
			ОбщегоНазначения.СообщитьОбОшибке(
				СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					ВернутьСтр("ru='Документ ""%1"" помечен на удаление. Реквизиты документа автоматически не перезаполнены'"),
					Ticket),
				Ложь,
				"",
				СтатусСообщения.Внимание);
			Возврат Ложь;
		КонецЕсли;
		ТикетОбъект.ДатаПроведения = ДатаПроведения;
		Попытка
			ТикетОбъект.Заблокировать();
			ТикетОбъект.Записать();
		Исключение
			ОбщегоНазначения.СообщитьОбОшибке(
				СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					ВернутьСтр("ru='Дата проведения документа ""%1"" автоматически не перезаполнена и может быть неактуальной'"),
					Ticket),
				Ложь,
				"",
				СтатусСообщения.Внимание);
			Возврат Ложь;
		КонецПопытки;
		ТикетОбъект.Записать();
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции
// } RGS LFedotova 14.09.2017 15:51:50 - вопрос SLI-0007356

// { RGS ASeryakov, 23.08.2018 19:46:08 S-I-0005867
Функция СоответствуетМаскеRegExp(Строка, Pattern) Экспорт
	
	objRegExpGUID = Новый COMОбъект("VBScript.RegExp");
	objRegExpGUID.MultiLine = Истина;
	objRegExpGUID.Global = Истина;
	objRegExpGUID.IgnoreCase = Истина;
	objRegExpGUID.Pattern = Pattern;
	
	Возврат objRegExpGUID.Test(Строка);
	
КонецФункции // } RGS ASeryakov 23.08.2018 19:46:10 S-I-0005867

Функция ПолучитьВхожденияПоМаскеRegExp(Строка, Pattern) Экспорт
	
	objRegExpGUID = Новый COMОбъект("VBScript.RegExp");
	objRegExpGUID.MultiLine = Истина;
	objRegExpGUID.Global = Истина;
	objRegExpGUID.IgnoreCase = Истина;
	objRegExpGUID.Pattern = Pattern;
	
	Возврат objRegExpGUID.Execute(Строка);
	
КонецФункции


/////////////////////////////////////////////////////////////////////////////////////////
// ИНИЦИАЛИЗАЦИЯ ПАРАМЕТРОВ СЕАНСА

Процедура УстановитьПараметрСеансаТекущийПользователь(Знач ИмяПараметра, УстановленныеПараметры) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	ТекущийПользователь = Неопределено;
	ОписаниеОшибкиОпределенияПользователя = "";
	Если НЕ УправлениеПользователями.ОпределитьТекущегоПользователя(ТекущийПользователь, ОписаниеОшибкиОпределенияПользователя) Тогда
		
		ВызватьИсключение(ОписаниеОшибкиОпределенияПользователя);
				
	КонецЕсли;
	
	ПараметрыСеанса.ТекущийПользователь = ТекущийПользователь;
	УстановленныеПараметры.Добавить("ТекущийПользователь");
	
КонецПроцедуры

Процедура УстановитьПараметрСеансаУчетнаяПолитикаПоБухгалтерскомуУчету(Знач ИмяПараметра, УстановленныеПараметры) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	УчетнаяПолитикаПоБухгалтерскомуУчету = ОбщегоНазначения.СоздатьКЭШУчетнойПолитики("БухгалтерскийУчет");
	ПараметрыСеанса.УчетнаяПолитикаПоБухгалтерскомуУчету = Новый ХранилищеЗначения(УчетнаяПолитикаПоБухгалтерскомуУчету, Новый СжатиеДанных(0));
	УстановленныеПараметры.Добавить("УчетнаяПолитикаПоБухгалтерскомуУчету");
	
КонецПроцедуры

Процедура УстановитьПараметрСеансаУчетнаяПолитикаПоНалоговомуУчету(Знач ИмяПараметра, УстановленныеПараметры) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	УчетнаяПолитикаПоНалоговомуУчету = ОбщегоНазначения.СоздатьКЭШУчетнойПолитики("НалоговыйУчет");
	ПараметрыСеанса.УчетнаяПолитикаПоНалоговомуУчету = Новый ХранилищеЗначения(УчетнаяПолитикаПоНалоговомуУчету, Новый СжатиеДанных(0));
	УстановленныеПараметры.Добавить("УчетнаяПолитикаПоБухгалтерскомуУчету");
	
КонецПроцедуры

//Обновление рег. Отчетности на бух. Корп 3.0.36.18
Процедура УстановитьПараметрСеансаПараметрыВнешнихРегламентированныхОтчетов(Знач ИмяПараметра, УстановленныеПараметры) Экспорт
	                         
	УстановитьПривилегированныйРежим(Истина);
	ПараметрыСеанса.ПараметрыВнешнихРегламентированныхОтчетов = Новый ФиксированноеСоответствие(Новый Соответствие) ;
	УстановленныеПараметры.Добавить("ПараметрыВнешнихРегламентированныхОтчетов");
	
КонецПроцедуры
//<=

////////////////////////////////////////////////////////////////////////////////
// ИНФОРМАЦИОННЫЕ НАДПИСИ

Процедура УстановитьИнформационныеНадписиЗакрытияПериода(Форма, Объект) Экспорт
	
	Элементы = Форма.Элементы;
		
	// Картинка необходимости утверждения
	УстановитьКартинкуНеобходимостьУтверждения(Элементы.инфКартинкаНеобходимостьУтверждения, Объект);
		
	// Надпись об отрытом периоде
	
	// { RGS LFedotova 14.03.2017 - вопрос SLI-0007188
	//Модуль = НастройкаПравДоступа.ПолучитьМодульРазработкиДокумента(Объект.ссылка);
	//НачалоОткрытогоПериодаМодуля = НастройкаПравДоступа.ПолучитьНачалоОткрытогоУправленческогоПериодаМодуля(Модуль);
	ДатаЗапретаРедактирования = ДатыЗапретаИзменения.ПолучитьДатуЗапретаРедактирования(Объект);
	НачалоОткрытогоПериодаМодуля = ?(ДатаЗапретаРедактирования = Неопределено, Дата(1,1,1), ДобавитьМесяц(ДатыЗапретаИзменения.ПолучитьДатуЗапретаРедактирования(Объект),1));
	// } RGS LFedotova 14.03.2017 - вопрос SLI-0007188
	
	Если НачалоОткрытогоПериодаМодуля <> Неопределено Тогда
		Элементы.инфНадписьОткрытыйПериод.Заголовок = "Открыт: " + Формат(НачалоОткрытогоПериодаМодуля, "ДФ='ММММ гггг'");
	Иначе
		Элементы.инфНадписьОткрытыйПериод.Заголовок = "";
	КонецЕсли;
	
	// Надпись налоговый период
	УстановитьИнформационнуюНадписьНалоговыйПериод(Элементы.инфНадписьНалоговыйПериод, Объект.НалоговыйПериод);	
	
КонецПроцедуры
   
Процедура УстановитьКартинкуНеобходимостьУтверждения(ИнформационнаяКартинка, ДокументОбъект) Экспорт
	
	ИнформационнаяКартинка.Картинка = ПолучитьКартинкуНеобходимостиУтверждения(ДокументОбъект);
	
КонецПроцедуры

Функция ПолучитьКартинкуНеобходимостиУтверждения(ДокументОбъект) 
	
	Если НЕ НастройкаПравДоступа.НадоУтверждатьДокумент(ДокументОбъект) Тогда
		
		Возврат БиблиотекаКартинок.ОбъектУтвержден;
		
	КонецЕсли;
	
	Если ОбщегоНазначения.ЗначениеНеЗаполнено(ДокументОбъект.ссылка) Тогда 
	
		Возврат БиблиотекаКартинок.Внимание;
		
	КонецЕсли;
	
	СтатусУтверждения = НастройкаПравДоступа.ПолучитьСтатусУтверждения(ДокументОбъект.Ссылка);
	ПеречислениеСтатусыУтвержденияОбъектов = Перечисления.СтатусыУтвержденияОбъектов;
	Если СтатусУтверждения = ПеречислениеСтатусыУтвержденияОбъектов.Новая Тогда
		
		Возврат БиблиотекаКартинок.Внимание;
		
	ИначеЕсли СтатусУтверждения = ПеречислениеСтатусыУтвержденияОбъектов.ВПроцессеУтверждения Тогда
		
		Возврат БиблиотекаКартинок.ОбъектУтверждается;
		
	ИначеЕсли СтатусУтверждения = ПеречислениеСтатусыУтвержденияОбъектов.Отклонена Тогда
		
		Возврат БиблиотекаКартинок.ОбъектОтклонен;
		
	ИначеЕсли СтатусУтверждения = ПеречислениеСтатусыУтвержденияОбъектов.Утверждена Тогда
		
		Возврат БиблиотекаКартинок.ОбъектУтвержден;
		
	Иначе
		
		Возврат БиблиотекаКартинок.Внимание;
		
	КонецЕсли;
			
КонецФункции

Процедура УстановитьИнформационнуюНадписьНалоговыйПериод(ИнформационнаяНадпись, НалоговыйПериод) Экспорт
	
	Если НалоговыйПериод <> '00010101' Тогда
		
		ИнформационнаяНадпись.Заголовок = Формат(НалоговыйПериод, "ДФ='к""й квартал"" гггг'");
		
	Иначе
		
		ИнформационнаяНадпись.Заголовок = "";
		
	КонецЕсли;
	
КонецПроцедуры


////////////////////////////////////////////////////////////////////////////////
// CREATION / MODIFICATION

Процедура ОчиститьCreationModification(Объект) Экспорт
	
	Объект.CreatedBy = Неопределено;
	Объект.CreationDate = Неопределено;
	Объект.ModifiedBy = Неопределено;
	Объект.ModificationDate = Неопределено;
	
КонецПроцедуры

Процедура ЗаполнитьCreation(Объект) Экспорт
	
	Объект.CreatedBy = ПараметрыСеанса.ТекущийПользователь;
	Объект.CreationDate = ТекущаяДата();
	
КонецПроцедуры

Процедура ЗаполнитьModification(Объект) Экспорт
	
	Объект.ModifiedBy = ПараметрыСеанса.ТекущийПользователь;
	Объект.ModificationDate = ТекущаяДата();
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// РЕГЛАМЕНТНЫЕ ЗАДАНИЯ

Процедура ЗагрузитьAccountingUnitsИзAU_master() Экспорт
	
	//Производит загрузку Accounting units из excel-файла "AU_master" с hub'a
	Обработки.AULoading.ЗагрузитьAccountingUnitsИзAU_master();	
	
КонецПроцедуры

// { RGS LFedotova 10.03.2017 - вопрос SLI-0007201
&НаКлиенте
Процедура ЗагрузитьAccountingUnitsИзAU_master_клиент() Экспорт

	СерверИсточник = "reports.lawson.slb.com";
	СтрокаПараметраПолучения = "londonmis2/Lawson/MasterData/MasterDataTables/AU_MASTER.zip";
	
	ВремКаталог = КаталогВременныхФайлов() + "tempAUs";
	СоздатьКаталог(ВремКаталог);
	УдалитьФайлы(ВремКаталог, "*.*");
	ИмяВходящегоФайла = "" + ВремКаталог + "/" + "AU_master.zip";
	
	Попытка
        XMLHttp = новый COMObject("Microsoft.XMLHTTP");
	Исключение
		РГСофт.СообщитьИЗалоггировать(
			"Ошибка создания объекта 'Microsoft.XMLHTTP'",
			УровеньЖурналаРегистрации.Ошибка,
			Метаданные.Обработки.AULoading,
			Неопределено,
			ОписаниеОшибки());
    КонецПопытки;    
	
	СсылкаЗапроса  = "http://reports.lawson.slb.com/londonmis2/Lawson/MasterData/MasterDataTables/AU_MASTER.zip";

	Попытка
		XMLHttp.open("GET", СсылкаЗапроса, Ложь,);
		//XMLHttp.open("GET", СсылкаЗапроса, Ложь,"Логин","Пароль");
	Исключение
		РГСофт.СообщитьИЗалоггировать(
			"Ошибка инициализации запроса HTTP",
			УровеньЖурналаРегистрации.Ошибка,
			Метаданные.Обработки.AULoading,
			Неопределено,
			ОписаниеОшибки());
    КонецПопытки;
    
    //отправляем запрос
    Попытка
        XMLHttp.send(Null);
	Исключение
		РГСофт.СообщитьИЗалоггировать(
			"Ошибка отправки запроса HTTP",
			УровеньЖурналаРегистрации.Ошибка,
			Метаданные.Обработки.AULoading,
			Неопределено,
			ОписаниеОшибки());
    Конецпопытки;
    
    //проверка и обработка ответа
    Если XMLHttp.status = 200 тогда
        Ответ = XMLHttp.responsetext;
        //1 - Успех
        //-1 - Отказ
        //Текст - ТекстОшибки
        //Сообщить(Ответ);
	Иначе
		РГСофт.СообщитьИЗалоггировать(
			"Ошибка - статус: " + Строка(XMLHttp.StatusText),
			УровеньЖурналаРегистрации.Ошибка,
			Метаданные.Обработки.AULoading,
			Неопределено,
			ОписаниеОшибки());
    Конецесли;
    	
	s = Новый ComОбъект("ADODB.Stream");
	s.Mode = 3;
	s.Type = 1;
	s.Open();
	s.Write(XMLHttp.responseBody);
	s.SaveToFile(ИмяВходящегоФайла);
	s.Close();

	//загрузим файл
	Попытка
		ЗагрузитьФайлВХранилище(ИмяВходящегоФайла);
	Исключение
		РГСофт.СообщитьИЗалоггировать(
			"Не удалось загрузить файл AU_master.zip",
			УровеньЖурналаРегистрации.Ошибка,
			Метаданные.Обработки.AULoading,
			Неопределено,
			ОписаниеОшибки());
	КонецПопытки;

		//РГСофт.СообщитьИЗалоггировать(
		//	"Загружен файл AU_master.zip",
		//	УровеньЖурналаРегистрации.Примечание,
		//	Метаданные.Обработки.AULoading,
		//	Неопределено,
		//	ВремКаталог);
	УдалитьФайлы(ВремКаталог,"*.*");

КонецПроцедуры

Процедура ЗагрузитьФайлВХранилище(ПолноеИмяФайла)
	
	ПомещаемоеЗначение = Новый ДвоичныеДанные(ПолноеИмяФайла);
	СохраненныеНастройкиОбъект = Справочники.СохраненныеНастройки.AU_master.ПолучитьОбъект();
	СохраненныеНастройкиОбъект.ТипНастройки = Перечисления.ТипыНастроек.ПроизвольныеНастройки;
	СохраненныеНастройкиОбъект.ХранилищеНастроек = Новый ХранилищеЗначения(ПомещаемоеЗначение);
	СохраненныеНастройкиОбъект.Записать();
	
КонецПроцедуры
// } RGS LFedotova 10.03.2017 - вопрос SLI-0007201

//Перенесла часть модуля из обработки AU Loading, чтобы можно было использовать при загрузке DSS
//Федотова Л., РГ-Софт, 28.04.16, вопрос SLI-0006427
Процедура ИзменитьСтруктуруСегментов(Стр, Segment, SubSegment, SubSubSegment) Экспорт

	//сегменты
	
	Segment = Справочники.Сегменты.НайтиПоКоду(СокрЛП(Стр.Segment));
	
	Если Не ЗначениеЗаполнено(Segment) Тогда
		
		SegmentОбъект = Справочники.Сегменты.СоздатьГруппу();
		SegmentОбъект.Код = СокрЛП(Стр.Segment);
		SegmentОбъект.Наименование = СокрЛП(Стр.Segment);
		SegmentОбъект.Родитель = Справочники.Сегменты.ПустаяСсылка();
		SegmentОбъект.Записать();
		Segment = SegmentОбъект.Ссылка;
		
	иначе
		
		SegmentОбъект = Segment.ПолучитьОбъект();
		
		Если Не SegmentОбъект.ЭтоГруппа Тогда 
			
			//Запоминаем ссылку на текущий элемент
			УникальнаяСсылка = Справочники.Сегменты.ПолучитьСсылку(SegmentОбъект.Ссылка.УникальныйИдентификатор());
			
			//Создаем новый элемент - группу
			НовыйЭлемент = Справочники.Сегменты.СоздатьГруппу();    
			НовыйЭлемент.УстановитьСсылкуНового(УникальнаяСсылка);
			
			//... с такими же параметрами, что и текущий
			НовыйЭлемент.Код                 = SegmentОбъект.Код;
			НовыйЭлемент.Наименование        = SegmentОбъект.Наименование;
			НовыйЭлемент.Родитель            = Справочники.Сегменты.ПустаяСсылка();
			
			//Удаляем текущий
			SegmentОбъект.Удалить();
			
			//Записываем новый (группу)
			НовыйЭлемент.Записать();
			
			Segment = НовыйЭлемент.Ссылка;
			
		иначе
			
			РГСофтКлиентСервер.УстановитьЗначение(SegmentОбъект.Родитель, Справочники.Сегменты.ПустаяСсылка());
		
			Если SegmentОбъект.Модифицированность() Тогда 
				SegmentОбъект.Записать();
			КонецЕсли;  
			Segment = SegmentОбъект.Ссылка;
			
		КонецЕсли;
		
	КонецЕсли;
	
	SubSegment = Справочники.Сегменты.НайтиПоКоду(СокрЛП(Стр.SubSegment));
	
	Если Не ЗначениеЗаполнено(SubSegment) Тогда 
		
		SubSegmentОбъект = Справочники.Сегменты.СоздатьГруппу();
		SubSegmentОбъект.Код = СокрЛП(Стр.SubSegment);
		SubSegmentОбъект.Наименование = СокрЛП(Стр.SubSegment);
		SubSegmentОбъект.Родитель = Segment;
		SubSegmentОбъект.Записать();
		SubSegment = SubSegmentОбъект.Ссылка;
		
	иначе
		
		SubSegmentОбъект = SubSegment.получитьОбъект();
		
		Если Не SubSegmentОбъект.ЭтоГруппа Тогда 
			
			//Запоминаем ссылку на текущий элемент
			УникальнаяСсылка = Справочники.Сегменты.ПолучитьСсылку(SubSegmentОбъект.Ссылка.УникальныйИдентификатор());
			
			//Создаем новый элемент - группу
			НовыйЭлемент = Справочники.Сегменты.СоздатьГруппу();    
			НовыйЭлемент.УстановитьСсылкуНового(УникальнаяСсылка);
			
			//... с такими же параметрами, что и текущий
			НовыйЭлемент.Код                 = SubSegmentОбъект.Код;
			НовыйЭлемент.Наименование        = SubSegmentОбъект.Наименование;
			НовыйЭлемент.Родитель            = Segment;
			
			//Удаляем текущий
			SubSegmentОбъект.Удалить();
			
			//Записываем новый (группу)
			НовыйЭлемент.Записать();
			
			SubSegment = НовыйЭлемент.Ссылка;
			
		иначе
			
			МассивНовыхЭлементов = Новый Массив;
			
			Если НЕ ЗначениеЗаполнено(SubSegmentОбъект.Родитель) Тогда 
				
				//сделаем все подчиненные группы - элементами, иначе будет превышение уровня элементов
				Запрос = Новый Запрос;
				Запрос.УстановитьПараметр("SubSegment", SubSegmentОбъект.Ссылка);
				
				Запрос.Текст = "ВЫБРАТЬ
				               |	Сегменты.Ссылка,
				               |	Сегменты.Код,
				               |	Сегменты.Наименование
				               |ИЗ
				               |	Справочник.Сегменты КАК Сегменты
				               |ГДЕ
				               |	Сегменты.Ссылка В ИЕРАРХИИ(&SubSegment)
				               |	И Сегменты.ЭтоГруппа
				               |	И Сегменты.Ссылка <> &SubSegment";
				
				ТЗ = Запрос.Выполнить().Выгрузить();
				ТЗДляИзменения = ТЗ.Скопировать();
				
				Для Каждого СтрТЗДляИзменения из ТЗДляИзменения Цикл
					
					//Запоминаем ссылку на текущий элемент
					УникальнаяСсылка = Справочники.Сегменты.ПолучитьСсылку(СтрТЗДляИзменения.Ссылка.УникальныйИдентификатор());
					
					//Создаем новый элемент - группу
					НовыйЭлемент = Справочники.Сегменты.СоздатьЭлемент();    
					НовыйЭлемент.УстановитьСсылкуНового(УникальнаяСсылка);
					
					//... с такими же параметрами, что и текущий
					НовыйЭлемент.Код                 = СтрТЗДляИзменения.Код;
					НовыйЭлемент.Наименование        = СтрТЗДляИзменения.Наименование;
					НовыйЭлемент.Родитель            = SubSegmentОбъект.Ссылка;
					
					//Удаляем текущий
					СтрТЗДляИзменения.Ссылка.получитьОбъект().Удалить();
					
					//добавляем новый 
					МассивНовыхЭлементов.Добавить(НовыйЭлемент);
					  				
				КонецЦикла;
				
			КонецЕсли;

			РГСофтКлиентСервер.УстановитьЗначение(SubSegmentОбъект.Родитель, Segment);
		
			Если SubSegmentОбъект.Модифицированность() Тогда 
				SubSegmentОбъект.Записать();
			КонецЕсли;
			
			Для Каждого НовыйЭлемент из МассивНовыхЭлементов Цикл 
				НовыйЭлемент.Записать();
			КонецЦикла;
			
			SubSegment = SubSegmentОбъект.Ссылка;
			
		КонецЕсли;

	КонецЕсли;
		
	SubSubSegment = Справочники.Сегменты.НайтиПоКоду(СокрЛП(Стр.SubSubSegment));
	
	Если Не ЗначениеЗаполнено(SubSubSegment) Тогда 
		
		SubSubSegmentОбъект = Справочники.Сегменты.СоздатьЭлемент();
		SubSubSegmentОбъект.Код = СокрЛП(Стр.SubSubSegment);
		SubSubSegmentОбъект.Наименование = СокрЛП(Стр.SubSubSegment);
		SubSubSegmentОбъект.Родитель = SubSegment;
		SubSubSegmentОбъект.Записать();
		SubSubSegment = SubSubSegmentОбъект.Ссылка;
		
	иначе
		
		SubSubSegmentОбъект = SubSubSegment.получитьОбъект();
				
		Если SubSubSegmentОбъект.ЭтоГруппа Тогда 
			
			//Запоминаем ссылку на текущий элемент                           
			УникальнаяСсылка = Справочники.Сегменты.ПолучитьСсылку(SubSubSegmentОбъект.Ссылка.УникальныйИдентификатор());
			
			//Создаем новый элемент - группу
			НовыйЭлемент = Справочники.Сегменты.СоздатьЭлемент();    
			НовыйЭлемент.УстановитьСсылкуНового(УникальнаяСсылка);
			
			//... с такими же параметрами, что и текущий
			НовыйЭлемент.Код                 = SubSubSegmentОбъект.Код;
			НовыйЭлемент.Наименование        = SubSubSegmentОбъект.Наименование;
			НовыйЭлемент.Родитель            = SubSegment;
			
			//Удаляем текущий
			SubSubSegmentОбъект.Удалить();
			
			//Записываем новый (группу)
			НовыйЭлемент.Записать();
			
			SubSubSegment = НовыйЭлемент.Ссылка; 		
			
		иначе
									
			РГСофтКлиентСервер.УстановитьЗначение(SubSubSegmentОбъект.Родитель, SubSegment);
			Если SubSubSegmentОбъект.Модифицированность() Тогда 
				SubSubSegmentОбъект.Записать();
			КонецЕсли;
			
			SubSubSegment = SubSubSegmentОбъект.Ссылка;
			
		КонецЕсли;
		
	КонецЕсли;

КонецПроцедуры

Процедура LoadActivityCodesFromHUB() Экспорт
	
	//Производит загрузку Activity Codes из excel-файла "AUAC_OFS" с hub'a
	
	Обработки.ActivityCodesLoading.LoadActivityCodesFromHUB();	
	
КонецПроцедуры

Процедура КонтрольСвободногоМестаНаДисках() Экспорт 
	
	// процедура проверяет свободное место в GB на каждом диске
	// отсылает сообщение, если места меньше 10 GB подписчикам ошибок журнала регистрации
	
	СообщениеОНедостаткеСвободногоМеста = "";
	
	FSO = Новый COMОбъект("Scripting.FileSystemObject");
	Drives = FSO.Drives;
	
	Для Каждого ЭлементDrives из Drives Цикл 
		
		Если Не ЭлементDrives.IsReady Тогда 
			Продолжить;
		КонецЕсли;
		
		FreeSpaceInGB = Окр(ЭлементDrives.FreeSpace /(1024*1024*1024),1);
		
		Если FreeSpaceInGB < 10 Тогда 
			
			СообщениеОНедостаткеСвободногоМеста = СообщениеОНедостаткеСвободногоМеста + "
				|На диске """ + ЭлементDrives.DriveLetter + """ осталось " + FreeSpaceInGB + " Гб свободного места!";
			
		КонецЕсли;
		
	КонецЦикла;
	
	Если Не ПустаяСтрока(СообщениеОНедостаткеСвободногоМеста) Тогда 
		
		РГСофт.ЗарегистрироватьПочтовоеСообщение(
			Константы.АдресатыПолученияОтчетаПоЖурналуРегистрации.Получить(),
			"Контроль свободного места на дискаx " + ИмяКомпьютера(),
			СокрЛП(СообщениеОНедостаткеСвободногоМеста)); 
		
	КонецЕсли;
	       	
КонецПроцедуры

// { RGS LFedotova 03.08.2016 13:38:04 - SLI-0006667
Процедура РассчитатьTriggerDate(ДокОбъект) Экспорт

	Если НЕ ЗначениеЗаполнено(ДокОбъект.ДоговорКонтрагента) Тогда
		Возврат;
	КонецЕсли; 
	                                     
	Trigger = ДокОбъект.ДоговорКонтрагента.ermTrigger;
	
	Если НЕ ЗначениеЗаполнено(Trigger) Тогда
		TriggerDate = Дата(1,1,1);
	ИначеЕсли Trigger = Справочники.ermTriggerTypes.FirstDateOfNextMonth Тогда
		TriggerDate = ДобавитьМесяц(НачалоМесяца(ДокОбъект.Дата),1);
	ИначеЕсли Trigger = Справочники.ermTriggerTypes.FirstDayNextQuarter Тогда
		TriggerDate = ДобавитьМесяц(НачалоКвартала(ДокОбъект.Дата),3);
	ИначеЕсли Trigger = Справочники.ermTriggerTypes.InvoiceDate Тогда
		// { RGS LFedotova 15.09.2016 11:36:57 - вопрос SLI-0006787
		//TriggerDate = ДокОбъект.Дата;
		TriggerDate = НачалоДня(ДокОбъект.Дата);
		// } RGS LFedotova 15.09.2016 11:37:04 - вопрос SLI-0006787
	ИначеЕсли Trigger = Справочники.ermTriggerTypes.SignatureDate Тогда
		TriggerDate = ДокОбъект.ДатаВозвратаКС;
	ИначеЕсли Trigger = Справочники.ermTriggerTypes.SubmissionDate Тогда
		TriggerDate = ДокОбъект.ДатаОтправкиКС;
	ИначеЕсли Trigger = Справочники.ermTriggerTypes.ReceptionDate Тогда

		Запрос = Новый Запрос;
		Запрос.Текст = 
		"ВЫБРАТЬ ПЕРВЫЕ 2
		|	ДанныеПроизводственногоКалендаря.Дата КАК Дата
		|ПОМЕСТИТЬ ВТ
		|ИЗ
		|	РегистрСведений.ДанныеПроизводственногоКалендаря КАК ДанныеПроизводственногоКалендаря
		|ГДЕ
		|	ДанныеПроизводственногоКалендаря.Дата > &ДатаОтправкиКС
		|	И ДанныеПроизводственногоКалендаря.ВидДня = ЗНАЧЕНИЕ(Перечисление.ВидыДнейПроизводственногоКалендаря.Рабочий)
		|УПОРЯДОЧИТЬ ПО
		|	Дата ВОЗР
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ ПЕРВЫЕ 1
		|	ВТ.Дата КАК Дата
		|ИЗ
		|	ВТ КАК ВТ
		|
		|УПОРЯДОЧИТЬ ПО
		|	Дата УБЫВ";
		
		Запрос.УстановитьПараметр("ДатаОтправкиКС", ДокОбъект.ДатаОтправкиКС);
		
		РезультатЗапроса = Запрос.Выполнить();
		
		ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
		
		Если ВыборкаДетальныеЗаписи.Следующий() Тогда
			TriggerDate = ВыборкаДетальныеЗаписи.Дата; //плюс 2 рабочих дня, если заполнен производственный календарь
		Иначе
			TriggerDate = ДокОбъект.ДатаОтправкиКС + 3600*24*2; //плюс 2 дня
		КонецЕсли;
		// { RGS LFedotova 14.09.2016 18:35:15 - вопрос SLI-0006784
	Иначе
		TriggerDate = Дата(1,1,1);
		// } RGS LFedotova 14.09.2016 18:36:13 - вопрос SLI-0006784	
	КонецЕсли;
	
	Если НЕ ДокОбъект.ermTriggerDate = TriggerDate Тогда
		ДокОбъект.ermTriggerDate = TriggerDate;	
	КонецЕсли;
	
	Если ЗначениеЗаполнено(TriggerDate) Тогда

		// { RGS VChaplygin 11.08.2016 17:02:18 - Добавим расчет Due dates
		//ТипКалендарныхДней = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(ДокОбъект, "ДоговорКонтрагента.ermPtType");
		СтруктураЗначений = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(ДокОбъект.ДоговорКонтрагента, "ermPtType, ermPtDaysFrom, СрокОплаты");
		Если ВРег(СтруктураЗначений.ErmPtType) = ВРег("Business") Тогда

			Запрос = Новый Запрос;
			Текст = 
			"ВЫБРАТЬ ПЕРВЫЕ 4545
			|	ДанныеПроизводственногоКалендаря.Дата КАК Дата
			|ПОМЕСТИТЬ ВТ45
			|ИЗ
			|	РегистрСведений.ДанныеПроизводственногоКалендаря КАК ДанныеПроизводственногоКалендаря
			|ГДЕ
			|	ДанныеПроизводственногоКалендаря.Дата > &ДатаТриггера
			|	И ДанныеПроизводственногоКалендаря.ВидДня = ЗНАЧЕНИЕ(Перечисление.ВидыДнейПроизводственногоКалендаря.Рабочий)
			|УПОРЯДОЧИТЬ ПО
			|	Дата ВОЗР
			|;
			|
			|////////////////////////////////////////////////////////////////////////////////
			|
			|ВЫБРАТЬ ПЕРВЫЕ 6060
			|	ДанныеПроизводственногоКалендаря.Дата КАК Дата
			|ПОМЕСТИТЬ ВТ60
			|ИЗ
			|	РегистрСведений.ДанныеПроизводственногоКалендаря КАК ДанныеПроизводственногоКалендаря
			|ГДЕ
			|	ДанныеПроизводственногоКалендаря.Дата > &ДатаТриггера
			|	И ДанныеПроизводственногоКалендаря.ВидДня = ЗНАЧЕНИЕ(Перечисление.ВидыДнейПроизводственногоКалендаря.Рабочий)
			|УПОРЯДОЧИТЬ ПО
			|	Дата ВОЗР
			|;
			|
			|////////////////////////////////////////////////////////////////////////////////
			|ВЫБРАТЬ ПЕРВЫЕ 1
			|	ВТ.Дата КАК Дата
			|ИЗ
			|	ВТ45 КАК ВТ
			|
			|УПОРЯДОЧИТЬ ПО
			|	Дата УБЫВ
			|;
			|
			|////////////////////////////////////////////////////////////////////////////////
			|ВЫБРАТЬ ПЕРВЫЕ 1
			|	ВТ.Дата КАК Дата
			|ИЗ
			|	ВТ60 КАК ВТ
			|
			|УПОРЯДОЧИТЬ ПО
			|	Дата УБЫВ";
			
			Текст = СтрЗаменить(Текст, "4545", СтруктураЗначений.ErmPtDaysFrom);
			Запрос.Текст = СтрЗаменить(Текст, "6060", СтруктураЗначений.СрокОплаты);
			
			Запрос.УстановитьПараметр("ДатаТриггера", TriggerDate);
			
			МассивРезультатовЗапроса = Запрос.ВыполнитьПакет();
			
			ВыборкаДетальныеЗаписи = МассивРезультатовЗапроса[2].Выбрать();
			
			Если ВыборкаДетальныеЗаписи.Следующий() Тогда
				ermDueDateFrom = ВыборкаДетальныеЗаписи.Дата; //плюс N рабочих дня, если заполнен производственный календарь
			Иначе
				ermDueDateFrom = TriggerDate + 3600*24*СтруктураЗначений.ermPtDaysFrom; //плюс N дня
			КонецЕсли;
			
			
			ВыборкаДетальныеЗаписи = МассивРезультатовЗапроса[3].Выбрать();
			
			Если ВыборкаДетальныеЗаписи.Следующий() Тогда
				ermDueDateTo = ВыборкаДетальныеЗаписи.Дата; //плюс N рабочих дня, если заполнен производственный календарь
			Иначе
				ermDueDateTo = TriggerDate + 3600*24*СтруктураЗначений.СрокОплаты; //плюс N дня
			КонецЕсли;
			
			
			Если НЕ ДокОбъект.ermDueDateFrom = ermDueDateFrom Тогда
				ДокОбъект.ermDueDateFrom = ermDueDateFrom;	
			КонецЕсли;
			
			Если НЕ ДокОбъект.ermDueDateTo = ermDueDateTo Тогда
				ДокОбъект.ermDueDateTo = ermDueDateTo;	
			КонецЕсли;
			
		Иначе

			ermDueDateFrom = TriggerDate + 3600*24*СтруктураЗначений.ermPtDaysFrom; //плюс N дня
			
			ermDueDateTo = TriggerDate + 3600*24*СтруктураЗначений.СрокОплаты; //плюс N дня
			
			Если НЕ ДокОбъект.ermDueDateFrom = ermDueDateFrom Тогда
				ДокОбъект.ermDueDateFrom = ermDueDateFrom;	
			КонецЕсли;
			
			Если НЕ ДокОбъект.ermDueDateTo = ermDueDateTo Тогда
				ДокОбъект.ermDueDateTo = ermDueDateTo;	
			КонецЕсли;
			
		КонецЕсли;
		
	Иначе
		// { RGS LFedotova 15.08.2016 22:15:19 - вопрос SLI-0006704
		//ДокОбъект.ermDueDateFrom = Дата(1,1,1);
		//ДокОбъект.ermDueDateTo = Дата(1,1,1);
		Если ЗначениеЗаполнено(ДокОбъект.ermDueDateFrom) Тогда
			ДокОбъект.ermDueDateFrom = Дата(1,1,1);
		КонецЕсли; 
		Если ЗначениеЗаполнено(ДокОбъект.ermDueDateTo) Тогда
			ДокОбъект.ermDueDateTo = Дата(1,1,1);
		КонецЕсли; 
		// } RGS LFedotova 15.08.2016 22:15:40 - вопрос SLI-0006704
		
	КонецЕсли;
	// } RGS VChaplygin 11.08.2016 17:02:33 - Добавим расчет Due dates
	
КонецПроцедуры // } RGS LFedotova 03.08.2016 13:38:26 - SLI-0006667

// <Формирует строку параметров расчета Триггера>
//
// Параметры:
//  <Параметр1>  - <Тип.Вид> - <описание параметра>
//                 <продолжение описания параметра>
//  <Параметр2>  - <Тип.Вид> - <описание параметра>
//                 <продолжение описания параметра>
//
// { RGS VChaplygin 15.08.2016 10:18:19 - Добавить формирование строки параметров расчета
Функция ПолучитьНадписьПараметровРасчетаПлатежа(ДокОбъект) Экспорт

	СтрокаОписания = "";
	
	СтруктураРеквизитов = ОбщегоНазначения.ПолучитьЗначенияРеквизитов(ДокОбъект.ДоговорКонтрагента,
		"ermDocumentFlowPeriodFrom, ermDocumentFlowPeriodTo, ermPtDaysFrom, СрокОплаты, ermPtType, ermPtType, ermTrigger");

	
	Если ЗначениеЗаполнено(СтруктураРеквизитов.ermTrigger) Тогда
		СтрокаОписания = Строка(СтруктураРеквизитов.ermTrigger);
	Иначе
		СтрокаОписания = "<Trigger empty>";
	КонецЕсли;
	
	Если ЗначениеЗаполнено(СтруктураРеквизитов.ermPtDaysFrom) Тогда
		СтрокаОписания = СтрокаОписания + ", Pt(" + Строка(СтруктураРеквизитов.ermPtDaysFrom);
	Иначе
		СтрокаОписания = СтрокаОписания + ", Pt(..";
	КонецЕсли;
	
	Если ЗначениеЗаполнено(СтруктураРеквизитов.СрокОплаты) Тогда
		СтрокаОписания = СтрокаОписания + "," + Строка(СтруктураРеквизитов.СрокОплаты) + ")";
	Иначе
		СтрокаОписания = СтрокаОписания + ",..)";
	КонецЕсли;
	
	Если ЗначениеЗаполнено(СтруктураРеквизитов.ermPtType) Тогда
		СтрокаОписания = СтрокаОписания + "," + СтруктураРеквизитов.ermPtType;
	Иначе
		СтрокаОписания = СтрокаОписания + ",..";
	КонецЕсли;
	
	Возврат СтрокаОписания;	

// } RGS VChaplygin 15.08.2016 10:18:31 - Добавить формирование строки параметров расчета
КонецФункции // СформироватьНадписьОписаниеРасчетаТригера()
 
Функция ФормаМножественногоЧисла(Слово1, Слово2, Слово3, Знач ЦелоеЧисло) Экспорт

	// Изменим знак целого числа, иначе отрицательные числа будут неправильно преобразовываться
	Если ЦелоеЧисло < 0 Тогда
		ЦелоеЧисло = -1 * ЦелоеЧисло;
	КонецЕсли;
	
	Если ЦелоеЧисло <> Цел(ЦелоеЧисло) Тогда 
		// для нецелых чисел - всегда вторая форма
		Возврат Слово2;
	КонецЕсли;
	
	// остаток
	Остаток = ЦелоеЧисло%10;
	Если (ЦелоеЧисло >10) И (ЦелоеЧисло<20) Тогда
		// для второго десятка - всегда третья форма
		Возврат Слово3;
	ИначеЕсли Остаток=1 Тогда
		Возврат Слово1;
	ИначеЕсли (Остаток>1) И (Остаток<5) Тогда
		Возврат Слово2;
	Иначе
		Возврат Слово3;
	КонецЕсли;

КонецФункции

Функция ПроверитьРоль_LocalDistributionRequestor(User) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	ЕстьРоль = Ложь;
	Если ЗначениеЗаполнено(User) Тогда
		
		ИдентиФикаторПользователя = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(User, "ИдентификаторПользователяИБ");
		
		РолиПользователя = ПользователиИнформационнойБазы.НайтиПоУникальномуИдентификатору(ИдентиФикаторПользователя).Роли;
		МетаданныеРоли = Метаданные.Роли;
		
		ЕстьРоль = РолиПользователя.Содержит(МетаданныеРоли.LocalDistributionRequestor_ForNonLawsonCompanies);
		
		Если РолиПользователя.Содержит(МетаданныеРоли.LocalDistributionSpecialist_ForNonLawsonCompanies) 
			ИЛИ РолиПользователя.Содержит(МетаданныеРоли.LocalDistributionOperator_ForNonLawsonCompanies) 
			ИЛИ РолиПользователя.Содержит(МетаданныеРоли.LocalDistributionBillingSpecialist_ForNonLawsonCompanies)  
			ИЛИ РолиПользователя.Содержит(МетаданныеРоли.LocalDistributionAdministrator_ForNonLawsonCompanies) Тогда 
			ЕстьРоль = Ложь;
		КонецЕсли;
		
	КонецЕсли;
	
	Если ЕстьРоль Тогда
		Возврат "REQUESTER OPERATION";
	Иначе
		Возврат "LOGISTICS";
	КонецЕсли;
	
КонецФункции

Функция Перевод_M_в_FT(M) Экспорт
	
	Возврат Формат(M / 0.3048, "ЧДЦ=2");
	
КонецФункции

Функция Получить_PAYING_LEGAL_ENTITY(LE) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	|	LocalDistributionSettingsForNonLawsonCompaniesСрезПоследних.Company.CompanyNo КАК CompanyNo
	|ИЗ
	|	РегистрСведений.LocalDistributionSettingsForNonLawsonCompanies.СрезПоследних КАК LocalDistributionSettingsForNonLawsonCompaniesСрезПоследних
	|ГДЕ
	|	LocalDistributionSettingsForNonLawsonCompaniesСрезПоследних.DefaultLegalEntity = &LE";
	Запрос.УстановитьПараметр("LE", LE);
	Результат = Запрос.Выполнить();
	Если Результат.Пустой() Тогда
		Возврат LE.CompanyCode;
	Иначе
		Выборка = Результат.Выбрать();
		Выборка.Следующий();
		Возврат Выборка.CompanyNo;
	КонецЕсли;
	
КонецФункции

Функция Получить_OB_SEGMENT(LE, AU) Экспорт
	
	//Запрос = Новый Запрос;
	//Запрос.Текст = "ВЫБРАТЬ
	//|	SegmentsOfNonLawsonCompanies.SegmentCode
	//|ИЗ
	//|	Справочник.SegmentsOfNonLawsonCompanies КАК SegmentsOfNonLawsonCompanies
	//|ГДЕ
	//|	SegmentsOfNonLawsonCompanies.Владелец = &LE
	//|	И SegmentsOfNonLawsonCompanies.CostCenter = &AU
	//|	И SegmentsOfNonLawsonCompanies.ПометкаУдаления";
	//Запрос.УстановитьПараметр("AU", AU);
	//Запрос.УстановитьПараметр("LE", LE);
	//Результат = Запрос.Выполнить();
	//Если Результат.Пустой() Тогда
	//	Возврат "";
	//Иначе
	//	Выборка = Результат.Выбрать();
	//	Выборка.Следующий();
	//	Возврат Выборка.SegmentCode;
	//КонецЕсли;
	
	Возврат AU.Segment
	
КонецФункции

Функция TenderUpdate(Date, ModifiedBy) Экспорт
	
	Если ЗначениеЗаполнено(Date) Тогда
		ОтформатированнаяДата = Документы.APInvoice.ПреобразоватьДатуВСтроку(Date) + " " + Формат(Date, "ДФ=HH:mm:ss");
		Возврат "Updated By: " + СокрЛП(ModifiedBy) + " on " + ОтформатированнаяДата;
	Иначе
		Возврат "";
	КонецЕсли;
	
КонецФункции

Функция ОпределитьSubGeomatketДляБюджета(Geo,SubGeo) Экспорт
	
	RCA_Geomarket = Справочники.GeoMarkets.НайтиПоКоду("RCA");
	SKG_Geomarket = Справочники.GeoMarkets.НайтиПоКоду("SKG");
	TKG_Geomarket = Справочники.GeoMarkets.НайтиПоКоду("TKG");
	AZE_Geomarket = Справочники.GeoMarkets.НайтиПоКоду("AZE");
	KZU_Geomarket = Справочники.GeoMarkets.НайтиПоКоду("KZU");
	ASG_Geomarket = Справочники.GeoMarkets.НайтиПоКоду("ASG");
	
	Если Geo <> RCA_Geomarket Тогда
		Если Geo = SKG_Geomarket Тогда
			Возврат SKG_Geomarket
		ИначеЕсли Geo = TKG_Geomarket Тогда
			Возврат TKG_Geomarket
		ИначеЕсли Geo = AZE_Geomarket Тогда
			Возврат AZE_Geomarket
		ИначеЕсли Geo = KZU_Geomarket Тогда
			Возврат KZU_Geomarket
		ИначеЕсли Geo = ASG_Geomarket Тогда
			Возврат ASG_Geomarket
		Иначе
			Возврат SubGeo
		КонецЕсли;
	Иначе
		Возврат SubGeo;
	КонецЕсли;
	
КонецФункции

// { RGS AArsentev 05.12.2017
Функция ПолучитьДатуДляЗагрузкиВЗакрытыйПериод() Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	|	ДатыЗапретаИзменения.ДатаЗапрета КАК ДатаЗапрета
	|ИЗ
	|	РегистрСведений.ДатыЗапретаИзменения КАК ДатыЗапретаИзменения
	|ГДЕ
	|	ДатыЗапретаИзменения.Пользователь = &Пользователь
	|
	|УПОРЯДОЧИТЬ ПО
	|	ДатаЗапрета УБЫВ";
	Запрос.УстановитьПараметр("Пользователь", Справочники.Пользователи.НайтиПоКоду("ДляОбменаВЗакрытомПериоде"));
	Результат = Запрос.Выполнить();
	Если Результат.Пустой() Тогда 
		Возврат Неопределено;
	Иначе
		Выборка = Результат.Выбрать();
		Выборка.Следующий();
		Если ЗначениеЗаполнено(Выборка.ДатаЗапрета) Тогда 
			Возврат Выборка.ДатаЗапрета;
		Иначе
			Возврат Неопределено;
		КонецЕсли;
	КонецЕсли;
	
КонецФункции // } RGS AArsentev 05.12.2017

Процедура PullAttachmentsFromRCATLM() Экспорт
	
	// Процедура для одноименного регламентного задания
	УстановитьПривилегированныйРежим(Истина);
	
	ИнтернетПочтовыйПрофиль = ImportExportСерверПовтИспСеанс.ПолучитьИнтернетПочтовыйПрофильRCATLM();
	ИнтернетПочта = ImportExportСервер.ПодключитьсяКИнтернетПочте(ИнтернетПочтовыйПрофиль);
	
	ОбработанныеПисьма = Новый Массив;
	ОписаниеОшибки = Неопределено;
	Попытка
		
		НовыеПисьма = ImportExportСервер.ПолучитьUnprocessedEmails(ИнтернетПочта, ИнтернетПочтовыйПрофиль.ПользовательIMAP);
		ОбработанныеПисьма = Обработки.PullAttachmentsFromRCATLMEmails.ОбработатьПисьма(НовыеПисьма);
				
	Исключение
		
		ОписаниеОшибки = "Failed to load RCA-TLM attachments from e-mails:
			|" + ОписаниеОшибки();
			
	КонецПопытки;
	
	ИнтернетПочта.Отключиться();
	
	// Зарегистрируем обработанные письма
	МассивИдентификаторов = Новый Массив;
	Для Каждого ОбработанноеПисьмо Из ОбработанныеПисьма Цикл
		МассивИдентификаторов.Добавить(ОбработанноеПисьмо.Идентификатор[0]);
	КонецЦикла;

	Если МассивИдентификаторов.Количество() Тогда
		РегистрыСведений.UIDsOfProcessedEmails.ДобавитьНесколько(МассивИдентификаторов, ИнтернетПочтовыйПрофиль.ПользовательIMAP);
	КонецЕсли;
	
	Если ОписаниеОшибки <> Неопределено Тогда
		ВызватьИсключение ОписаниеОшибки;
	КонецЕсли;
	
КонецПроцедуры

// { RGS AArsentev 24.01.2018 S-I-0004386
Функция ПолучитьCheckData(CCD, PaymentKind) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	|	CustomsPaymentAllocation.CustomsPayment.Description КАК Description
	|ИЗ
	|	Документ.CustomsPaymentAllocation КАК CustomsPaymentAllocation
	|ГДЕ
	|	CustomsPaymentAllocation.PaymentKind = &PaymentKind
	|	И CustomsPaymentAllocation.CustomsDocument = &CustomsDocument";
	Запрос.УстановитьПараметр("CustomsDocument",CCD);
	Запрос.УстановитьПараметр("PaymentKind",PaymentKind);
	ДатаДляОтчета = "";
	Результат = Запрос.Выполнить();
	Если Результат.Пустой() Тогда
		Возврат ДатаДляОтчета;
	Иначе
		Выборка = Результат.Выбрать();
		Пока Выборка.Следующий() Цикл
			Если ЗначениеЗаполнено(Выборка.Description) Тогда
				РазбитаяСтрока = СтрЗаменить(Выборка.Description, "/",Символы.ПС);
				Для ИндексСтроки = 1 По СтрЧислоСтрок(РазбитаяСтрока) Цикл
					Подстрока = СтрПолучитьСтроку(РазбитаяСтрока, ИндексСтроки);
					Если Подстрока = "ДЕ" Тогда
						ИндексДаты = ИндексСтроки - 1;
						ЧастьДаты = СтрПолучитьСтроку(РазбитаяСтрока, ИндексДаты);
						Если СтрДлина(ЧастьДаты) = 8 Тогда
							Год = Лев(ЧастьДаты,4);
							Месяц = Сред(ЧастьДаты,5,2);
							День = Прав(ЧастьДаты,2);
							Если ЗначениеЗаполнено(ДатаДляОтчета) Тогда
								ДатаДляОтчета = ДатаДляОтчета + "
								|" + День + "." + Месяц + "." + Год;
							Иначе
								ДатаДляОтчета = "" + День + "." + Месяц + "." + Год
							КонецЕсли;
						Иначе
							Продолжить
						КонецЕсли;
					КонецЕсли;
				КонецЦикла;
			Иначе
				Продолжить;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Возврат ДатаДляОтчета;
	
КонецФункции // } RGS AArsentev 24.01.2018 S-I-0004386

// { RGS AArsentev 24.01.2018 S-I-0004386
Функция ПолучитьCheckNo(CCD, PaymentKind) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	|	CustomsPaymentAllocation.CustomsPayment.CheckNo КАК CheckNo
	|ИЗ
	|	Документ.CustomsPaymentAllocation КАК CustomsPaymentAllocation
	|ГДЕ
	|	CustomsPaymentAllocation.PaymentKind = &PaymentKind
	|	И CustomsPaymentAllocation.CustomsDocument = &CustomsDocument";
	Запрос.УстановитьПараметр("CustomsDocument",CCD);
	Запрос.УстановитьПараметр("PaymentKind",PaymentKind);
	CheckNoДляОтчета = "";
	Результат = Запрос.Выполнить();
	Если Результат.Пустой() Тогда
		Возврат CheckNoДляОтчета;
	Иначе
		Выборка = Результат.Выбрать();
		Пока Выборка.Следующий() Цикл
			Если ЗначениеЗаполнено(Выборка.CheckNo) Тогда
				Если ЗначениеЗаполнено(CheckNoДляОтчета) Тогда
					CheckNoДляОтчета = CheckNoДляОтчета + "
					|" + Выборка.CheckNo;
				Иначе
					CheckNoДляОтчета = "" + Выборка.CheckNo;
				КонецЕсли;
			Иначе
				Продолжить
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Возврат CheckNoДляОтчета;
	
КонецФункции // } RGS AArsentev 24.01.2018 S-I-0004386

// { RGS AArsentev 24.01.2018 S-I-0004386
Функция ПолучитьCheckDescription(CCD, PaymentKind) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	|	CustomsPaymentAllocation.CustomsPayment.Description КАК Description
	|ИЗ
	|	Документ.CustomsPaymentAllocation КАК CustomsPaymentAllocation
	|ГДЕ
	|	CustomsPaymentAllocation.PaymentKind = &PaymentKind
	|	И CustomsPaymentAllocation.CustomsDocument = &CustomsDocument";
	Запрос.УстановитьПараметр("CustomsDocument",CCD);
	Запрос.УстановитьПараметр("PaymentKind",PaymentKind);
	DescriptionДляОтчета = "";
	Результат = Запрос.Выполнить();
	Если Результат.Пустой() Тогда
		Возврат DescriptionДляОтчета;
	Иначе
		Выборка = Результат.Выбрать();
		Пока Выборка.Следующий() Цикл
			Если ЗначениеЗаполнено(Выборка.Description) Тогда
				Если ЗначениеЗаполнено(DescriptionДляОтчета) Тогда
					DescriptionДляОтчета = DescriptionДляОтчета + "
					|" + Выборка.Description;
				Иначе
					DescriptionДляОтчета = "" + Выборка.Description;
				КонецЕсли;
			Иначе
				Продолжить
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Возврат DescriptionДляОтчета;
	
КонецФункции // } RGS AArsentev 24.01.2018 S-I-0004386

Функция Перевод_CUMTR_в_CUFT(CUMTR) Экспорт
	
	Возврат Формат(CUMTR * 35.3146, "ЧДЦ=4");
	
КонецФункции

Функция Перевод_KG_в_LB(KG) Экспорт
	
	Возврат Формат(KG * 2.204, "ЧДЦ=2");
	
КонецФункции

Функция ApprovalUpdate(ApprovalDate, ApprovalManager) Экспорт
	
	Если ЗначениеЗаполнено(ApprovalDate) И ЗначениеЗаполнено(ApprovalManager) Тогда
		ОтформатированнаяДата = Документы.APInvoice.ПреобразоватьДатуВСтроку(ApprovalDate) + " " + Формат(ApprovalDate, "ДФ=HH:mm:ss");
		Возврат "Updated By: " + СокрЛП(ApprovalManager) + " on " + ОтформатированнаяДата;
	Иначе
		Возврат "";
	КонецЕсли;
	
КонецФункции

Функция TRANSPORT_MODE_GID(EQUIPMENT_GROUP) Экспорт
	
	Если СтрЧислоВхождений(EQUIPMENT_GROUP, "LTL") = 1 Тогда
		Возврат "LTL";
	Иначе 
		Возврат "TL";
	КонецЕсли
	
КонецФункции

// { RGS AFokin 02.11.2018 23:59:59 S-I-0006211
Функция ПолучитьСписокСегментовДляTrip(Trip) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	TripNonLawsonCompaniesParcels.Ссылка КАК Trip,
	|	ВЫБОР
	|		КОГДА ЕСТЬNULL(ВЫБОР
	|					КОГДА TripNonLawsonCompaniesParcels.Parcel.Ссылка.TransportRequest.LegalEntity.ERPID = ""LAWSON""
	|						ТОГДА ВЫБОР
	|								КОГДА TripNonLawsonCompaniesParcels.Parcel.Ссылка.TransportRequest.SegmentLawson.Код = ""SDTR""
	|										ИЛИ TripNonLawsonCompaniesParcels.Parcel.Ссылка.TransportRequest.SegmentLawson.Код = ""BITS""
	|									ТОГДА ""BDT""
	|								ИНАЧЕ TripNonLawsonCompaniesParcels.Parcel.Ссылка.TransportRequest.SegmentLawson.Код
	|							КОНЕЦ
	|					ИНАЧЕ ВЫБОР
	|							КОГДА TripNonLawsonCompaniesParcels.Parcel.Ссылка.TransportRequest.CostCenter.Segment.Код = ""SDTR""
	|									ИЛИ TripNonLawsonCompaniesParcels.Parcel.Ссылка.TransportRequest.CostCenter.Segment.Код = ""BITS""
	|								ТОГДА ""BDT""
	|							ИНАЧЕ TripNonLawsonCompaniesParcels.Parcel.Ссылка.TransportRequest.CostCenter.Segment.Код
	|						КОНЕЦ
	|				КОНЕЦ, """") = """"
	|			ТОГДА TripNonLawsonCompaniesParcels.Parcel.TransportRequest.Company.Код
	|		ИНАЧЕ ВЫБОР
	|				КОГДА TripNonLawsonCompaniesParcels.Parcel.Ссылка.TransportRequest.LegalEntity.ERPID = ""LAWSON""
	|					ТОГДА ВЫБОР
	|							КОГДА TripNonLawsonCompaniesParcels.Parcel.Ссылка.TransportRequest.SegmentLawson.Код = ""SDTR""
	|									ИЛИ TripNonLawsonCompaniesParcels.Parcel.Ссылка.TransportRequest.SegmentLawson.Код = ""BITS""
	|								ТОГДА ""BDT""
	|							ИНАЧЕ TripNonLawsonCompaniesParcels.Parcel.Ссылка.TransportRequest.SegmentLawson.Код
	|						КОНЕЦ
	|				ИНАЧЕ ВЫБОР
	|						КОГДА TripNonLawsonCompaniesParcels.Parcel.Ссылка.TransportRequest.CostCenter.Segment.Код = ""SDTR""
	|								ИЛИ TripNonLawsonCompaniesParcels.Parcel.Ссылка.TransportRequest.CostCenter.Segment.Код = ""BITS""
	|							ТОГДА ""BDT""
	|						ИНАЧЕ TripNonLawsonCompaniesParcels.Parcel.Ссылка.TransportRequest.CostCenter.Segment.Код
	|					КОНЕЦ
	|			КОНЕЦ
	|	КОНЕЦ КАК Сегмент
	|ИЗ
	|	Документ.TripNonLawsonCompanies.Parcels КАК TripNonLawsonCompaniesParcels
	|ГДЕ
	|	TripNonLawsonCompaniesParcels.Ссылка = &Trip";

	Запрос.УстановитьПараметр("Trip", Trip);
	РезультатЗапроса = Запрос.Выполнить();
	
	СписокСегментов = "";
	
	Если НЕ РезультатЗапроса.Пустой() Тогда
		Выборка = РезультатЗапроса.Выбрать();
		Пока Выборка.Следующий() Цикл
			СписокСегментов = СписокСегментов + СокрЛП(Выборка.Сегмент) + ", ";
		КонецЦикла;	
	КонецЕсли;
	СписокСегментов = Лев(СписокСегментов, СтрДлина(СписокСегментов) - 2);
	Возврат СписокСегментов;	
	
КонецФункции // { RGS AFokin 02.11.2018 23:59:59 S-I-0006211	

Функция Parcel_Change_Events(Parcel) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	|	ParcelChangeEvents.Parcel КАК Parcel,
	|	ParcelChangeEvents.Date КАК Date,
	|	ParcelChangeEvents.Event КАК Event,
	|	ParcelChangeEvents.Before КАК Before,
	|	ParcelChangeEvents.After КАК After,
	|	1 КАК Event_Kol
	|ПОМЕСТИТЬ Events
	|ИЗ
	|	РегистрСведений.ParcelChangeEvents КАК ParcelChangeEvents
	|ГДЕ
	|	ParcelChangeEvents.Parcel = &Parcel
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	СУММА(Events.Event_Kol) КАК Event_Kol
	|ИЗ
	|	Events КАК Events";
	Запрос.УстановитьПараметр("Parcel", Parcel);
	Результат = Запрос.Выполнить();
	Если Результат.Пустой() Тогда
		Возврат 0
	Иначе
		Выборка = Результат.Выбрать();
		Выборка.Следующий();
		Возврат Выборка.Event_Kol;
	КонецЕсли;
	
КонецФункции

Функция ПользователиИзменявшиеПарсель(Parcel) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	|	ParcelLogs.User.Наименование КАК User
	|ИЗ
	|	РегистрСведений.ParcelLogs КАК ParcelLogs
	|ГДЕ
	|	ParcelLogs.LogTo = &LogTo
	|
	|СГРУППИРОВАТЬ ПО
	|	ParcelLogs.User.Наименование";
	Запрос.УстановитьПараметр("LogTo", Parcel);
	
	Результат = Запрос.Выполнить().Выгрузить();
	
	Если Результат.Количество() > 0 Тогда
		Для Каждого Строка Из Результат Цикл
			Строка.User = СокрЛП(Строка.User);
		КонецЦикла;
		Возврат РГСофтКлиентСервер.ВыгрузитьКолонкуКоллекцииБезПустыхЗначенийИДублей(Результат, "User");
	Иначе
		Возврат "";
	КонецЕсли;
	
КонецФункции

// { RGS AArsentev 10.04.2018 S-I-0005007
Функция ПолучитьEquipmentGroup(Trip, NamingConvention, TypeOfTransport, EquipmentType, EquipmentNo) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	|	TripNonLawsonCompaniesParcels.Parcel.TransportRequest.Country КАК Country
	|ИЗ
	|	Документ.TripNonLawsonCompanies.Parcels КАК TripNonLawsonCompaniesParcels
	|ГДЕ
	|	TripNonLawsonCompaniesParcels.Ссылка = &Trip
	|
	|СГРУППИРОВАТЬ ПО
	|	TripNonLawsonCompaniesParcels.Parcel.TransportRequest.Country";
	Запрос.УстановитьПараметр("Trip", Trip);
	
	EquipmentGroup = "";
	
	Результат = Запрос.Выполнить();
	Если Результат.Пустой() тогда
		Возврат EquipmentGroup;
	Иначе
		Выборка = Результат.Выбрать();
		Если Выборка.Количество() > 1 Тогда
			Возврат EquipmentGroup;
		Иначе
			Выборка.Следующий();
			EquipmentGroup = "" + Выборка.Country + "_";
			Если TypeOfTransport = Перечисления.TypesOfTransport.Rental Тогда
				EquipmentGroup = EquipmentGroup + "RTL_" + NamingConvention + "_" + EquipmentType + "_" + EquipmentNo;
			ИначеЕсли TypeOfTransport = Перечисления.TypesOfTransport.CallOut Тогда
				EquipmentGroup = EquipmentGroup + "CLO_" + NamingConvention + "_" + EquipmentType;
			Иначе
				Возврат "";
			КонецЕсли;
			Возврат EquipmentGroup;
		КонецЕсли;
	КонецЕсли;
	
КонецФункции // } RGS AArsentev 10.04.2018 S-I-0005007

// { RGS AArsentev 17.05.2018
Функция УбратьПробелыВДате(ДатаИзЗапроса) Экспорт
	
	Если ЗначениеЗаполнено(ДатаИзЗапроса) Тогда
		ДатаВСтроку = Формат(ДатаИзЗапроса, "ДФ='yyyy-MM-dd  HH:mm:ss'");
		ДатаВСтроку = СтрЗаменить(ДатаВСтроку, "  ", " ");
		Возврат ДатаВСтроку;
	КонецЕсли;
	
КонецФункции //  RGS AArsentev 17.05.2018

Функция ПолучитьCustomsFilesLightДляShipment(DocumentBase, InvoiceLine) Экспорт
	// Вызов из отчёта AgentInvoiceDetails
	
	Если ТипЗнч(DocumentBase) = Тип("ДокументСсылка.Поставка") ИЛИ ТипЗнч(DocumentBase) = Тип("ДокументСсылка.ExportShipment") Тогда
		
		Запрос = Новый Запрос;
		Запрос.УстановитьПараметр("Shipment", DocumentBase);
		Запрос.УстановитьПараметр("InvoiceLine", InvoiceLine);
		Запрос.Текст = 
		"ВЫБРАТЬ
		|	CustomsFilesLightItems.Ссылка.Номер КАК НомерCFL
		|ИЗ
		|	Документ.CustomsFilesLight.Items КАК CustomsFilesLightItems
		|ГДЕ
		|	CustomsFilesLightItems.Ссылка.Shipment = &Shipment
		|	И CustomsFilesLightItems.Ссылка.Проведен
		|	И CustomsFilesLightItems.Item = &InvoiceLine";
		
		Результат = Запрос.Выполнить().Выгрузить();
		СписокНомеров = РГСофтКлиентСервер.ПолучитьСтрокуИзМассиваПодстрокСокрЛП(Результат.ВыгрузитьКолонку("НомерCFL"),", ");
		
		Возврат СписокНомеров;
		
	Иначе
		
		Возврат "";
		
	КонецЕсли;
	
КонецФункции

Функция ДанныеВнутреннейТаблицыЗапроса(Запрос, ИмяВнутреннейТаблицы) Экспорт
    Запрос.Текст="
    |ВЫБРАТЬ
    |    *
    |ИЗ
    |    " + ИмяВнутреннейТаблицы + " КАК Таблица";

    Возврат Запрос.Выполнить().Выгрузить();
	
КонецФункции

// } RGS ASeryakov 28.02.2018 15:00:00 - вопрос S-I-0004726

// { RGS DKazanskiy 23.05.2018 14:05:03 - S-I-0005276

Функция КоличествоРабочихДнейДляСтатуса(Ссылка, Статус, СледующийСтатус, ТолькоРабочие, КонецПериода) Экспорт

	ДатаСтатуса 			= НачалоДня(ПолучитьДатуСтатусаDOC(Ссылка, Статус));
	ДатаСледующегоСтатуса 	= Неопределено;
	Если НЕ СледующийСтатус = Неопределено Тогда
		ДатаСледующегоСтатуса = НачалоДня(ПолучитьДатуСтатусаDOC(Ссылка, СледующийСтатус));
	КонецЕсли;
	
	Возврат РасчитатьКоличествоРабочихДнейПериодаПоКалендарю(ТолькоРабочие, ДатаСтатуса, ?(ЗначениеЗаполнено(ДатаСледующегоСтатуса), ДатаСледующегоСтатуса, КонецПериода));
	
КонецФункции // КоличествоРабочихДнейДляСтатуса()

Функция ПолучитьДатуСтатусаDOC(DOC, Статус) Экспорт
	
	ManualStatuses = DOC.ManualStatuses;	
	
	ДатаСтатусаПоиска = '00010101';
	СтатусПоискаПред  = Неопределено; 
	
	//1. Ручных статусов нет
	КолВо = ManualStatuses.Количество() ;
	Если КолВо = 0 Тогда
		
		Если DOC.CurrentStatus = Статус Тогда
			ДатаСтатусаПоиска = DOC.CurrentStatusDate;
			СтатусПоискаПред  = DOC.CurrentStatus; 
		КонецЕсли;
		
	ИначеЕсли КолВо = 1 Тогда
		
		Если ManualStatuses[0].Status = Статус Тогда
			ДатаСтатусаПоиска = ManualStatuses[0].Date;
			СтатусПоискаПред  = ManualStatuses[0].Status;
		КонецЕсли;
		
		//2. ОдинаковыеСтатусы
	Иначе 
		
		Отбор = Новый Структура;
		Отбор.Вставить("Status", Статус);
		
		СвернутаяПоСтатусам = ManualStatuses.Выгрузить(Отбор, "Status");
		СвернутаяПоСтатусам.Свернуть("Status");
		
		Если СвернутаяПоСтатусам.Количество() = 1  Тогда
			
			ДатаСтатусаПоиска = ManualStatuses[0].Date;
			СтатусПоискаПред  = ManualStatuses[0].Status;
			
		Иначе
			
			СтрокаПоиска = ManualStatuses[КолВо-1];
			
			СтатусПоиска = СтрокаПоиска.Status;
			ДатаСтатусаПоиска = СтрокаПоиска.Date;
			
			СтатусПоискаПредП = ManualStatuses[КолВо-2].Status;
			
			//3. ПервыйСтатусВГруппе
			Если СтатусПоиска = СтатусПоискаПредП Тогда
				
				СтрокаПоследняя = ManualStatuses[КолВо-1];
				ПоследнийСтатус = СтрокаПоследняя.Status;
				ДатаПоискаПред   = СтрокаПоследняя.Date;	
				
				Пока КолВо <> 0 Цикл
					
					СтрокаПоискаПред = ManualStatuses[КолВо-1];				
					СтатусПоискаПред = СтрокаПоискаПред.Status;
					
					Если  ПоследнийСтатус <> СтатусПоискаПред Тогда
						
						СтрокаПоискаПред = ManualStatuses[КолВо];				
						ДатаПоискаПред   = СтрокаПоискаПред.Date;
						
						Прервать;					
					КонецЕсли;
					
					КолВо = КолВо -1;
				КонецЦикла;
				
				// Вернуть Дату 
				ДатаСтатусаПоиска = ДатаПоискаПред;
				
				
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Если СтатусПоискаПред = Перечисления.DOCStatuses.PendingHUB И  НачалоДня(ДатаСтатусаПоиска) > DOC.Received Тогда		
		ДатаСтатусаПоиска = Дата('00010101');	
	КонецЕсли;
	
	Возврат ДатаСтатусаПоиска;
	
КонецФункции // ПолучитьДатуСтатусаDOC()
