////////////////////////////////////////////////////////////////////////////////
// Подсистема "Базовая функциональность".
// Серверные процедуры и функции общего назначения:
// - для работы с данными в базе;
// - для работы с прикладными типами и коллекциями значений;
// - математические процедуры и функции;
// - для работы с внешним соединением;
// - для работы с формами;
// - для работы с типами, объектами метаданных и их строковыми представлениями;
// - функции определения типов объектов метаданных;
// - сохранение, чтение и удаление настроек из хранилищ;
// - для работы с табличными документами;
// - для работы с журналом регистрации;
// - для работы в режиме разделения данных;
// - версионирование программных интерфейсов;
// - вспомогательные процедуры и функции.
//
////////////////////////////////////////////////////////////////////////////////

#Область ПрограммныйИнтерфейс

////////////////////////////////////////////////////////////////////////////////
// Общие процедуры и функции для работы с данными в базе.

// Возвращает структуру, содержащую значения реквизитов прочитанные из информационной базы
// по ссылке на объект.
// 
//  Если доступа к одному из реквизитов нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
// 
// Функция не предназначена для получения значений реквизитов пустых ссылок.
//
// Параметры:
//  Ссылка    - ЛюбаяСсылка - объект, значения реквизитов которого необходимо получить.
//
//  Реквизиты - Строка - имена реквизитов, перечисленные через запятую, в формате
//              требований к свойствам структуры.
//              Например, "Код, Наименование, Родитель".
//            - Структура, ФиксированнаяСтруктура - в качестве ключа передается
//              псевдоним поля для возвращаемой структуры с результатом, а в качестве
//              значения (опционально) фактическое имя поля в таблице.
//              Если значение не определено, то имя поля берется из ключа.
//            - Массив, ФиксированныйМассив - имена реквизитов в формате требований
//              к свойствам структуры.
//
// Возвращаемое значение:
//  Структура - содержит имена (ключи) и значения затребованных реквизитов.
//              Если строка затребованных реквизитов пуста, то возвращается пустая структура.
//              Если в качестве объекта передана пустая ссылка, то все реквизиты вернутся со значением Неопределено.
//
Функция ЗначенияРеквизитовОбъекта(Ссылка, Знач Реквизиты) Экспорт
	
	Если ТипЗнч(Реквизиты) = Тип("Строка") Тогда
		Если ПустаяСтрока(Реквизиты) Тогда
			Возврат Новый Структура;
		КонецЕсли;
		Реквизиты = СтрРазделить(Реквизиты, ",", Ложь);
	КонецЕсли;
	
	СтруктураРеквизитов = Новый Структура;
	Если ТипЗнч(Реквизиты) = Тип("Структура") Или ТипЗнч(Реквизиты) = Тип("ФиксированнаяСтруктура") Тогда
		СтруктураРеквизитов = Реквизиты;
	ИначеЕсли ТипЗнч(Реквизиты) = Тип("Массив") Или ТипЗнч(Реквизиты) = Тип("ФиксированныйМассив") Тогда
		Для Каждого Реквизит Из Реквизиты Цикл
			СтруктураРеквизитов.Вставить(СтрЗаменить(Реквизит, ".", ""), Реквизит);
		КонецЦикла;
	Иначе
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ВернутьСтр("ru = 'Неверный тип второго параметра Реквизиты: %1'"), Строка(ТипЗнч(Реквизиты)));
	КонецЕсли;
	
	ТекстПолей = "";
	Для Каждого КлючИЗначение Из СтруктураРеквизитов Цикл
		ИмяПоля   = ?(ЗначениеЗаполнено(КлючИЗначение.Значение),
		              СокрЛП(КлючИЗначение.Значение),
		              СокрЛП(КлючИЗначение.Ключ));
		// { RGS LFedotova 01.02.2017 11:19:13 - вопрос SLI-0007126
		Если ТипЗнч(Ссылка) = Тип("ДокументСсылка.СчетКнигиПокупок")
			И ИмяПоля = "Urn" Тогда
		 
		 	ИмяПоля = "ПроводкаDSS.Urn";
		 
		 КонецЕсли;
		// } RGS LFedotova 01.02.2017 11:19:36 - вопрос SLI-0007126			  
					  
		Псевдоним = СокрЛП(КлючИЗначение.Ключ);
		
		ТекстПолей  = ТекстПолей + ?(ПустаяСтрока(ТекстПолей), "", ",") + "
		|	" + ИмяПоля + " КАК " + Псевдоним;
	КонецЦикла;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	Запрос.Текст =
	"ВЫБРАТЬ
	|" + ТекстПолей + "
	|ИЗ
	|	" + Ссылка.Метаданные().ПолноеИмя() + " КАК ПсевдонимЗаданнойТаблицы
	|ГДЕ
	|	ПсевдонимЗаданнойТаблицы.Ссылка = &Ссылка
	|";
	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий();
	
	Результат = Новый Структура;
	Для Каждого КлючИЗначение Из СтруктураРеквизитов Цикл
		Результат.Вставить(КлючИЗначение.Ключ);
	КонецЦикла;
	ЗаполнитьЗначенияСвойств(Результат, Выборка);
	
	Возврат Результат;
	
КонецФункции

// Возвращает значение реквизита, прочитанного из информационной базы по ссылке на объект.
// 
//  Если доступа к реквизиту нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
//
// Функция не предназначена для получения значений реквизитов пустых ссылок.
// 
// Параметры:
//  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
//  ИмяРеквизита - Строка, например, "Код".
// 
// Возвращаемое значение:
//  Произвольный    - зависит от типа значения прочитанного реквизита.
// 
Функция ЗначениеРеквизитаОбъекта(Ссылка, ИмяРеквизита) Экспорт
	
	Результат = ЗначенияРеквизитовОбъекта(Ссылка, ИмяРеквизита);
	Возврат Результат[СтрЗаменить(ИмяРеквизита, ".", "")];
	
КонецФункции 

// Возвращает значения реквизитов, прочитанные из информационной базы
// для нескольких объектов.
// 
//  Если доступа к одному из реквизитов нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
//
// Функция не предназначена для получения значений реквизитов пустых ссылок.
// 
// Параметры:
//  МассивСсылок - массив ссылок на объекты одного типа.
//				ВАЖНО! значения массива должны быть ссылками на 
//				объекты одного типа!
//  ИменаРеквизитов - Строка, имена реквизитов перечисленные через запятую,
//				в формате требований к свойствам структуры.
//				Например, "Код, Наименование, Родитель".
// 
// Возвращаемое значение:
//  Соответствие - где ключ - ссылка на объект, а Значение - структура, которая 
//		   		содержит список свойств, как список имен в строке.
//				ИменаРеквизитов, со значениям реквизитов, прочитанными из информационной базы.
// 
Функция ЗначенияРеквизитовОбъектов(МассивСсылок, ИменаРеквизитов) Экспорт
	
	ЗначенияРеквизитов = Новый Соответствие;
	Если МассивСсылок.Количество() = 0 Тогда
		Возврат ЗначенияРеквизитов;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
		"ВЫБРАТЬ
		|	Ссылка КАК Ссылка, " + ИменаРеквизитов + "
		|ИЗ
		|	" + МассивСсылок[0].Метаданные().ПолноеИмя() + " КАК Таблица
		|ГДЕ
		|	Таблица.Ссылка В (&МассивСсылок)";
	Запрос.УстановитьПараметр("МассивСсылок", МассивСсылок);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Результат = Новый Структура(ИменаРеквизитов);
		ЗаполнитьЗначенияСвойств(Результат, Выборка);
		ЗначенияРеквизитов[Выборка.Ссылка] = Результат;
	КонецЦикла;
	
	Возврат ЗначенияРеквизитов;
	
КонецФункции

// Возвращает значения реквизита, прочитанного из информационной базы для нескольких объектов.
// 
//  Если доступа к реквизиту нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
// 
// Функция не предназначена для получения значений реквизитов пустых ссылок.
//
// Параметры:
//  МассивСсылок - массив ссылок на объекты одного типа.
//				ВАЖНО! значения массива должны быть ссылками на 
//				объекты одного типа!
//  ИмяРеквизита - Строка, например, "Код".
// 
// Возвращаемое значение:
//  Соответствие - Ключ - ссылка на объект, Значение - значение прочитанного реквизита.
// 
Функция ЗначениеРеквизитаОбъектов(МассивСсылок, ИмяРеквизита) Экспорт
	
	ЗначенияРеквизитов = ЗначенияРеквизитовОбъектов(МассивСсылок, ИмяРеквизита);
	Для Каждого Элемент Из ЗначенияРеквизитов Цикл
		ЗначенияРеквизитов[Элемент.Ключ] = Элемент.Значение[ИмяРеквизита];
	КонецЦикла;
		
	Возврат ЗначенияРеквизитов;
	
КонецФункции

//Добавила Федотова Л., РГ-Софт, 09.02.16, вопрос SLI-0006176 
Функция ПолучитьКППНаДату(Контрагент,Дата) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	КонтрагентыИсторияКПП.Ссылка КАК Контрагент,
		|	КонтрагентыИсторияКПП.Период,
		|	КонтрагентыИсторияКПП.КПП
		|ПОМЕСТИТЬ ИсторияКПП
		|ИЗ
		|	Справочник.Контрагенты.ИсторияКПП КАК КонтрагентыИсторияКПП
		|ГДЕ
		|	КонтрагентыИсторияКПП.Период <= &Дата
		|	И КонтрагентыИсторияКПП.Ссылка = &Контрагент
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ
		|	ИсторияКПП.Контрагент,
		|	МАКСИМУМ(ИсторияКПП.Период) КАК Период
		|ПОМЕСТИТЬ ДатаКПП
		|ИЗ
		|	ИсторияКПП КАК ИсторияКПП
		|
		|СГРУППИРОВАТЬ ПО
		|	ИсторияКПП.Контрагент
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ
		|	ИсторияКПП.Контрагент,
		|	ИсторияКПП.КПП
		|ИЗ
		|	ИсторияКПП КАК ИсторияКПП
		|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ДатаКПП КАК ДатаКПП
		|		ПО ИсторияКПП.Период = ДатаКПП.Период";
	
	Запрос.УстановитьПараметр("Контрагент", Контрагент);
	Запрос.УстановитьПараметр("Дата", Дата);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
	
	Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
		Возврат ВыборкаДетальныеЗаписи.КПП;
	КонецЦикла;
	
	Возврат Контрагент.КПП;
	
КонецФункции 

// Проверяет проведенность документов.
//
// Параметры:
//  Документы - Массив - документы, проведенность которых необходимо проверить.
//
// Возвращаемое значение:
//  Массив - непроведенные документы из массива Документы.
//
Функция ПроверитьПроведенностьДокументов(Знач Документы) Экспорт
	
	Результат = Новый Массив;
	
	ШаблонЗапроса = 	
		"ВЫБРАТЬ
		|	ПсевдонимЗаданнойТаблицы.Ссылка КАК Ссылка
		|ИЗ
		|	&ИмяДокумента КАК ПсевдонимЗаданнойТаблицы
		|ГДЕ
		|	ПсевдонимЗаданнойТаблицы.Ссылка В(&МассивДокументов)
		|	И НЕ ПсевдонимЗаданнойТаблицы.Проведен";
	
	ТекстОбъединитьВсе =
		"
		|
		|ОБЪЕДИНИТЬ ВСЕ
		|
		|";
		
	ИменаДокументов = Новый Массив;
	Для Каждого Документ Из Документы Цикл
		МетаданныеДокумента = Документ.Метаданные();
		Если ИменаДокументов.Найти(МетаданныеДокумента.ПолноеИмя()) = Неопределено
			И Метаданные.Документы.Содержит(МетаданныеДокумента)
			И МетаданныеДокумента.Проведение = Метаданные.СвойстваОбъектов.Проведение.Разрешить Тогда
				ИменаДокументов.Добавить(МетаданныеДокумента.ПолноеИмя());
		КонецЕсли;
	КонецЦикла;
	
	ТекстЗапроса = "";
	Для Каждого ИмяДокумента Из ИменаДокументов Цикл
		Если Не ПустаяСтрока(ТекстЗапроса) Тогда
			ТекстЗапроса = ТекстЗапроса + ТекстОбъединитьВсе;
		КонецЕсли;
		ТекстПодзапроса = СтрЗаменить(ШаблонЗапроса, "&ИмяДокумента", ИмяДокумента);
		ТекстЗапроса = ТекстЗапроса + ТекстПодзапроса;
	КонецЦикла;
		
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("МассивДокументов", Документы);
	
	Если Не ПустаяСтрока(ТекстЗапроса) Тогда
		Результат = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Выполняет попытку проведения документов.
//
// Параметры:
//	Документы                - Массив - документы, которые необходимо провести.
//
// Возвращаемое значение:
//	Массив - массив структур с полями:
//			 Ссылка         - документ, который не удалось провести;
//			 ОписаниеОшибки - текст описания ошибки при проведении.
//
Функция ПровестиДокументы(Документы) Экспорт
	
	НепроведенныеДокументы = Новый Массив;
	
	Для Каждого ДокументСсылка Из Документы Цикл
		
		ВыполненоУспешно = Ложь;
		ДокументОбъект = ДокументСсылка.ПолучитьОбъект();
		Если ДокументОбъект.ПроверитьЗаполнение() Тогда
			РежимПроведения = РежимПроведенияДокумента.Неоперативный;
			Если ДокументОбъект.Дата >= НачалоДня(ТекущаяДатаСеанса())
				И ДокументСсылка.Метаданные().ОперативноеПроведение = Метаданные.СвойстваОбъектов.ОперативноеПроведение.Разрешить Тогда
					РежимПроведения = РежимПроведенияДокумента.Оперативный;
			КонецЕсли;
			Попытка
				ДокументОбъект.Записать(РежимЗаписиДокумента.Проведение, РежимПроведения);
				ВыполненоУспешно = Истина;
			Исключение
				ПредставлениеОшибки = КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
			КонецПопытки;
		Иначе
			ПредставлениеОшибки = ВернутьСтр("ru = 'Поля документа не заполнены.'");
		КонецЕсли;
		
		Если Не ВыполненоУспешно Тогда
			НепроведенныеДокументы.Добавить(Новый Структура("Ссылка,ОписаниеОшибки", ДокументСсылка, ПредставлениеОшибки));
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат НепроведенныеДокументы;
	
КонецФункции 

// Проверяет наличие ссылок на объект в базе данных.
//
// Параметры:
//  Ссылка       - ЛюбаяСсылка
//               - Массив значений типа ЛюбаяСсылка.
//
//  ИскатьСредиСлужебныхОбъектов - Булево - начальное значение Ложь,
//                 когда установлено Истина, тогда не будут учитываться
//                 исключения поиска ссылок, заданные при разработке конфигурации.
//
//  ДругиеИсключения - Массив полных имен объектов метаданных, которые также
//                 требуется исключить из поиска ссылок.
//
// Возвращаемое значение:
//  Булево.
//
Функция ЕстьСсылкиНаОбъект(Знач СсылкаИлиМассивСсылок, Знач ИскатьСредиСлужебныхОбъектов = Ложь,  ДругиеИсключения = Неопределено) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если ТипЗнч(СсылкаИлиМассивСсылок) = Тип("Массив") Тогда
		МассивСсылок = СсылкаИлиМассивСсылок;
	Иначе
		МассивСсылок = Новый Массив;
		МассивСсылок.Добавить(СсылкаИлиМассивСсылок);
	КонецЕсли;
	
	ТаблицаСсылок = НайтиПоСсылкам(МассивСсылок);
	ТаблицаСсылок.Колонки[0].Имя = "ИсходнаяСсылка";
	ТаблицаСсылок.Колонки[1].Имя = "ОбнаруженныйСсылка";
	ТаблицаСсылок.Колонки[2].Имя = "ОбнаруженныйМетаданные";
	
	Если НЕ ИскатьСредиСлужебныхОбъектов Тогда
		ИсключенияПоискаСсылок = ПолучитьОбщийСписокИсключенийПоискаСсылок();
		Исключения = Новый Массив;
		
		Для Каждого СтрокаТаблицы Из ТаблицаСсылок Цикл
			ИсключениеПоиска = ИсключенияПоискаСсылок[СтрокаТаблицы.ОбнаруженныйМетаданные];
			Если ИсключениеПоиска = "*" Тогда
				Исключения.Добавить(СтрокаТаблицы);
			КонецЕсли;
		КонецЦикла;
		
		Для Каждого СтрокаТаблицы Из Исключения Цикл
			ТаблицаСсылок.Удалить(СтрокаТаблицы);
		КонецЦикла;
	КонецЕсли;
	
	Если ТипЗнч(ДругиеИсключения) = Тип("Массив") Тогда
		ИсключенияПоискаСсылок = Новый Соответствие;
		Исключения = Новый Массив;
		
		Для каждого ПолноеИмя Из ДругиеИсключения Цикл
			ОбъектМетаданных = Метаданные.НайтиПоПолномуИмени(ПолноеИмя);
			Если ОбъектМетаданных <> Неопределено Тогда
				ИсключенияПоискаСсылок.Вставить(ОбъектМетаданных, "*");
			КонецЕсли;
		КонецЦикла;
		
		Для Каждого СтрокаТаблицы Из ТаблицаСсылок Цикл
			ИсключениеПоиска = ИсключенияПоискаСсылок[СтрокаТаблицы.ОбнаруженныйМетаданные];
			Если ИсключениеПоиска = "*" Тогда
				Исключения.Добавить(СтрокаТаблицы);
			КонецЕсли;
		КонецЦикла;
		
		Для Каждого СтрокаТаблицы Из Исключения Цикл
			ТаблицаСсылок.Удалить(СтрокаТаблицы);
		КонецЦикла;
	КонецЕсли;
	
	Возврат ТаблицаСсылок.Количество() > 0;
	
КонецФункции

// Производит замену ссылок во всех данных. После замены неиспользуемые ссылки опционально удаляются.
// Замена ссылок происходит с транзакциями по изменяемому объекту и его связям, не по анализируемой ссылке.
//
// Параметры:
//   ПарыЗамен - Соответствие - Пары замен.
//       * Ключ     - ЛюбаяСсылка - Что ищем (дубль).
//       * Значение - ЛюбаяСсылка - На что заменяем (оригинал).
//       Ссылки сами на себя и пустые ссылки для поиска будут проигнорированы.
//   
//   Параметры - Структура - Необязательный. Параметры замены.
//       
//       * СпособУдаления - Строка - Необязательный. Что делать с дублем после успешной замены.
//           ""                - По умолчанию. Не предпринимать никаких действий.
//           "Пометка"         - Помечать на удаление.
//           "Непосредственно" - Удалять непосредственно.
//       
//       * УчитыватьПрикладныеПравила - Булево - Необязательный. Режим проверки параметра ПарыЗамен.
//           Истина - По умолчанию. Проверять каждую пару "дубль-оригинал" (вызывается функция ВозможностьЗаменыЭлементов модуля менеджера).
//           Ложь   - Отключить прикладные проверки пар.
//       
//       * ВключатьБизнесЛогику - Булево - Необязательный. Режим записи мест использования при замене дублей на оригиналы.
//           Истина - По умолчанию. Места использования дублей записываются в режиме ОбменДанными.Загрузка = Ложь.
//           Ложь   - Запись ведется в режиме ОбменДанными.Загрузка = Истина.
//       
//       * ЗаменаПарыВТранзакции - Булево - Необязательный. Определяет размер транзакции.
//           Истина - По умолчанию. Транзакция охватывает все места использования одного дубля.
//           Ложь   - Замена каждого места использования выполняется в отдельной транзакции.
//       
//       * ПривилегированнаяЗапись - Булево - Необязательный. Требуется ли устанавливать привилегированный режим перед запись.
//           Ложь   - По умолчанию. Записывать с текущими правами.
//           Истина - Записывать в привилегированном режиме.
//
// Возвращаемое значение:
//   ТаблицаЗначений - Неуспешные замены (ошибки).
//       * Ссылка - ЛюбаяСсылка - Ссылка, которую заменяли.
//       * ОбъектОшибки - Произвольный - Объект - причина ошибки.
//       * ПредставлениеОбъектаОшибки - Строка - Строковое представление объекта ошибки.
//       * ТипОшибки - Строка - Тип ошибки:
//           "ОшибкаБлокировки"  - при обработке ссылки некоторые объекты были заблокированы.
//           "ДанныеИзменены"    - в процессе обработки данные были изменены другим пользователем.
//           "ОшибкаЗаписи"      - не смогли записать объект, или метод ВозможностьЗаменыЭлементов вернул отказ.
//           "ОшибкаУдаления"    - не смогли удалить объект.
//           "НеизвестныеДанные" - при обработке были найдены данные, которые не планировались к анализу, замена не реализована.
//       * ТекстОшибки - Строка - Подробное описание ошибки.
//
Функция ЗаменитьСсылки(Знач ПарыЗамен, Знач Параметры = Неопределено) Экспорт
	
	ТипСтрока = Новый ОписаниеТипов("Строка");
	
	ОшибкиЗамены = Новый ТаблицаЗначений;
	ОшибкиЗамены.Колонки.Добавить("Ссылка");
	ОшибкиЗамены.Колонки.Добавить("ОбъектОшибки");
	ОшибкиЗамены.Колонки.Добавить("ПредставлениеОбъектаОшибки", ТипСтрока);
	ОшибкиЗамены.Колонки.Добавить("ТипОшибки", ТипСтрока);
	ОшибкиЗамены.Колонки.Добавить("ТекстОшибки", ТипСтрока);
	
	ОшибкиЗамены.Индексы.Добавить("Ссылка");
	ОшибкиЗамены.Индексы.Добавить("Ссылка, ОбъектОшибки, ТипОшибки");
	
	ТаблицаОшибок = Новый ТаблицаЗначений;
	ТаблицаОшибок.Колонки.Добавить("Дубль");
	ТаблицаОшибок.Колонки.Добавить("Оригинал");
	ТаблицаОшибок.Колонки.Добавить("МестоИспользованияПолноеИмя");
	ТаблицаОшибок.Колонки.Добавить("Кратко");
	ТаблицаОшибок.Колонки.Добавить("ИнформацияОбОшибке");
	
	Результат = Новый Структура;
	Результат.Вставить("ЕстьОшибки", Ложь);
	Результат.Вставить("Ошибки", ОшибкиЗамены);
	Результат.Вставить("ТаблицаОшибок", ТаблицаОшибок);
	
	// Значения по умолчанию.
	ПараметрыВыполнения = Новый Структура;
	ПараметрыВыполнения.Вставить("УдалятьНепосредственно",     Ложь);
	ПараметрыВыполнения.Вставить("ПомечатьНаУдаление",         Ложь);
	ПараметрыВыполнения.Вставить("ВключатьБизнесЛогику",       Истина);
	ПараметрыВыполнения.Вставить("ПривилегированнаяЗапись",    Ложь);
	ПараметрыВыполнения.Вставить("УчитыватьПрикладныеПравила", Ложь);
	ДлиннаяТранзакция = Истина;
	
	// Переданные значения.
	ЗначениеПараметра = ОбщегоНазначенияКлиентСервер.СвойствоСтруктуры(Параметры, "СпособУдаления");
	Если ЗначениеПараметра = "Непосредственно" Тогда
		ПараметрыВыполнения.УдалятьНепосредственно = Истина;
		ПараметрыВыполнения.ПомечатьНаУдаление     = Ложь;
	ИначеЕсли ЗначениеПараметра = "Пометка" Тогда
		ПараметрыВыполнения.УдалятьНепосредственно = Ложь;
		ПараметрыВыполнения.ПомечатьНаУдаление     = Истина;
	КонецЕсли;
	
	ЗначениеПараметра = ОбщегоНазначенияКлиентСервер.СвойствоСтруктуры(Параметры, "ВключатьБизнесЛогику");
	Если ТипЗнч(ЗначениеПараметра) = Тип("Булево") Тогда
		ПараметрыВыполнения.ВключатьБизнесЛогику = ЗначениеПараметра;
	КонецЕсли;
	
	ЗначениеПараметра = ОбщегоНазначенияКлиентСервер.СвойствоСтруктуры(Параметры, "ЗаменаПарыВТранзакции");
	Если ТипЗнч(ЗначениеПараметра) = Тип("Булево") Тогда
		ДлиннаяТранзакция = ЗначениеПараметра;
	КонецЕсли;
	
	ЗначениеПараметра = ОбщегоНазначенияКлиентСервер.СвойствоСтруктуры(Параметры, "ПривилегированнаяЗапись");
	Если ТипЗнч(ЗначениеПараметра) = Тип("Булево") Тогда
		ПараметрыВыполнения.ПривилегированнаяЗапись = ЗначениеПараметра;
	КонецЕсли;
	
	ЗначениеПараметра = ОбщегоНазначенияКлиентСервер.СвойствоСтруктуры(Параметры, "УчитыватьПрикладныеПравила");
	Если ТипЗнч(ЗначениеПараметра) = Тип("Булево") Тогда
		ПараметрыВыполнения.УчитыватьПрикладныеПравила = ЗначениеПараметра;
	КонецЕсли;
	
	Если ПарыЗамен.Количество() = 0 Тогда
		Возврат Результат.Ошибки;
	КонецЕсли;
	
	Дубли = Новый Массив;
	Для Каждого КлючЗначение Из ПарыЗамен Цикл
		Дубль = КлючЗначение.Ключ;
		Оригинал = КлючЗначение.Значение;
		Если Дубль = Оригинал Или Дубль.Пустая() Тогда
			Продолжить; // Самого на себя и пустые ссылки не заменяем.
		КонецЕсли;
		Дубли.Добавить(Дубль);
		// Пропускаем промежуточные замены, чтобы не строить граф (если A->B и B->C то вместо A->B производится замена A->C).
		ОригиналОригинала = ПарыЗамен[Оригинал];
		ЕстьОригиналОригинала = (ОригиналОригинала <> Неопределено И ОригиналОригинала <> Дубль И ОригиналОригинала <> Оригинал);
		Если ЕстьОригиналОригинала Тогда
			Пока ЕстьОригиналОригинала Цикл
				Оригинал = ОригиналОригинала;
				ОригиналОригинала = ПарыЗамен[Оригинал];
				ЕстьОригиналОригинала = (ОригиналОригинала <> Неопределено И ОригиналОригинала <> Дубль И ОригиналОригинала <> Оригинал);
			КонецЦикла;
			ПарыЗамен.Вставить(Дубль, Оригинал);
		КонецЕсли;
	КонецЦикла;
	
	Если ПараметрыВыполнения.УчитыватьПрикладныеПравила И ПодсистемаСуществует("СтандартныеПодсистемы.ПоискИУдалениеДублей") Тогда
		МодульПоискИУдалениеДублей = ОбщийМодуль("ПоискИУдалениеДублей");
		Ошибки = МодульПоискИУдалениеДублей.ПроверитьВозможностьЗаменыЭлементов(ПарыЗамен, Параметры);
		Для Каждого КлючЗначение Из Ошибки Цикл
			Дубль = КлючЗначение.Ключ;
			Оригинал = ПарыЗамен[Дубль];
			ТекстОшибки = КлючЗначение.Значение;
			Причина = ОписаниеОшибкиЗамены("ОшибкаЗаписи", Оригинал, ПредметСтрокой(Оригинал), ТекстОшибки);
			ЗарегистрироватьОшибкуЗамены(Результат, Дубль, Причина);
			
			Индекс = Дубли.Найти(Дубль);
			Если Индекс <> Неопределено Тогда
				Дубли.Удалить(Индекс); // пропускаем проблемный элемент
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	ТаблицаПоиска = МестаИспользования(Дубли);
	
	// Для каждой ссылки объекта будем производить замены в порядке "Константа", "Объект", "Набор".
	// Одновременно пустая строка в этой колонке - флаг того, что эта замена не нужна или уже была произведена.
	ТаблицаПоиска.Колонки.Добавить("КлючЗамены", ТипСтрока);
	ТаблицаПоиска.Индексы.Добавить("Ссылка, КлючЗамены");
	ТаблицаПоиска.Индексы.Добавить("Данные, КлючЗамены");
	
	// Вспомогательные данные
	ТаблицаПоиска.Колонки.Добавить("ЦелеваяСсылка");
	ТаблицаПоиска.Колонки.Добавить("Обработано", Новый ОписаниеТипов("Булево"));
	
	// Определяем порядок обработки и проверяем то, что мы можем обработать.
	Количество = Дубли.Количество();
	Для Номер = 1 По Количество Цикл
		ОбратныйИндекс = Количество - Номер;
		Дубль = Дубли[ОбратныйИндекс];
		РезультатРазметки = РазметитьМестаИспользования(ПараметрыВыполнения, Дубль, ПарыЗамен[Дубль], ТаблицаПоиска);
		Если Не РезультатРазметки.Успех Тогда
			// Найдены неизвестные типы замены, не будем работать с этой ссылкой, возможно нарушение связности.
			Дубли.Удалить(ОбратныйИндекс);
			Для Каждого Ошибка Из РезультатРазметки.ОшибкиРазметки Цикл
				ПредставлениеОбъектаОшибки = ПредметСтрокой(Ошибка.Объект);
				ЗарегистрироватьОшибкуЗамены(Результат, Дубль,
					ОписаниеОшибкиЗамены("НеизвестныеДанные", Ошибка.Объект, ПредставлениеОбъектаОшибки, Ошибка.Текст));
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	
	ПараметрыВыполнения.Вставить("ПарыЗамен",      ПарыЗамен);
	ПараметрыВыполнения.Вставить("УспешныеЗамены", Новый Соответствие);
	
	Если ДлиннаяТранзакция Тогда
		Для Каждого Дубль Из Дубли Цикл
			ЗаменитьСсылкуДлиннойТранзакцией(Результат, Дубль, ПараметрыВыполнения, ТаблицаПоиска);
		КонецЦикла;
	Иначе
		ЗаменитьСсылкиКороткимиТранзакциями(Результат, ПараметрыВыполнения, Дубли, ТаблицаПоиска);
	КонецЕсли;
	
	Возврат Результат.Ошибки;
КонецФункции

// Получает все места использования ссылок.
// Если какая-либо ссылка нигде не используется, то строк для нее в результирующей таблице не будет.
//
// Параметры:
//     НаборСсылок     - Массив - Ссылки, для которых ищем места использования.
//     АдресРезультата - Строка - Необязательный адрес во временном хранилище, куда будет помещен копия результата
//                                замены.
// 
// Возвращаемое значение:
//     ТаблицаЗначений - Состоит из колонок:
//       * Ссылка                - ЛюбаяСсылка      - Ссылка, которая анализируется.
//       * Данные                - Произвольный     - Данные, содержащие анализируемую ссылку.
//       * Метаданные            - ОбъектМетаданных - Метаданные найденных данных.
//       * ПредставлениеДанных   - Строка           - Представление данных, содержащих анализируемую ссылку.
//       * ТипСсылки             - Тип              - Тип анализируемой ссылки.
//       * ВспомогательныеДанные - Булево           - Истина, если данные используются анализируемой ссылкой как
//                                                    вспомогательными  данными (ведущее измерение и т.п.).
//
Функция МестаИспользования(Знач НаборСсылок, Знач АдресРезультата = "") Экспорт
	
	МестаИспользования = Новый ТаблицаЗначений;
	
	УстановитьПривилегированныйРежим(Истина);
	МестаИспользования = НайтиПоСсылкам(НаборСсылок);
	
	МестаИспользования.Колонки.Добавить("ПредставлениеДанных", Новый ОписаниеТипов("Строка"));
	МестаИспользования.Колонки.Добавить("ТипСсылки");
	МестаИспользования.Колонки.Добавить("ИнформацияОМестеИспользования");
	МестаИспользования.Колонки.Добавить("ВспомогательныеДанные", Новый ОписаниеТипов("Булево"));
	
	МестаИспользования.Индексы.Добавить("Ссылка");
	МестаИспользования.Индексы.Добавить("Данные");
	МестаИспользования.Индексы.Добавить("ВспомогательныеДанные");
	МестаИспользования.Индексы.Добавить("Ссылка, ВспомогательныеДанные");
	
	ТипКлючиЗаписей = ОписаниеТипаКлючиЗаписей();
	ТипВсеСсылки    = ОписаниеТипаВсеСсылки();
	
	МетаПоследовательности = Метаданные.Последовательности;
	МетаКонстанты          = Метаданные.Константы;
	МетаДокументы          = Метаданные.Документы;
	
	ИсключенияПоискаСсылок = ПолучитьОбщийСписокИсключенийПоискаСсылок();
	
	КэшИзмерений = Новый Соответствие;
	
	Для Каждого Строка Из МестаИспользования Цикл
		Ссылка    = Строка.Ссылка;
		Данные    = Строка.Данные;
		Мета      = Строка.Метаданные;
		ТипДанных = ТипЗнч(Данные);
		
		ИсключениеПоиска = ИсключенияПоискаСсылок[Мета];
		
		Если ИсключениеПоиска = Неопределено Тогда
			ЭтоВспомогательныеДанные = (Ссылка = Данные);
			
		ИначеЕсли ИсключениеПоиска = "*" Тогда
			ЭтоВспомогательныеДанные = Истина;
			
		Иначе
			ЭтоВспомогательныеДанные = Ложь;
			Для Каждого ПутьКРеквизиту Из ИсключениеПоиска Цикл
				Если Ссылка = ВычислитьЗначениеДанныхПоПути(Данные, ПутьКРеквизиту) Тогда
					ЭтоВспомогательныеДанные = Истина;
					Прервать;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		
		Если МетаДокументы.Содержит(Мета) Тогда
			Представление = Строка(Данные);
			
		ИначеЕсли МетаКонстанты.Содержит(Мета) Тогда
			Представление = Мета.Представление() + " (" + ВернутьСтр("ru = 'константа'") + ")";
			
		ИначеЕсли МетаПоследовательности.Содержит(Мета) Тогда
			Представление = Мета.Представление() + " (" + ВернутьСтр("ru = 'последовательность'") + ")";
			
		ИначеЕсли ТипДанных = Неопределено Тогда
			Представление = Строка(Данные);
			
		ИначеЕсли ТипВсеСсылки.СодержитТип(ТипДанных) Тогда
			МетаПредставлениеОбъекта = Новый Структура("ПредставлениеОбъекта");
			ЗаполнитьЗначенияСвойств(МетаПредставлениеОбъекта, Мета);
			Если ПустаяСтрока(МетаПредставлениеОбъекта.ПредставлениеОбъекта) Тогда
				МетаПредставление = Мета.Представление();
			Иначе
				МетаПредставление = МетаПредставлениеОбъекта.ПредставлениеОбъекта;
			КонецЕсли;
			Представление = Строка(Данные);
			Если Не ПустаяСтрока(МетаПредставление) Тогда
				Представление = Представление + " (" + МетаПредставление + ")";
			КонецЕсли;
			
		ИначеЕсли ТипКлючиЗаписей.СодержитТип(ТипДанных) Тогда
			Представление = Мета.ПредставлениеЗаписи;
			Если ПустаяСтрока(Представление) Тогда
				Представление = Мета.Представление();
			КонецЕсли;
			
			ОписаниеИзмерений = "";
			Для Каждого КлючЗначение Из ОписаниеИзмеренийНабора(Мета, КэшИзмерений) Цикл
				Значение = Данные[КлючЗначение.Ключ];
				Описание = КлючЗначение.Значение;
				Если Значение = Ссылка Тогда
					Если Описание.Ведущее Тогда
						ЭтоВспомогательныеДанные = Истина;
					КонецЕсли;
				КонецЕсли;
				Формат = Описание.Формат; 
				ОписаниеИзмерений = ОписаниеИзмерений + ", " 
					+ Описание.Представление + " """ + ?(Формат = Неопределено, Строка(Значение), Формат(Значение, Формат)) + """";
			КонецЦикла;
			ОписаниеИзмерений = Сред(ОписаниеИзмерений, 3);
			
			Если Не ПустаяСтрока(ОписаниеИзмерений) Тогда
				Представление = Представление + " (" + ОписаниеИзмерений + ")";
			КонецЕсли;
			
		Иначе
			Представление = Строка(Данные);
			
		КонецЕсли;
		
		Строка.ПредставлениеДанных   = Представление;
		Строка.ВспомогательныеДанные = ЭтоВспомогательныеДанные;
		Строка.ТипСсылки             = ТипЗнч(Строка.Ссылка);
	КонецЦикла;
	
	Если Не ПустаяСтрока(АдресРезультата) Тогда
		ПоместитьВоВременноеХранилище(МестаИспользования, АдресРезультата);
	КонецЕсли;
	
	Возврат МестаИспользования;
КонецФункции

// Возвращает описание типа, включающего в себя все возможные ссылочные типы конфигурации.
//
Функция ОписаниеТипаВсеСсылки() Экспорт
	
	Возврат Новый ОписаниеТипов(Новый ОписаниеТипов(Новый ОписаниеТипов(Новый ОписаниеТипов(Новый ОписаниеТипов(
		Новый ОписаниеТипов(Новый ОписаниеТипов(Новый ОписаниеТипов(Новый ОписаниеТипов(
			Справочники.ТипВсеСсылки(),
			Документы.ТипВсеСсылки().Типы()),
			ПланыОбмена.ТипВсеСсылки().Типы()),
			Перечисления.ТипВсеСсылки().Типы()),
			ПланыВидовХарактеристик.ТипВсеСсылки().Типы()),
			ПланыСчетов.ТипВсеСсылки().Типы()),
			ПланыВидовРасчета.ТипВсеСсылки().Типы()),
			БизнесПроцессы.ТипВсеСсылки().Типы()),
			БизнесПроцессы.ТипВсеСсылкиТочекМаршрутаБизнесПроцессов().Типы()),
			Задачи.ТипВсеСсылки().Типы());
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Общие процедуры и функции для работы с прикладными типами и коллекциями значений.

// Получает имя значения перечисления как объекта метаданных.
//
// Параметры:
//  Значение - значение перечисления для которого необходимо получить имя перечисления.
//
// Возвращаемое значение:
//  Строка - имя значения перечисления как объекта метаданных.
//
Функция ИмяЗначенияПеречисления(Значение) Экспорт
	
	ОбъектМетаданных = Значение.Метаданные();
	
	ИндексЗначения = Перечисления[ОбъектМетаданных.Имя].Индекс(Значение);
	
	Возврат ОбъектМетаданных.ЗначенияПеречисления[ИндексЗначения].Имя;
	
КонецФункции 

// Устарела. Следует использовать ОбщегоНазначенияКлиентСервер.ДополнитьМассив,
// установив параметра ТолькоУникальныеЗначения в значение Истина.
//
// Заполняет массив-приемник уникальными значениями из массива-источника.
// Если элемент в массиве-приемнике уже существует, то добавления нового элемента не происходит.
//
// Параметры:
//  МассивПриемник - Массив - массив, который заполняется уникальными значениями.
//  МассивИсточник - Массив - массив, из которого подбираются элементы в массив-приемник.
// 
Процедура ЗаполнитьМассивУникальнымиЗначениями(МассивПриемник, МассивИсточник) Экспорт
	
	ОбщегоНазначенияКлиентСервер.ДополнитьМассив(МассивПриемник, МассивИсточник, Истина);
	
КонецПроцедуры

// Процедура удаляет из массива МассивРеквизитов элементы, соответствующие именам 
// реквизитов объекта из массива МассивНепроверяемыхРеквизитов.
// Для использования в обработчиках события ОбработкаПроверкиЗаполнения.
//
// Параметры:
//	МассивРеквизитов              - Массив - массив строк с именами реквизитов объекта.
//	МассивНепроверяемыхРеквизитов - Массив строк с именами реквизитов объекта, не требующих проверки.
//
Процедура УдалитьНепроверяемыеРеквизитыИзМассива(МассивРеквизитов, МассивНепроверяемыхРеквизитов) Экспорт
	
	Для Каждого ЭлементМассива Из МассивНепроверяемыхРеквизитов Цикл
	
		ПорядковыйНомер = МассивРеквизитов.Найти(ЭлементМассива);
		Если ПорядковыйНомер <> Неопределено Тогда
			МассивРеквизитов.Удалить(ПорядковыйНомер);
		КонецЕсли;
	
	КонецЦикла;
	
КонецПроцедуры

//	Преобразует таблицу значений в массив.
//	Может использоваться для передачи на клиента данных, полученных
//	на сервере в виде таблицы значений в том случае, если таблица
//	значений содержит только такие значения, которые могут
//  быть переданы на клиента.
//
//	Полученный массив содержит структуры, каждая из которых повторяет
//	структуру колонок таблицы значений.
//
//	Не рекомендуется использовать для преобразования таблиц значений
//	с большим количеством строк.
//
//	Параметры: 
//    ТаблицаЗначений - ТаблицаЗначений
//
//	Возвращаемое значение: 
//    Массив
//
Функция ТаблицаЗначенийВМассив(ТаблицаЗначений) Экспорт
	
	Массив = Новый Массив();
	СтруктураСтрокой = "";
	НужнаЗапятая = Ложь;
	Для Каждого Колонка Из ТаблицаЗначений.Колонки Цикл
		Если НужнаЗапятая Тогда
			СтруктураСтрокой = СтруктураСтрокой + ",";
		КонецЕсли;
		СтруктураСтрокой = СтруктураСтрокой + Колонка.Имя;
		НужнаЗапятая = Истина;
	КонецЦикла;
	Для Каждого Строка Из ТаблицаЗначений Цикл
		НоваяСтрока = Новый Структура(СтруктураСтрокой);
		ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка);
		Массив.Добавить(НоваяСтрока);
	КонецЦикла;
	Возврат Массив;

КонецФункции

// Функция СтрокаТаблицыЗначенийВСтруктуру создает
// структуру со свойствами, как колонки таблицы
// значений передаваемой строки
// и устанавливает этим свойствам значения
// из строки таблицы значений.
// 
// Параметры:
//  СтрокаТаблицыЗначений - СтрокаТаблицыЗначений
//
// ВозвращаемоеЗначение:
//  Структура
//
Функция СтрокаТаблицыЗначенийВСтруктуру(СтрокаТаблицыЗначений) Экспорт
	
	Структура = Новый Структура;
	Для каждого Колонка Из СтрокаТаблицыЗначений.Владелец().Колонки Цикл
		Структура.Вставить(Колонка.Имя, СтрокаТаблицыЗначений[Колонка.Имя]);
	КонецЦикла;
	
	Возврат Структура;
	
КонецФункции

// Создает структуру аналогичную менеджеру записи регистра сведений.
// 
// Параметры:
//	МенеджерЗаписи - РегистрСведенийМенеджерЗаписи,
//	МетаданныеРегистра - метаданные регистра сведений.
//
Функция СтруктураПоМенеджеруЗаписи(МенеджерЗаписи, МетаданныеРегистра) Экспорт
	
	ЗаписьКакСтруктура = Новый Структура;
	
	Если МетаданныеРегистра.ПериодичностьРегистраСведений <> Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда
		ЗаписьКакСтруктура.Вставить("Период", МенеджерЗаписи.Период);
	КонецЕсли;
	Для Каждого Поле Из МетаданныеРегистра.Измерения Цикл
		ЗаписьКакСтруктура.Вставить(Поле.Имя, МенеджерЗаписи[Поле.Имя]);
	КонецЦикла;
	Для Каждого Поле Из МетаданныеРегистра.Ресурсы Цикл
		ЗаписьКакСтруктура.Вставить(Поле.Имя, МенеджерЗаписи[Поле.Имя]);
	КонецЦикла;
	Для Каждого Поле Из МетаданныеРегистра.Реквизиты Цикл
		ЗаписьКакСтруктура.Вставить(Поле.Имя, МенеджерЗаписи[Поле.Имя]);
	КонецЦикла;
	
	Возврат ЗаписьКакСтруктура;
	
КонецФункции

// Создает массив и копирует в него значения, содержащиеся в колонке коллекции строк.
//
// Параметры:
//	КоллекцияСтрок - коллекция, для которой доступен обход посредством  
//		оператора Для каждого … Из … Цикл.
//	ИмяКолонки - строка с именем поля коллекции, значения которого нужно выгрузить.
//	ТолькоУникальныеЗначения - булево, необязательный, если истина, 
//		то в массив будут включены только различающиеся значения.
//
Функция ВыгрузитьКолонку(КоллекцияСтрок, ИмяКолонки, ТолькоУникальныеЗначения = Ложь) Экспорт

	МассивЗначений = Новый Массив;
	
	УникальныеЗначения = Новый Соответствие;
	
	Для каждого СтрокаКоллекции Из КоллекцияСтрок Цикл
		Значение = СтрокаКоллекции[ИмяКолонки];
		Если ТолькоУникальныеЗначения И УникальныеЗначения[Значение] <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		МассивЗначений.Добавить(Значение);
		УникальныеЗначения.Вставить(Значение, Истина);
	КонецЦикла; 
	
	Возврат МассивЗначений;
	
КонецФункции

// Преобразует текст формата XML в таблицу значений,
// при этом колонки таблицы формируются на основе описания в XML.
//
// Параметры:
//  XML     - текст в формате XML или ЧтениеXML.
//
// Схема XML:
// <?xml version="1.0" encoding="utf-8"?>
//  <xs:schema attributeFormDefault="unqualified" elementFormDefault="qualified" xmlns:xs="http://www.w3.org/2001/XMLSchema">
//   <xs:element name="Items">
//    <xs:complexType>
//     <xs:sequence>
//      <xs:element maxOccurs="unbounded" name="Item">
//       <xs:complexType>
//        <xs:attribute name="Code" type="xs:integer" use="required" />
//        <xs:attribute name="Name" type="xs:string" use="required" />
//        <xs:attribute name="Socr" type="xs:string" use="required" />
//        <xs:attribute name="Index" type="xs:string" use="required" />
//       </xs:complexType>
//      </xs:element>
//     </xs:sequence>
//    <xs:attribute name="Description" type="xs:string" use="required" />
//    <xs:attribute name="Columns" type="xs:string" use="required" />
//   </xs:complexType>
//  </xs:element>
// </xs:schema>
//
// Примеры XML-файлов см. в демонстрационной конфигурации.
// 
// Пример использования:
//   КлассификаторТаблица = ПрочитатьXMLВТаблицу(
//     Справочники.Валюты.ПолучитьМакет("ОбщероссийскийКлассификаторВалют").ПолучитьТекст()).Данные;
//
// Возвращаемое значение:
//  Структура - с полями 
//    * ИмяТаблицы - Строка
//    * Данные - ТаблицаЗначений.
//
Функция ПрочитатьXMLВТаблицу(Знач XML) Экспорт
	
	Если ТипЗнч(XML) <> Тип("ЧтениеXML") Тогда
		Чтение = Новый ЧтениеXML;
		Чтение.УстановитьСтроку(XML);
	Иначе
		Чтение = XML;
	КонецЕсли;
	
	// Прочитаем первый узел и проверим его.
	Если Не Чтение.Прочитать() Тогда
		ВызватьИсключение ВернутьСтр("ru = 'Пустой XML'");
	ИначеЕсли Чтение.Имя <> "Items" Тогда
		ВызватьИсключение ВернутьСтр("ru = 'Ошибка в структуре XML'");
	КонецЕсли;
	
	// Получим описание таблицы и создадим ее.
	ИмяТаблицы = Чтение.ПолучитьАтрибут("Description");
	ИменаКолонок = СтрЗаменить(Чтение.ПолучитьАтрибут("Columns"), ",", Символы.ПС);
	Колонок = СтрЧислоСтрок(ИменаКолонок);
	
	ТаблицаЗначений = Новый ТаблицаЗначений;
	Для Сч = 1 По Колонок Цикл
		ТаблицаЗначений.Колонки.Добавить(СтрПолучитьСтроку(ИменаКолонок, Сч), Новый ОписаниеТипов("Строка"));
	КонецЦикла;
	
	// Заполним значения в таблице.
	Пока Чтение.Прочитать() Цикл
		
		Если Чтение.ТипУзла = ТипУзлаXML.КонецЭлемента И Чтение.Имя = "Items" Тогда
			Прервать;
		ИначеЕсли Чтение.ТипУзла <> ТипУзлаXML.НачалоЭлемента Тогда
			Продолжить;
		ИначеЕсли Чтение.Имя <> "Item" Тогда
			ВызватьИсключение ВернутьСтр("ru = 'Ошибка в структуре XML'");
		КонецЕсли;
		
		новСтр = ТаблицаЗначений.Добавить();
		Для Сч = 1 По Колонок Цикл
			ИмяКолонки = СтрПолучитьСтроку(ИменаКолонок, Сч);
			новСтр[Сч-1] = Чтение.ПолучитьАтрибут(ИмяКолонки);
		КонецЦикла;
		
	КонецЦикла;
	
	// Заполним результат
	Результат = Новый Структура;
	Результат.Вставить("ИмяТаблицы", ИмяТаблицы);
	Результат.Вставить("Данные", ТаблицаЗначений);
	
	Возврат Результат;
	
КонецФункции

// Функция выполняет сравнение двух коллекций строк, для которых доступен обход 
// посредством оператора Для каждого … Из … Цикл.
// Сравниваемые коллекции должны отвечать следующим требованиям:
//  - доступен обход посредством оператора Для каждого … Из … Цикл,
//  - наличие в обеих коллекциях всех колонок, перечисленных в параметре ИменаКолонок 
//  (если ИменаКолонок не заполнен - всех колонок).
//  Так же позволяет сравнивать массивы.
//
// Параметры:
//	КоллекцияСтрок1 - КоллекцияЗначений - коллекция, отвечающая вышеописанным требованиям;
//	КоллекцияСтрок2 - КоллекцияЗначений - коллекция, отвечающая вышеописанным требованиям;
//	ИменаКолонок - Строка - имена колонок через запятую, 
//						по которым производится сравнение. 
//						Не является обязательным для коллекций, 
//						состав колонок которых можно выявить: 
//						ТаблицаЗначений, СписокЗначений, Соответствие, Структура,
//						если не указан - сравнение производится по всем колонкам.
//						Для коллекций других типов является обязательным.
//	ИсключаяКолонки - Строка - имена колонок, которые игнорируются при сравнении, необязательный.
//	УчитыватьПоследовательностьСтрок - Булево - если Истина, то коллекции признаются 
//						идентичными только если одинаковые строки размещены 
//						в коллекциях на одинаковых местах.
//
// Возвращаемое значение:
//  Булево.
//
Функция КоллекцииИдентичны(КоллекцияСтрок1, КоллекцияСтрок2, ИменаКолонок = "", ИсключаяКолонки = "", УчитыватьПоследовательностьСтрок = Ложь) Экспорт
	
	СравниваютсяМассивы = (ТипЗнч(КоллекцияСтрок1) = Тип("Массив")
	 Или ТипЗнч(КоллекцияСтрок1) = Тип("ФиксированныйМассив"));
	
	Если Не СравниваютсяМассивы Тогда
		
		// Типы коллекций, для которых доступен состав колонок,
		// и можно выявить, если он не задан.
		ТипыОсобыхКоллекций = Новый Массив;
		ТипыОсобыхКоллекций.Добавить(Тип("ТаблицаЗначений"));
		ТипыОсобыхКоллекций.Добавить(Тип("СписокЗначений"));
		
		ТипыКоллекцийКлючИЗначение = Новый Массив;
		ТипыКоллекцийКлючИЗначение.Добавить(Тип("Соответствие"));
		ТипыКоллекцийКлючИЗначение.Добавить(Тип("Структура"));
		ТипыКоллекцийКлючИЗначение.Добавить(Тип("ФиксированноеСоответствие"));
		ТипыКоллекцийКлючИЗначение.Добавить(Тип("ФиксированнаяСтруктура"));
		
		Если ПустаяСтрока(ИменаКолонок) Тогда
			Если ТипыОсобыхКоллекций.Найти(ТипЗнч(КоллекцияСтрок1)) <> Неопределено
				Или ТипыКоллекцийКлючИЗначение.Найти(ТипЗнч(КоллекцияСтрок1)) <> Неопределено Тогда
				СравниваемыеКолонки = Новый Массив;
				Если ТипЗнч(КоллекцияСтрок1) = Тип("ТаблицаЗначений") Тогда
					Для Каждого Колонка Из КоллекцияСтрок1.Колонки Цикл
						СравниваемыеКолонки.Добавить(Колонка.Имя);
					КонецЦикла;
				ИначеЕсли ТипЗнч(КоллекцияСтрок1) = Тип("СписокЗначений") Тогда
					СравниваемыеКолонки.Добавить("Значение");
					СравниваемыеКолонки.Добавить("Картинка");
					СравниваемыеКолонки.Добавить("Пометка");
					СравниваемыеКолонки.Добавить("Представление");
				ИначеЕсли ТипыКоллекцийКлючИЗначение.Найти(ТипЗнч(КоллекцияСтрок1)) <> Неопределено Тогда
					СравниваемыеКолонки.Добавить("Ключ");
					СравниваемыеКолонки.Добавить("Значение");
				КонецЕсли;
			Иначе
				ТекстИсключения = ВернутьСтр("ru = 'Для коллекции типа %1 необходимо указать имена полей, по которым производится сравнение'");
				ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстИсключения, ТипЗнч(КоллекцияСтрок1));
			КонецЕсли;
		Иначе
			СравниваемыеКолонки = СтрРазделить(ИменаКолонок, ",");
		КонецЕсли;
		
		// Вычитаем исключаемые поля
		СравниваемыеКолонки = ОбщегоНазначенияКлиентСервер.СократитьМассив(СравниваемыеКолонки, СтрРазделить(ИсключаяКолонки, ","));
	КонецЕсли;
	
	Если УчитыватьПоследовательностьСтрок Тогда
		
		// Параллельный обход обеих коллекций.
		НомерСтрокиКоллекции1 = 0;
		Для Каждого СтрокаКоллекции1 Из КоллекцияСтрок1 Цикл
			// Спозиционируемся на аналогичную строку второй коллекции.
			НомерСтрокиКоллекции2 = 0;
			ЕстьСтрокиКоллекции2 = Ложь;
			Для Каждого СтрокаКоллекции2 Из КоллекцияСтрок2 Цикл
				ЕстьСтрокиКоллекции2 = Истина;
				Если НомерСтрокиКоллекции2 = НомерСтрокиКоллекции1 Тогда
					Прервать;
				КонецЕсли;
				НомерСтрокиКоллекции2 = НомерСтрокиКоллекции2 + 1;
			КонецЦикла;
			Если Не ЕстьСтрокиКоллекции2 Тогда
				// Во второй коллекции вообще нет строк.
				Возврат Ложь;
			КонецЕсли;
			// Сравниваем значения полей двух строк.
			Если СравниваютсяМассивы Тогда
				Если СтрокаКоллекции1 <> СтрокаКоллекции2 Тогда
					Возврат Ложь;
				КонецЕсли;
			Иначе
				Для Каждого ИмяКолонки Из СравниваемыеКолонки Цикл
					Если СтрокаКоллекции1[ИмяКолонки] <> СтрокаКоллекции2[ИмяКолонки] Тогда
						Возврат Ложь;
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
			НомерСтрокиКоллекции1 = НомерСтрокиКоллекции1 + 1;
		КонецЦикла;
		
		КоличествоСтрокКоллекции1 = НомерСтрокиКоллекции1;
		
		// Отдельно подсчитаем количество строк второй коллекции.
		КоличествоСтрокКоллекции2 = 0;
		Для Каждого СтрокаКоллекции2 Из КоллекцияСтрок2 Цикл
			КоличествоСтрокКоллекции2 = КоличествоСтрокКоллекции2 + 1;
		КонецЦикла;
		
		// Если в первой коллекции не оказалось строк, 
		// то их не должно быть и во второй.
		Если КоличествоСтрокКоллекции1 = 0 Тогда
			Для Каждого СтрокаКоллекции2 Из КоллекцияСтрок2 Цикл
				Возврат Ложь;
			КонецЦикла;
			КоличествоСтрокКоллекции2 = 0;
		КонецЕсли;
		
		// Количество строк не должно отличаться.
		Если КоличествоСтрокКоллекции1 <> КоличествоСтрокКоллекции2 Тогда
			Возврат Ложь;
		КонецЕсли;
		
	Иначе
		
		// Для массивов используется более простой алгоритм.
		Если СравниваютсяМассивы Тогда
			
			Если КоллекцияСтрок1.Количество() <> КоллекцияСтрок2.Количество() Тогда
				Возврат Ложь;
			КонецЕсли;
			
			Для Каждого СтрокаКоллекции1 Из КоллекцияСтрок1 Цикл
				Если КоллекцияСтрок2.Найти(СтрокаКоллекции1) = Неопределено Тогда
					Возврат Ложь;
				КонецЕсли;
			КонецЦикла;
			
		Иначе
			
			// Проверяем идентичность состава одинаковых строк без учета их последовательности.
			
			// Строки отбора накапливаем по первой коллекции для того, чтобы:
			//  - повторно не искать одинаковые строки,
			//  - убедиться, что во второй коллекции ни одной такой строки, которой нет в накопленных.
			
			СтрокиОтбора = Новый ТаблицаЗначений;
			ПараметрыОтбора = Новый Структура;
			Для Каждого ИмяКолонки Из СравниваемыеКолонки Цикл
				СтрокиОтбора.Колонки.Добавить(ИмяКолонки);
				ПараметрыОтбора.Вставить(ИмяКолонки);
			КонецЦикла;
			
			ЕстьСтрокиКоллекции1 = Ложь;
			Для Каждого СтрокаОтбора Из КоллекцияСтрок1 Цикл
				
				ЗаполнитьЗначенияСвойств(ПараметрыОтбора, СтрокаОтбора);
				Если СтрокиОтбора.НайтиСтроки(ПараметрыОтбора).Количество() > 0 Тогда
					// Строку с такими полями уже искали.
					Продолжить;
				КонецЕсли;
				ЗаполнитьЗначенияСвойств(СтрокиОтбора.Добавить(), СтрокаОтбора);
				
				// Подсчитаем количество таких строк в первой коллекции.
				НайденоСтрокКоллекции1 = 0;
				Для Каждого СтрокаКоллекции1 Из КоллекцияСтрок1 Цикл
					СтрокаПодходит = Истина;
					Для Каждого ИмяКолонки Из СравниваемыеКолонки Цикл
						Если СтрокаКоллекции1[ИмяКолонки] <> СтрокаОтбора[ИмяКолонки] Тогда
							СтрокаПодходит = Ложь;
							Прервать;
						КонецЕсли;
					КонецЦикла;
					Если СтрокаПодходит Тогда
						НайденоСтрокКоллекции1 = НайденоСтрокКоллекции1 + 1;
					КонецЕсли;
				КонецЦикла;
				
				// Подсчитаем количество таких строк во второй коллекции.
				НайденоСтрокКоллекции2 = 0;
				Для Каждого СтрокаКоллекции2 Из КоллекцияСтрок2 Цикл
					СтрокаПодходит = Истина;
					Для Каждого ИмяКолонки Из СравниваемыеКолонки Цикл
						Если СтрокаКоллекции2[ИмяКолонки] <> СтрокаОтбора[ИмяКолонки] Тогда
							СтрокаПодходит = Ложь;
							Прервать;
						КонецЕсли;
					КонецЦикла;
					Если СтрокаПодходит Тогда
						НайденоСтрокКоллекции2 = НайденоСтрокКоллекции2 + 1;
						// Если количество таких строк во второй коллекции превысило количество в первой, 
						// то уже можно сделать вывод, что коллекции не идентичны.
						Если НайденоСтрокКоллекции2 > НайденоСтрокКоллекции1 Тогда
							Возврат Ложь;
						КонецЕсли;
					КонецЕсли;
				КонецЦикла;
				
				// Количество таких строк не должно отличаться.
				Если НайденоСтрокКоллекции1 <> НайденоСтрокКоллекции2 Тогда
					Возврат Ложь;
				КонецЕсли;
				
				ЕстьСтрокиКоллекции1 = Истина;
				
			КонецЦикла;
			
			// Если в первой коллекции не оказалось строк, 
			// то их не должно быть и во второй.
			Если Не ЕстьСтрокиКоллекции1 Тогда
				Для Каждого СтрокаКоллекции2 Из КоллекцияСтрок2 Цикл
					Возврат Ложь;
				КонецЦикла;
			КонецЕсли;
			
			// Проверим, что во второй коллекции нет ни одной такой строки, которой нет в накопленных.
			Для Каждого СтрокаКоллекции2 Из КоллекцияСтрок2 Цикл
				ЗаполнитьЗначенияСвойств(ПараметрыОтбора, СтрокаКоллекции2);
				Если СтрокиОтбора.НайтиСтроки(ПараметрыОтбора).Количество() = 0 Тогда
					Возврат Ложь;
				КонецЕсли;
			КонецЦикла;
			
		КонецЕсли;
	
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

// Сравнивает данные сложной структуры с учетом вложенности.
//
// Параметры:
//  Данные1 - Структура,    ФиксированнаяСтруктура -
//          - Соответствие, ФиксированноеСоответствие -
//          - Массив,       ФиксированныйМассив - 
//          - ХранилищеЗначения, ТаблицаЗначений - сложные типы для сравнения.
//          - Строка, Число, Булево - простые типы, которые можно сравнивать на равно.
//
//  Данные2 - Произвольный - те же типы, что и для параметра Данные1.
//
// Возвращаемое значение:
//  Булево.
//
Функция ДанныеСовпадают(Данные1, Данные2) Экспорт
	
	Если ТипЗнч(Данные1) <> ТипЗнч(Данные2) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если ТипЗнч(Данные1) = Тип("Структура")
	 ИЛИ ТипЗнч(Данные1) = Тип("ФиксированнаяСтруктура") Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Для каждого КлючИЗначение Из Данные1 Цикл
			СтароеЗначение = Неопределено;
			
			Если НЕ Данные2.Свойство(КлючИЗначение.Ключ, СтароеЗначение)
			 ИЛИ НЕ ДанныеСовпадают(КлючИЗначение.Значение, СтароеЗначение) Тогда
			
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
		Возврат Истина;
		
	ИначеЕсли ТипЗнч(Данные1) = Тип("Соответствие")
	      ИЛИ ТипЗнч(Данные1) = Тип("ФиксированноеСоответствие") Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		КлючиНовогоСоответствия = Новый Соответствие;
		
		Для каждого КлючИЗначение Из Данные1 Цикл
			КлючиНовогоСоответствия.Вставить(КлючИЗначение.Ключ, Истина);
			СтароеЗначение = Данные2.Получить(КлючИЗначение.Ключ);
			
			Если НЕ ДанныеСовпадают(КлючИЗначение.Значение, СтароеЗначение) Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
		Для каждого КлючИЗначение Из Данные2 Цикл
			Если КлючиНовогоСоответствия[КлючИЗначение.Ключ] = Неопределено Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
		Возврат Истина;
		
	ИначеЕсли ТипЗнч(Данные1) = Тип("Массив")
	      ИЛИ ТипЗнч(Данные1) = Тип("ФиксированныйМассив") Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Индекс = Данные1.Количество()-1;
		Пока Индекс >= 0 Цикл
			Если НЕ ДанныеСовпадают(Данные1.Получить(Индекс), Данные2.Получить(Индекс)) Тогда
				Возврат Ложь;
			КонецЕсли;
			Индекс = Индекс - 1;
		КонецЦикла;
		
		Возврат Истина;
		
	ИначеЕсли ТипЗнч(Данные1) = Тип("ТаблицаЗначений") Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Если Данные1.Колонки.Количество() <> Данные2.Колонки.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Для каждого Колонка Из Данные1.Колонки Цикл
			Если Данные2.Колонки.Найти(Колонка.Имя) = Неопределено Тогда
				Возврат Ложь;
			КонецЕсли;
			
			Индекс = Данные1.Количество()-1;
			Пока Индекс >= 0 Цикл
				Если НЕ ДанныеСовпадают(Данные1[Индекс][Колонка.Имя], Данные2[Индекс][Колонка.Имя]) Тогда
					Возврат Ложь;
				КонецЕсли;
				Индекс = Индекс - 1;
			КонецЦикла;
		КонецЦикла;
		
		Возврат Истина;
		
	ИначеЕсли ТипЗнч(Данные1) = Тип("ХранилищеЗначения") Тогда
	
		Если НЕ ДанныеСовпадают(Данные1.Получить(), Данные2.Получить()) Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Возврат Истина;
	КонецЕсли;
	
	Возврат Данные1 = Данные2;
	
КонецФункции

// Фиксирует данные типов Структура, Соответствие, Массив с учетом вложенности.
//
// Параметры:
//  Данные - Структура, Соответствие, Массив - коллекции, значения которых являются примитивными типами,
//           хранилищем значения или не могут быть изменены. Поддерживаются типы значений:
//           Булево, Строка, Число, Дата, Неопределено, УникальныйИдентификатор, Null, Тип,
//           ХранилищеЗначения, ОбщийМодуль, ОбъектМетаданных, ТипЗначенияXDTO, ТипОбъектаXDTO,
//           ЛюбаяСсылка.
//
//  ВызыватьИсключение - Булево - начальное значение Истина. Когда установлено.
//                       Ложь, тогда в случае наличия нефиксируемых данных исключение не будет
//                       вызвано, при этом данные будут зафиксированы на сколько возможно.
//
// Возвращаемое значение:
//  Фиксированные данные, аналогичные переданным в параметре Данные.
// 
Функция ФиксированныеДанные(Данные, ВызыватьИсключение = Истина) Экспорт
	
	Если ТипЗнч(Данные) = Тип("Массив") Тогда
		Массив = Новый Массив;
		
		Индекс = Данные.Количество() - 1;
		
		Для каждого Значение Из Данные Цикл
			
			Если ТипЗнч(Значение) = Тип("Структура")
			 ИЛИ ТипЗнч(Значение) = Тип("Соответствие")
			 ИЛИ ТипЗнч(Значение) = Тип("Массив") Тогда
				
				Массив.Добавить(ФиксированныеДанные(Значение, ВызыватьИсключение));
			Иначе
				Если ВызыватьИсключение Тогда
					ПроверкаФиксированностиДанных(Значение, Истина);
				КонецЕсли;
				Массив.Добавить(Значение);
			КонецЕсли;
		КонецЦикла;
		
		Возврат Новый ФиксированныйМассив(Массив);
		
	ИначеЕсли ТипЗнч(Данные) = Тип("Структура")
	      ИЛИ ТипЗнч(Данные) = Тип("Соответствие") Тогда
		
		Если ТипЗнч(Данные) = Тип("Структура") Тогда
			Коллекция = Новый Структура;
		Иначе
			Коллекция = Новый Соответствие;
		КонецЕсли;
		
		Для каждого КлючИЗначение Из Данные Цикл
			Значение = КлючИЗначение.Значение;
			
			Если ТипЗнч(Значение) = Тип("Структура")
			 ИЛИ ТипЗнч(Значение) = Тип("Соответствие")
			 ИЛИ ТипЗнч(Значение) = Тип("Массив") Тогда
				
				Коллекция.Вставить(
					КлючИЗначение.Ключ, ФиксированныеДанные(Значение, ВызыватьИсключение));
			Иначе
				Если ВызыватьИсключение Тогда
					ПроверкаФиксированностиДанных(Значение, Истина);
				КонецЕсли;
				Коллекция.Вставить(КлючИЗначение.Ключ, Значение);
			КонецЕсли;
		КонецЦикла;
		
		Если ТипЗнч(Данные) = Тип("Структура") Тогда
			Возврат Новый ФиксированнаяСтруктура(Коллекция);
		Иначе
			Возврат Новый ФиксированноеСоответствие(Коллекция);
		КонецЕсли;
		
	ИначеЕсли ВызыватьИсключение Тогда
		ПроверкаФиксированностиДанных(Данные);
	КонецЕсли;
	
	Возврат Данные;
	
КонецФункции

// Создает копию объекта XDTO.
//
// Параметры:
//  Фабрика - ФабрикаXDTO - фабрика, которой создан исходный объект.
//  Объект  - ОбъектXDTO  - объект, копию которого требуется создать.
//
// Возвращаемое значение:
//  ОбъектXDTO - копия исходного объекта XDTO.
//
Функция СкопироватьXDTO(Знач Фабрика, Знач Объект) Экспорт
	
	Запись = Новый ЗаписьXML;
	Запись.УстановитьСтроку();
	Фабрика.ЗаписатьXML(Запись, Объект, , , , НазначениеТипаXML.Явное);
	
	XMLПредставление = Запись.Закрыть();
	
	Чтение = Новый ЧтениеXML;
	Чтение.УстановитьСтроку(XMLПредставление);
	
	Возврат Фабрика.ПрочитатьXML(Чтение, Объект.Тип());
	
КонецФункции

// Возвращает XML представление типа XDTO.
//
// Параметры:
//  ТипXDTO - ТипОбъектаXDTO, ТипЗначенияXDTO - тип XDTO для которого требуется получить.
//   XML представление
//
// Возвращаемое значение:
//  Строка - XML представление типа XDTO.
//
Функция ПредставлениеТипаXDTO(ТипXDTO) Экспорт
	
	Возврат СериализаторXDTO.XMLСтрока(Новый РасширенноеИмяXML(ТипXDTO.URIПространстваИмен, ТипXDTO.Имя))
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Математические процедуры и функции.

// Выполняет пропорциональное распределение суммы в соответствии с заданными коэффициентами.
//
// Параметры:
//  РаспределяемаяСумма - Число;
//  КоэффициентыРаспределения - Массив;
//  ТочностьОкругления - Число.
//
// Возвращаемое значение:
//   Массив - список распределенных сумм.
//               В случае, если распределить не удалось (сумма = 0, кол-во коэффициентов = 0,
//               или суммарный вес коэффициентов = 0), возвращается значение Неопределено.
//
Функция РаспределитьСуммуПропорциональноКоэффициентам(Знач РаспределяемаяСумма, КоэффициентыРаспределения, Знач Точность = 2) Экспорт
	
	Возврат ОбщегоНазначенияКлиентСервер.РаспределитьСуммуПропорциональноКоэффициентам(РаспределяемаяСумма, КоэффициентыРаспределения, Точность);
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для работы с внешним соединением.

// Возвращает CLSID COM-класса для работы с 1С:Предприятием 8 через COM-соединение.
//
// Параметры:
//  ИмяCOMСоединителя - Строка - имя COM-класса для работы с 1С:Предприятием 8 через COM-соединение.
//
// Возвращаемое значение:
//  Строка - строковое представление CLSID.
//
Функция ИдентификаторCOMСоединителя(Знач ИмяCOMСоединителя) Экспорт
	
	Если ИмяCOMСоединителя = "v83.COMConnector" Тогда
		Возврат "181E893D-73A4-4722-B61D-D604B3D67D47";
	КонецЕсли;
	
	ТекстИсключения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ВернутьСтр("ru = 'На задан CLSID для класса %1'"), ИмяCOMСоединителя);
	ВызватьИсключение ТекстИсключения;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Вспомогательные процедуры и функции.

// Определяет режим эксплуатации информационной базы файловый (Истина) или серверный (Ложь).
// При проверке используется СтрокаСоединенияИнформационнойБазы, которую можно указать явно.
//
// Параметры:
//  СтрокаСоединенияИнформационнойБазы - Строка - параметр используется, если
//                 нужно проверить строку соединения не текущей информационной базы.
//
// Возвращаемое значение:
//  Булево.
//
Функция ИнформационнаяБазаФайловая(Знач СтрокаСоединенияИнформационнойБазы = "") Экспорт
			
	Если ПустаяСтрока(СтрокаСоединенияИнформационнойБазы) Тогда
		СтрокаСоединенияИнформационнойБазы =  СтрокаСоединенияИнформационнойБазы();
	КонецЕсли;
	Возврат СтрНайти(Врег(СтрокаСоединенияИнформационнойБазы), "FILE=") = 1;
	
КонецФункции 

// Переводит параметры сеанса в состояние "Не установлено". 
// 
// Параметры: 
// ПараметрыДляОчистки - Строка - имена параметров сеанса для очистки, разделенные ",".
// Исключения          - Строка - имена параметров сеанса не предназначенные для очистки, разделенные ",".
//
Процедура ОчиститьПараметрыСеанса(ПараметрыДляОчистки = "", Исключения = "") Экспорт
	
	МассивИсключений = СтрРазделить(Исключения, ",");
	МассивПараметровДляОчистки = СтрРазделить(ПараметрыДляОчистки, ",", Ложь);
	
	Если МассивПараметровДляОчистки.Количество() = 0 Тогда
		Для Каждого ПараметрСеанса Из Метаданные.ПараметрыСеанса Цикл
			Если МассивИсключений.Найти(ПараметрСеанса.Имя) = Неопределено Тогда
				МассивПараметровДляОчистки.Добавить(ПараметрСеанса.Имя);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Индекс = МассивПараметровДляОчистки.Найти("ПараметрыКлиентаНаСервере");
	Если Индекс <> Неопределено Тогда
		МассивПараметровДляОчистки.Удалить(Индекс);
	КонецЕсли;
	
	Индекс = МассивПараметровДляОчистки.Найти("УстановленныеРасширения");
	Если Индекс <> Неопределено Тогда
		МассивПараметровДляОчистки.Удалить(Индекс);
	КонецЕсли;
	
	ПараметрыСеанса.Очистить(МассивПараметровДляОчистки);
	
КонецПроцедуры

// Возвращает описание предмета в виде текстовой строки.
// 
// Параметры:
//  СсылкаНаПредмет  - ЛюбаяСсылка - объект ссылочного типа.
//
// Возвращаемое значение:
//   Строка.
// 
Функция ПредметСтрокой(СсылкаНаПредмет) Экспорт
	
	Результат = "";
	
	Если СсылкаНаПредмет = Неопределено Или СсылкаНаПредмет.Пустая() Тогда
		Результат = ВернутьСтр("ru = 'не задан'");
	ИначеЕсли Метаданные.Документы.Содержит(СсылкаНаПредмет.Метаданные()) Тогда
		Результат = Строка(СсылкаНаПредмет);
	Иначе
		ПредставлениеОбъекта = СсылкаНаПредмет.Метаданные().ПредставлениеОбъекта;
		Если ПустаяСтрока(ПредставлениеОбъекта) Тогда
			ПредставлениеОбъекта = СсылкаНаПредмет.Метаданные().Представление();
		КонецЕсли;
		Результат = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку("%1 (%2)", Строка(СсылкаНаПредмет), ПредставлениеОбъекта);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Формирует соответствие для удаления объектов.
//
// Возвращаемое значение:
//   Соответствие - Исключения поиска ссылок в разрезе объектов метаданных
//       * Ключ - ОбъектМетаданных - Объект метаданных, для которого применяются исключения.
//       * Значение - Строка, Массив - описание исключенных реквизитов.
//           - "*" - Исключены все реквизиты объекта метаданных.
//           - Массив из Строка - Относительные имена исключенных реквизитов.
//
Функция ПолучитьОбщийСписокИсключенийПоискаСсылок() Экспорт
	МассивИсключенийСобытия = Новый Массив;
	ОбработчикиСобытия = ОбработчикиСлужебногоСобытия(
		"СтандартныеПодсистемы.БазоваяФункциональность\ПриДобавленииИсключенийПоискаСсылок");
	Для Каждого Обработчик Из ОбработчикиСобытия Цикл
		Обработчик.Модуль.ПриДобавленииИсключенийПоискаСсылок(МассивИсключенийСобытия);
	КонецЦикла;
	
	МассивИсключенийПереопределения = Новый Массив;
	ОбщегоНазначенияПереопределяемый.ПриДобавленииИсключенийПоискаСсылок(МассивИсключенийПереопределения);
	
	Результат = Новый Соответствие;
	ДобавитьИсключенияПоискаСсылок(Результат, МассивИсключенийСобытия);
	ДобавитьИсключенияПоискаСсылок(Результат, МассивИсключенийПереопределения);
	Возврат Результат;
КонецФункции

// Возвращает значение в виде XML-строки.
// Преобразованы в XML-строку (сериализованы) могут быть только те объекты, 
// для которых в описании указано, что они сериализуются.
//
// Параметры:
//   Значение - Произвольный. Значение, которое необходимо сериализовать в XML-строку.
//
// Возвращаемое значение:
//   Строка - XML-строка представления значения в сериализованном виде.
//
Функция ЗначениеВСтрокуXML(Значение) Экспорт
	
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.УстановитьСтроку();
	СериализаторXDTO.ЗаписатьXML(ЗаписьXML, Значение, НазначениеТипаXML.Явное);
	
	Возврат ЗаписьXML.Закрыть();
КонецФункции

// Возвращает значение, полученное из XML-строки. 
// Получены из XML-строки могут быть только те объекты, 
// для которых в описании указано, что они сериализуются.
//
// Параметры:
// СтрокаXML - строка представления значения в сериализованном виде.
//
// Возвращаемое значение:
// Значение, полученное из переданной XML-строки.
//
Функция ЗначениеИзСтрокиXML(СтрокаXML) Экспорт
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(СтрокаXML);
	
	Возврат СериализаторXDTO.ПрочитатьXML(ЧтениеXML);
КонецФункции

// Возвращает XML-представление XDTO-объекта.
//
// Параметры:
//  ОбъектXDTO - ОбъектXDTO  - объект, для которого требуется сформировать XML-представление.
//  Фабрика    - ФабрикаXDTO - фабрика, с использованием которой требуется формировать XML-представление.
//                             Если параметр не указан - будет использоваться глобальная фабрика XDTO.
//
// Возвращаемое значение: 
//   Строка - XML-представление XDTO-объекта.
//
Функция ОбъектXDTOВСтрокуXML(Знач ОбъектXDTO, Знач Фабрика = Неопределено) Экспорт
	
	ОбъектXDTO.Проверить();
	
	Если Фабрика = Неопределено Тогда
		Фабрика = ФабрикаXDTO;
	КонецЕсли;
	
	Запись = Новый ЗаписьXML();
	Запись.УстановитьСтроку();
	Фабрика.ЗаписатьXML(Запись, ОбъектXDTO, , , , НазначениеТипаXML.Явное);
	
	Возврат Запись.Закрыть();
	
КонецФункции

// Формирует XDTO-объект по XML-представлению.
//
// Параметры:
//  СтрокаXML - Строка    - XML-представление XDTO-объекта,
//  Фабрика - ФабрикаXDTO - фабрика, с использованием которой требуется формировать XDTO-объект.
//                          Если параметр не указан - будет использоваться глобальная фабрика XDTO.
//
// Возвращаемое значение: 
//   ОбъектXDTO.
//
Функция ОбъектXDTOИзСтрокиXML(Знач СтрокаXML, Знач Фабрика = Неопределено) Экспорт
	
	Если Фабрика = Неопределено Тогда
		Фабрика = ФабрикаXDTO;
	КонецЕсли;
	
	Чтение = Новый ЧтениеXML();
	Чтение.УстановитьСтроку(СтрокаXML);
	
	Возврат Фабрика.ПрочитатьXML(Чтение);
	
КонецФункции

// Формирует из исходной строки СтрокаПоиска строку для поиска данных в запросе.
//
// Параметры:
//	СтрокаПоиска - Строка - исходная строка, содержащая запрещенные символы.
//
// Возвращаемое значение:
//  Строка - строка подготовленная для поиска данных в запросе.
//
Функция СформироватьСтрокуДляПоискаВЗапросе(Знач СтрокаПоиска) Экспорт
	
	ИтоговаяСтрокаДляПоиска = СтрокаПоиска;
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "~", "~~");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "%", "~%");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "_", "~_");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "[", "~[");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "-", "~-");
	
	Возврат ИтоговаяСтрокаДляПоиска;
	
КонецФункции

// Функция возвращает объект WSПрокси созданный с переданными параметрами.
//
// Параметры:
//  АдресWSDL - Строка - месторасположение wsdl.
//  URIПространстваИмен - Строка - URI пространства имен web-сервиса.
//  ИмяСервиса - Строка - имя сервиса.
//  ИмяТочкиПодключения - Строка - если не задано, образуется как <ИмяСервиса>Soap.
//  ИмяПользователя - Строка - имя пользователя для входа на сервер.
//  Пароль - Строка - пароль пользователя.
//  Таймаут - Число - таймаут на операции выполняемые через полученное прокси.
//
// Возвращаемое значение:
//  WSПрокси
//
Функция WSПрокси(Знач АдресWSDL,
	Знач URIПространстваИмен,
	Знач ИмяСервиса,
	Знач ИмяТочкиПодключения = "",
	Знач ИмяПользователя,
	Знач Пароль,
	Знач Таймаут = 0,
	Знач ДелатьКонтрольныйВызов = Ложь) Экспорт

	Если ДелатьКонтрольныйВызов И Таймаут <> Неопределено И Таймаут > 20 Тогда
		
		WSПроксиPing = ОбщегоНазначенияПовтИсп.WSПрокси(
			АдресWSDL,
			URIПространстваИмен,
			ИмяСервиса,
			ИмяТочкиПодключения,
			ИмяПользователя,
			Пароль,
			3);
		
		Попытка
			WSПроксиPing.Ping();
		Исключение
			ЗаписьЖурналаРегистрации(ВернутьСтр("ru = 'WSПрокси'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
				УровеньЖурналаРегистрации.Ошибка,,, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			ВызватьИсключение;
		КонецПопытки;
		
	КонецЕсли;
	
	Возврат ОбщегоНазначенияПовтИсп.WSПрокси(
		АдресWSDL,
		URIПространстваИмен,
		ИмяСервиса,
		ИмяТочкиПодключения,
		ИмяПользователя,
		Пароль,
		Таймаут);
	
КонецФункции

// Определяет доступность объекта метаданных по функциональным опциям.
//
// Параметры:
//   ОбъектМетаданных - ОбъектМетаданных - проверяемый объект метаданных.
//
// Возвращаемое значение: 
//  Булево - Истина, если объект доступен.
//
Функция ОбъектМетаданныхДоступенПоФункциональнымОпциям(ОбъектМетаданных) Экспорт
	Возврат ОбщегоНазначенияПовтИсп.ДоступностьОбъектовПоОпциям()[ОбъектМетаданных] <> Ложь;
КонецФункции

// Устанавливает или снимает пометку удаления для всех объектов, которые ссылаются на заданный "объект-владелец".
//
// Параметры:
//  Владелец        - ПланОбменаСсылка, СправочникСсылка, ДокументСсылка - ссылка на объект, который является
//                    "владельцем" по отношению к помечаемым на удаление объектам.
//
//  ПометкаУдаления - Булево - признак установки/снятия пометки на удаление у всех "подчиненных" объектов.
//
Процедура УстановитьПометкуУдаленияПодчиненнымОбъектам(Знач Владелец, Знач ПометкаУдаления) Экспорт
	
	НачатьТранзакцию();
	Попытка
		
		СписокСсылок = Новый Массив;
		СписокСсылок.Добавить(Владелец);
		Ссылки = НайтиПоСсылкам(СписокСсылок);
		
		Для Каждого Ссылка Из Ссылки Цикл
			
			Если ЗначениеСсылочногоТипа(Ссылка[1]) Тогда
				
				Ссылка[1].ПолучитьОбъект().УстановитьПометкуУдаления(ПометкаУдаления);
				
			КонецЕсли;
			
		КонецЦикла;
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Пытается выполнить запрос в несколько попыток.
// Используется для чтения вне транзакции часто изменяемых данных.
// При вызове в транзакции выдает ошибку.
//
// Параметры:
//  Запрос - Запрос - запрос который требуется выполнить.
//
// Возвращаемое значение:
//  РезультатЗапроса - результат выполнения запроса.
//
Функция ВыполнитьЗапросВнеТранзакции(Знач Запрос) Экспорт
	
	Если ТранзакцияАктивна() Тогда
		ВызватьИсключение(ВернутьСтр("ru = 'Транзакция активна. Выполнение запроса вне транзакции невозможно.'"));
	КонецЕсли;
	
	КоличествоПопыток = 0;
	
	Результат = Неопределено;
	Пока Истина Цикл
		Попытка
			Результат = Запрос.Выполнить(); // Чтение вне транзакции, возможно появление ошибки.
			                                // Could not continue scan with NOLOCK due to data movement
			                                // в этом случае нужно повторить попытку чтения.
			Прервать;
		Исключение
			КоличествоПопыток = КоличествоПопыток + 1;
			Если КоличествоПопыток = 5 Тогда
				ВызватьИсключение;
			КонецЕсли;
		КонецПопытки;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Возвращает общие параметры базовой функциональности.
//
// Возвращаемое значение: 
//  Структура - структура со свойствами:
//      * ИмяФормыПерсональныхНастроек            - Строка - имя формы для редактирования персональных настроек.
//                                                           Ранее определялись в
//                                                           ОбщегоНазначенияПереопределяемый.ИмяФормыПерсональныхНастроек.
//      * МинимальноНеобходимаяВерсияПлатформы    - Строка - полный номер версии платформы для запуска программы.
//                                                           Например, "8.3.4.365".
//                                                           Ранее определялись в
//                                                           ОбщегоНазначенияПереопределяемый.ПолучитьМинимальноНеобходимуюВерсиюПлатформы.
//      * РаботаВПрограммеЗапрещена               - Булево - Начальное значение Ложь.
//      * ЗапрашиватьПодтверждениеПриЗавершенииПрограммы - Булево - по умолчанию Истина. Если установить Ложь, то 
//                                                                  подтверждение при завершении работы программы не
//                                                                  будет запрашиваться,  если явно не разрешить в
//                                                                  персональных настройках программы.
//      * ОтключитьИдентификаторыОбъектовМетаданных - Булево - отключает заполнение справочников ИдентификаторыОбъектовМетаданных
//              и ИдентификаторыОбъектовРасширений, процедуру выгрузки и загрузки в узлах РИБ.
//              Для частичного встраивания отдельных функций библиотеки в конфигурации без постановки на поддержку.
//
Функция ОбщиеПараметрыБазовойФункциональности() Экспорт
	
	ОбщиеПараметры = Новый Структура;
	ОбщиеПараметры.Вставить("ИмяФормыПерсональныхНастроек", "");
	ОбщиеПараметры.Вставить("МинимальноНеобходимаяВерсияПлатформы", "8.3.6.2041");
	ОбщиеПараметры.Вставить("РаботаВПрограммеЗапрещена", Ложь); // Блокировать запуск, если версия ниже минимальной.
	ОбщиеПараметры.Вставить("ЗапрашиватьПодтверждениеПриЗавершенииПрограммы", Истина);
	ОбщиеПараметры.Вставить("ОтключитьИдентификаторыОбъектовМетаданных", Ложь);
	ОбщиеПараметры.Вставить("РекомендуемыйОбъемОперативнойПамяти", 2);
	
	ОбщегоНазначенияПереопределяемый.ПриОпределенииОбщихПараметровБазовойФункциональности(ОбщиеПараметры);
	
	Возврат ОбщиеПараметры;
	
КонецФункции

// Определяет, что эта информационная база является подчиненным узлом
// распределенной информационной базы (РИБ) с фильтром.
//
// Возвращаемое значение: 
//  Булево
//
Функция ЭтоПодчиненныйУзелРИБСФильтром() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если ПланыОбмена.ГлавныйУзел() <> Неопределено
		И ПодсистемаСуществует("СтандартныеПодсистемы.ОбменДанными") Тогда
		ОбщийМодульОбменДаннымиСервер = ОбщийМодуль("ОбменДаннымиСервер");
		Если ОбщийМодульОбменДаннымиСервер.НазначениеПланаОбмена(ПланыОбмена.ГлавныйУзел().Метаданные().Имя) = "РИБСФильтром" Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Определяет, что эта информационная база является подчиненным узлом
// распределенной информационной базы (РИБ).
//
// Возвращаемое значение: 
//  Булево
//
Функция ЭтоПодчиненныйУзелРИБ() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Возврат ПланыОбмена.ГлавныйУзел() <> Неопределено;
	
КонецФункции

// Возвращает Истина при необходимости обновления конфигурации информационной базы подчиненного узла РИБ.
// В главном узле всегда - Ложь.
//
// Возвращаемое значение: 
//  Булево
//
Функция ТребуетсяОбновлениеКонфигурацииПодчиненногоУзлаРИБ() Экспорт
	
	Возврат ЭтоПодчиненныйУзелРИБ() И КонфигурацияИзменена();
	
КонецФункции

// Возвращает Истина, если текущий сеанс выполняется на сервере, работающим под управлением ОС Linux.
//
// Возвращаемое значение:
//  Булево - Истина, если сервер работает под управлением ОС Linux.
//
Функция ЭтоLinuxСервер() Экспорт
	
	СистемнаяИнформация = Новый СистемнаяИнформация;
	Возврат СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Linux_x86 ИЛИ СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Linux_x86_64;
	
КонецФункции

// Предназначена для вставки в начало обработчика ПриСозданииНаСервере управляемых форм, которые размещаются на рабочем
// столе.
//
// Предотвращает открытие формы в ряде особых случаев:
//  - если рабочий стол открывается до завершения обновления данных ИБ
//   (исключается возможность заведомо ошибочного обращения к еще необновленным данным);
//  - если в разделенную ИБ выполняется вход в сеансе с неустановленным значением разделителя
//  ОбластьДанныхОсновныеДанные
//   (исключается возможность заведомо ошибочного обращения к разделенным данным из неразделенного сеанса);
//
// Не следует использовать в формах, которые используются перед началом работы системы,
// а также в формах, предназначенных для работы в неразделенном сеансе.
//
// Параметры:
//  Форма - УправляемаяФорма - ссылка на форму, которая создается.
//  Отказ - Булево - параметр переданный в обработчик формы ПриСозданииНаСервере.
//  СтандартнаяОбработка - Булево - параметр переданный в обработчик формы ПриСозданииНаСервере.
//
// Возвращаемое значение:
//  Булево - если Ложь, значит установлен отказ создания формы.
//
Функция ПриСозданииНаСервере(Форма, Отказ, СтандартнаяОбработка) Экспорт
	
	Если ОбщегоНазначенияПовтИсп.РазделениеВключено()
		И Не ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных() Тогда
		Отказ = Истина;
		Возврат Ложь;
	КонецЕсли;
	
	Если Форма.Параметры.Свойство("АвтоТест") Тогда
		// Возврат при получении формы для анализа.
		Возврат Ложь;
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	Если ПараметрыСеанса.ПараметрыКлиентаНаСервере.Получить("СкрытьРабочийСтолПриНачалеРаботыСистемы") <> Неопределено Тогда
		Отказ = Истина;
		Возврат Ложь;
	КонецЕсли;
	УстановитьПривилегированныйРежим(Ложь);
	
	Возврат Истина;
	
КонецФункции

// Выполняет действия перед продолжением выполнения обработчика регламентного задания.
//
// Например, проверяет возможность выполнения обработчика регламентного задания.
// Если администратор не заблокировал выполнение регламентных заданий до
// окончания обновления ИБ, тогда требуется прекратить выполнение обработчика.
//
// Параметры:
//  РегламентноеЗадание - ОбъектМетаданных: РегламентноеЗадание - регламентное задание,
//    из которого был вызван данный метод. Необходимо передавать для проверки доступности
//    по функциональным опциям.
//
Процедура ПриНачалеВыполненияРегламентногоЗадания(РегламентноеЗадание = Неопределено) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	Справочники.ВерсииРасширений.ЗарегистрироватьИспользованиеВерсииРасширений();
	УстановитьПривилегированныйРежим(Ложь);
	
	Если СтандартныеПодсистемыСервер.НеобходимоОбновлениеПараметровРаботыПрограммы() Тогда
		ВызватьИсключение
			ВернутьСтр("ru = 'Вход в программу временно невозможен в связи с обновлением на новую версию.
			           |Рекомендуется запрещать выполнение регламентных заданий на время обновления.'");
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если Не ОбщегоНазначенияПовтИсп.РазделениеВключено()
	   И ПланыОбмена.ГлавныйУзел() = Неопределено
	   И ЗначениеЗаполнено(Константы.ГлавныйУзел.Получить()) Тогда
		
		ВызватьИсключение
			ВернутьСтр("ru = 'Вход в программу временно невозможен до восстановления связи с главным узлом.
			           |Рекомендуется запрещать выполнение регламентных заданий на время восстановления.'");
	КонецЕсли;
	
	Если РегламентноеЗадание <> Неопределено
		И ПодсистемаСуществует("СтандартныеПодсистемы.РегламентныеЗадания") Тогда
		МодульРегламентныеЗаданияСлужебный = ОбщийМодуль("РегламентныеЗаданияСлужебный");
		
		ЗависимостиЗаданий = Неопределено;
		МодульРегламентныеЗаданияСлужебный.ПроверитьВозможностьРаботыСВнешнимиРесурсами(
			РегламентноеЗадание, ЗависимостиЗаданий);
		
		Доступно = МодульРегламентныеЗаданияСлужебный.РегламентноеЗаданиеДоступноПоФункциональнымОпциям(
			РегламентноеЗадание, ЗависимостиЗаданий);
		Если Не Доступно Тогда
			ВызватьИсключение
				ВернутьСтр("ru = 'Регламентное задание недоступно по функциональным опциям
					|или не поддерживает работу в текущем режиме работы программы.
					|Выполнение прервано.'");
		КонецЕсли;
		
		
	КонецЕсли;
	
КонецПроцедуры

// Возвращает редакцию конфигурации.
// Редакцией принято называть две первые группы цифр полной версии конфигурации.
// Например, у версии "1.2.3.4" редакция "1.2".
//
// Возвращаемое значение:
//  Строка - номер редакции конфигурации.
//
Функция РедакцияКонфигурации() Экспорт
	
	Результат = "";
	ВерсияКонфигурации = Метаданные.Версия;
	
	Позиция = СтрНайти(ВерсияКонфигурации, ".");
	Если Позиция > 0 Тогда
		Результат = Лев(ВерсияКонфигурации, Позиция);
		ВерсияКонфигурации = Сред(ВерсияКонфигурации, Позиция + 1);
		Позиция = СтрНайти(ВерсияКонфигурации, ".");
		Если Позиция > 0 Тогда
			Результат = Результат + Лев(ВерсияКонфигурации, Позиция - 1);
		Иначе
			Результат = "";
		КонецЕсли;
	КонецЕсли;
	
	Если ПустаяСтрока(Результат) Тогда
		Результат = Метаданные.Версия;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Возвращает строковое представление интервала между переданными датами или
// относительно переданной даты и текущей даты сеанса.
//
// Параметры:
//  ВремяНачала    - Дата - начальная точка интервала.
//  ВремяОкончания - Дата - конечная точка интервала, если не задана - берется текущая дата сеанса.
//
Функция ИнтервалВремениСтрокой(ВремяНачала, ВремяОкончания = Неопределено) Экспорт
	
	Если ВремяОкончания = Неопределено Тогда
		ВремяОкончания = ТекущаяДатаСеанса();
	ИначеЕсли ВремяНачала > ВремяОкончания Тогда
		ВызватьИсключение ВернутьСтр("ru = 'Дата окончания интервала не может быть меньше даты начала.'");
	КонецЕсли;
	
	ВеличинаИнтервала = ВремяОкончания - ВремяНачала;
	ВеличинаИнтервалаВДнях = Цел(ВеличинаИнтервала/60/60/24);
	
	Если ВеличинаИнтервалаВДнях > 365 Тогда
		ОписаниеИнтервала = ВернутьСтр("ru = 'более года'");
	ИначеЕсли ВеличинаИнтервалаВДнях > 31 Тогда
		ОписаниеИнтервала = ВернутьСтр("ru = 'более месяца'");
	ИначеЕсли ВеличинаИнтервалаВДнях >= 1 Тогда
		ОписаниеИнтервала = Формат(ВеличинаИнтервалаВДнях, "ЧДЦ=0") + " "
			+ ПользователиСлужебныйКлиентСервер.ПредметЦелогоЧисла(ВеличинаИнтервалаВДнях,
				"Л = ru_RU", ВернутьСтр("ru = 'день,дня,дней,,,,,,0'"));
	Иначе
		ОписаниеИнтервала = ВернутьСтр("ru = 'менее одного дня'");
	КонецЕсли;
	
	Возврат ОписаниеИнтервала;
	
КонецФункции

// Возвращает фрагмент текста запроса, отделяющего один запрос от другого.
//
// Возвращаемое значение:
//  Строка - разделитель запросов.
//
Функция РазделительПакетаЗапросов() Экспорт
	
	Возврат "
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|";
		
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для работы с формами.

// Процедура предназначена для заполнения реквизита формы типа ДанныеФормыДерево.
//
// Параметры:
//  КоллекцияЭлементовДерева - ДанныеФормыДерево - реквизит, который нужно заполнить.
//  ДеревоЗначений           - ДеревоЗначений    - данные для заполнения.
// 
Процедура ЗаполнитьКоллекциюЭлементовДереваДанныхФормы(КоллекцияЭлементовДерева, ДеревоЗначений) Экспорт
	
	Для Каждого Строка Из ДеревоЗначений.Строки Цикл
		
		ЭлементДерева = КоллекцияЭлементовДерева.Добавить();
		
		ЗаполнитьЗначенияСвойств(ЭлементДерева, Строка);
		
		Если Строка.Строки.Количество() > 0 Тогда
			
			ЗаполнитьКоллекциюЭлементовДереваДанныхФормы(ЭлементДерева.ПолучитьЭлементы(), Строка);
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для работы с типами, объектами метаданных и их строковыми представлениями.

// Получает дерево метаданных конфигурации с заданным отбором по объектам метаданных.
//
// Параметры:
//   Отбор - Структура - содержит значения элементов отбора.
//						Если параметр задан, то будет получено дерево метаданных в соответствии с заданным отбором:
//						Ключ - Строка - имя свойства элемента метаданных;
//						Значение - Массив - множество значений для отбора.
//
// Пример инициализации переменной "Отбор":
//
// Массив = Новый Массив;
// Массив.Добавить("Константа.ИспользоватьСинхронизациюДанных");
// Массив.Добавить("Справочник.Валюты");
// Массив.Добавить("Справочник.Организации");
// Отбор = Новый Структура;
// Отбор.Вставить("ПолноеИмя", Массив);
// 
//  Возвращаемое значение:
//   ДеревоЗначений - дерево описания метаданных конфигурации.
//
Функция ДеревоМетаданныхКонфигурации(Отбор = Неопределено) Экспорт
	
	ИспользоватьОтбор = (Отбор <> Неопределено);
	
	КоллекцииОбъектовМетаданных = Новый ТаблицаЗначений;
	КоллекцииОбъектовМетаданных.Колонки.Добавить("Имя");
	КоллекцииОбъектовМетаданных.Колонки.Добавить("Синоним");
	КоллекцииОбъектовМетаданных.Колонки.Добавить("Картинка");
	КоллекцииОбъектовМетаданных.Колонки.Добавить("КартинкаОбъекта");
	
	НоваяСтрокаКоллекцииОбъектовМетаданных("Константы",               ВернутьСтр("ru = 'Константы'"),                 БиблиотекаКартинок.Константа,              БиблиотекаКартинок.Константа,                    КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("Справочники",             ВернутьСтр("ru = 'Справочники'"),               БиблиотекаКартинок.Справочник,             БиблиотекаКартинок.Справочник,                   КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("Документы",               ВернутьСтр("ru = 'Документы'"),                 БиблиотекаКартинок.Документ,               БиблиотекаКартинок.ДокументОбъект,               КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("ПланыВидовХарактеристик", ВернутьСтр("ru = 'Планы видов характеристик'"), БиблиотекаКартинок.ПланВидовХарактеристик, БиблиотекаКартинок.ПланВидовХарактеристикОбъект, КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("ПланыСчетов",             ВернутьСтр("ru = 'Планы счетов'"),              БиблиотекаКартинок.ПланСчетов,             БиблиотекаКартинок.ПланСчетовОбъект,             КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("ПланыВидовРасчета",       ВернутьСтр("ru = 'Планы видов расчета'"),       БиблиотекаКартинок.ПланВидовРасчета,       БиблиотекаКартинок.ПланВидовРасчетаОбъект,       КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("РегистрыСведений",        ВернутьСтр("ru = 'Регистры сведений'"),         БиблиотекаКартинок.РегистрСведений,        БиблиотекаКартинок.РегистрСведений,              КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("РегистрыНакопления",      ВернутьСтр("ru = 'Регистры накопления'"),       БиблиотекаКартинок.РегистрНакопления,      БиблиотекаКартинок.РегистрНакопления,            КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("РегистрыБухгалтерии",     ВернутьСтр("ru = 'Регистры бухгалтерии'"),      БиблиотекаКартинок.РегистрБухгалтерии,     БиблиотекаКартинок.РегистрБухгалтерии,           КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("РегистрыРасчета",         ВернутьСтр("ru = 'Регистры расчета'"),          БиблиотекаКартинок.РегистрРасчета,         БиблиотекаКартинок.РегистрРасчета,               КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("БизнесПроцессы",          ВернутьСтр("ru = 'Бизнес-процессы'"),           БиблиотекаКартинок.БизнесПроцесс,          БиблиотекаКартинок.БизнесПроцессОбъект,          КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("Задачи",                  ВернутьСтр("ru = 'Задачи'"),                    БиблиотекаКартинок.Задача,                 БиблиотекаКартинок.ЗадачаОбъект,                 КоллекцииОбъектовМетаданных);
	
	// Возвращаемое значение функции.
	ДеревоМетаданных = Новый ДеревоЗначений;
	ДеревоМетаданных.Колонки.Добавить("Имя");
	ДеревоМетаданных.Колонки.Добавить("ПолноеИмя");
	ДеревоМетаданных.Колонки.Добавить("Синоним");
	ДеревоМетаданных.Колонки.Добавить("Картинка");
	
	Для Каждого СтрокаКоллекции Из КоллекцииОбъектовМетаданных Цикл
		
		СтрокаДерева = ДеревоМетаданных.Строки.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаДерева, СтрокаКоллекции);
		Для Каждого ОбъектМетаданных Из Метаданные[СтрокаКоллекции.Имя] Цикл
			
			Если ИспользоватьОтбор Тогда
				
				ОбъектПрошелФильтр = Истина;
				Для Каждого ЭлементОтбора Из Отбор Цикл
					
					Значение = ?(ВРег(ЭлементОтбора.Ключ) = ВРег("ПолноеИмя"), ОбъектМетаданных.ПолноеИмя(), ОбъектМетаданных[ЭлементОтбора.Ключ]);
					Если ЭлементОтбора.Значение.Найти(Значение) = Неопределено Тогда
						ОбъектПрошелФильтр = Ложь;
						Прервать;
					КонецЕсли;
					
				КонецЦикла;
				
				Если Не ОбъектПрошелФильтр Тогда
					Продолжить;
				КонецЕсли;
				
			КонецЕсли;
			
			СтрокаДереваОМ = СтрокаДерева.Строки.Добавить();
			СтрокаДереваОМ.Имя       = ОбъектМетаданных.Имя;
			СтрокаДереваОМ.ПолноеИмя = ОбъектМетаданных.ПолноеИмя();
			СтрокаДереваОМ.Синоним   = ОбъектМетаданных.Синоним;
			СтрокаДереваОМ.Картинка  = СтрокаКоллекции.КартинкаОбъекта;
			
		КонецЦикла;
		
	КонецЦикла;
	
	// Удаляем строки без подчиненных элементов.
	Если ИспользоватьОтбор Тогда
		
		// Используем обратный порядок обхода дерева значений.
		КоличествоЭлементовКоллекции = ДеревоМетаданных.Строки.Количество();
		
		Для ОбратныйИндекс = 1 По КоличествоЭлементовКоллекции Цикл
			
			ТекущийИндекс = КоличествоЭлементовКоллекции - ОбратныйИндекс;
			СтрокаДерева = ДеревоМетаданных.Строки[ТекущийИндекс];
			Если СтрокаДерева.Строки.Количество() = 0 Тогда
				ДеревоМетаданных.Строки.Удалить(ТекущийИндекс);
			КонецЕсли;
			
		КонецЦикла;
	
	КонецЕсли;
	
	Возврат ДеревоМетаданных;
	
КонецФункции

// Получить представление физического места размещения информационной базы для отображения администратору.
//
// Возвращаемое значение:
//   Строка - представление информационной базы.
//
// Пример возвращаемого результата:
// - для ИБ в файлом режиме: \\FileServer\1c_ib\
// - для ИБ в серверном режиме: ServerName:1111 / information_base_name.
//
Функция ПолучитьПредставлениеИнформационнойБазы() Экспорт
	
	СтрокаСоединенияСБД = СтрокаСоединенияИнформационнойБазы();
	
	Если ИнформационнаяБазаФайловая(СтрокаСоединенияСБД) Тогда
		Возврат Сред(СтрокаСоединенияСБД, 6, СтрДлина(СтрокаСоединенияСБД) - 6);
	КонецЕсли;
		
	// Прибавить к имени сервера имя пути информационной базы.
	ПозицияПоиска = СтрНайти(Врег(СтрокаСоединенияСБД), "SRVR=");
	Если ПозицияПоиска <> 1 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ПозицияТочкиСЗапятой = СтрНайти(СтрокаСоединенияСБД, ";");
	НачальнаяПозицияКопирования = 6 + 1;
	КонечнаяПозицияКопирования = ПозицияТочкиСЗапятой - 2; 
	
	ИмяСервера = Сред(СтрокаСоединенияСБД, НачальнаяПозицияКопирования, КонечнаяПозицияКопирования - НачальнаяПозицияКопирования + 1);
	
	СтрокаСоединенияСБД = Сред(СтрокаСоединенияСБД, ПозицияТочкиСЗапятой + 1);
	
	// Позиция имени сервера
	ПозицияПоиска = СтрНайти(Врег(СтрокаСоединенияСБД), "REF=");
	Если ПозицияПоиска <> 1 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	НачальнаяПозицияКопирования = 6;
	ПозицияТочкиСЗапятой = СтрНайти(СтрокаСоединенияСБД, ";");
	КонечнаяПозицияКопирования = ПозицияТочкиСЗапятой - 2; 
	
	ИмяИБНаСервере = Сред(СтрокаСоединенияСБД, НачальнаяПозицияКопирования, КонечнаяПозицияКопирования - НачальнаяПозицияКопирования + 1);
	ПутьКБД = ИмяСервера + "/ " + ИмяИБНаСервере;
	Возврат ПутьКБД;
	
КонецФункции

// Возвращает строку реквизитов объекта метаданных с заданным типом.
//
// Параметры:
//  Ссылка - ЛюбаяСсылка - ссылка на элемент базы данных, для которого требуется получить результат функции;
//  Тип    - Тип - тип значения реквизита.
// 
// Возвращаемое значение:
//  Строка - строка реквизитов объекта метаданных конфигурации, разделенные символом ",".
//
Функция ИменаРеквизитовПоТипу(Ссылка, Тип) Экспорт
	
	Результат = "";
	МетаданныеОбъекта = Ссылка.Метаданные();
	
	Для Каждого Реквизит Из МетаданныеОбъекта.Реквизиты Цикл
		Если Реквизит.Тип.СодержитТип(Тип) Тогда
			Результат = Результат + ?(ПустаяСтрока(Результат), "", ", ") + Реквизит.Имя;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

// Возвращает имя базового типа по переданному значению объекта метаданных.
//
// Параметры:
//  ОбъектМетаданных - объект метаданных, по которому необходимо определить базовый тип.
// 
// Возвращаемое значение:
//  Строка - имя базового типа по переданному значению объекта метаданных.
//
Функция ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) Экспорт
	
	Если Метаданные.Документы.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаДокументы();
		
	ИначеЕсли Метаданные.Справочники.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаСправочники();
		
	ИначеЕсли Метаданные.Перечисления.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПеречисления();
		
	ИначеЕсли Метаданные.РегистрыСведений.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаРегистрыСведений();
		
	ИначеЕсли Метаданные.РегистрыНакопления.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаРегистрыНакопления();
		
	ИначеЕсли Метаданные.РегистрыБухгалтерии.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаРегистрыБухгалтерии();
		
	ИначеЕсли Метаданные.РегистрыРасчета.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаРегистрыРасчета();
		
	ИначеЕсли Метаданные.ПланыОбмена.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПланыОбмена();
		
	ИначеЕсли Метаданные.ПланыВидовХарактеристик.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПланыВидовХарактеристик();
		
	ИначеЕсли Метаданные.БизнесПроцессы.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаБизнесПроцессы();
		
	ИначеЕсли Метаданные.Задачи.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаЗадачи();
		
	ИначеЕсли Метаданные.ПланыСчетов.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПланыСчетов();
		
	ИначеЕсли Метаданные.ПланыВидовРасчета.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПланыВидовРасчета();
		
	ИначеЕсли Метаданные.Константы.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаКонстанты();
		
	ИначеЕсли Метаданные.ЖурналыДокументов.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаЖурналыДокументов();
		
	ИначеЕсли Метаданные.Последовательности.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПоследовательности();
		
	ИначеЕсли Метаданные.РегламентныеЗадания.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаРегламентныеЗадания();
		
	ИначеЕсли Метаданные.РегистрыРасчета.Содержит(ОбъектМетаданных.Родитель())
		И ОбъектМетаданных.Родитель().Перерасчеты.Найти(ОбъектМетаданных.Имя) = ОбъектМетаданных Тогда
		Возврат ИмяТипаПерерасчеты();
		
	Иначе
		
		Возврат "";
		
	КонецЕсли;
	
КонецФункции

// Возвращает менеджер объекта по полному имени объекта метаданных.
// Ограничение: не обрабатываются точки маршрутов бизнес-процессов.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных. Пример: "Справочник.Организации".
//
// Возвращаемое значение:
//  СправочникМенеджер, ДокументМенеджер.
// 
Функция МенеджерОбъектаПоПолномуИмени(ПолноеИмя) Экспорт
	Перем КлассОМ, ИмяОМ, Менеджер;
	
	ЧастиИмени = СтрРазделить(ПолноеИмя, ".");
	
	Если ЧастиИмени.Количество() >= 2 Тогда
		КлассОМ = ЧастиИмени[0];
		ИмяОМ  = ЧастиИмени[1];
	КонецЕсли;
	
	Если      ВРег(КлассОМ) = "ПЛАНОБМЕНА" Тогда
		Менеджер = ПланыОбмена;
		
	ИначеЕсли ВРег(КлассОМ) = "СПРАВОЧНИК" Тогда
		Менеджер = Справочники;
		
	ИначеЕсли ВРег(КлассОМ) = "ДОКУМЕНТ" Тогда
		Менеджер = Документы;
		
	ИначеЕсли ВРег(КлассОМ) = "ЖУРНАЛДОКУМЕНТОВ" Тогда
		Менеджер = ЖурналыДокументов;
		
	ИначеЕсли ВРег(КлассОМ) = "ПЕРЕЧИСЛЕНИЕ" Тогда
		Менеджер = Перечисления;
		
	ИначеЕсли ВРег(КлассОМ) = "ОТЧЕТ" Тогда
		Менеджер = Отчеты;
		
	ИначеЕсли ВРег(КлассОМ) = "ОБРАБОТКА" Тогда
		Менеджер = Обработки;
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНВИДОВХАРАКТЕРИСТИК" Тогда
		Менеджер = ПланыВидовХарактеристик;
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНСЧЕТОВ" Тогда
		Менеджер = ПланыСчетов;
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНВИДОВРАСЧЕТА" Тогда
		Менеджер = ПланыВидовРасчета;
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРСВЕДЕНИЙ" Тогда
		Менеджер = РегистрыСведений;
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРНАКОПЛЕНИЯ" Тогда
		Менеджер = РегистрыНакопления;
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРБУХГАЛТЕРИИ" Тогда
		Менеджер = РегистрыБухгалтерии;
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРРАСЧЕТА" Тогда
		Если ЧастиИмени.Количество() = 2 Тогда
			// Регистр расчета
			Менеджер = РегистрыРасчета;
		Иначе
			КлассПодчиненногоОМ = ЧастиИмени[2];
			ИмяПодчиненногоОМ = ЧастиИмени[3];
			Если ВРег(КлассПодчиненногоОМ) = "ПЕРЕРАСЧЕТ" Тогда
				// Перерасчет
				Попытка
					Менеджер = РегистрыРасчета[ИмяОМ].Перерасчеты;
					ИмяОм = ИмяПодчиненногоОМ;
				Исключение
					Менеджер = Неопределено;
				КонецПопытки;
			КонецЕсли;
		КонецЕсли;
		
	ИначеЕсли ВРег(КлассОМ) = "БИЗНЕСПРОЦЕСС" Тогда
		Менеджер = БизнесПроцессы;
		
	ИначеЕсли ВРег(КлассОМ) = "ЗАДАЧА" Тогда
		Менеджер = Задачи;
		
	ИначеЕсли ВРег(КлассОМ) = "КОНСТАНТА" Тогда
		Менеджер = Константы;
		
	ИначеЕсли ВРег(КлассОМ) = "ПОСЛЕДОВАТЕЛЬНОСТЬ" Тогда
		Менеджер = Последовательности;
	КонецЕсли;
	
	Если Менеджер <> Неопределено Тогда
		Попытка
			Возврат Менеджер[ИмяОМ];
		Исключение
			Менеджер = Неопределено;
		КонецПопытки;
	КонецЕсли;
	
	ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ВернутьСтр("ru = 'Неизвестный тип объекта метаданных ""%1""'"), ПолноеИмя);
	
КонецФункции

// Возвращает менеджер объекта по ссылке на объект.
// Ограничение: не обрабатываются точки маршрутов бизнес-процессов.
//
// Параметры:
//  Ссылка - ЛюбаяСсылка - объект, менеджер которого требуется получить.
//
// Возвращаемое значение:
//  СправочникМенеджер, ДокументМенеджер.
// 
Функция МенеджерОбъектаПоСсылке(Ссылка) Экспорт
	
	ИмяОбъекта = Ссылка.Метаданные().Имя;
	ТипСсылки = ТипЗнч(Ссылка);
	
	Если Справочники.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Справочники[ИмяОбъекта];
		
	ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Документы[ИмяОбъекта];
		
	ИначеЕсли БизнесПроцессы.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат БизнесПроцессы[ИмяОбъекта];
		
	ИначеЕсли ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыВидовХарактеристик[ИмяОбъекта];
		
	ИначеЕсли ПланыСчетов.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыСчетов[ИмяОбъекта];
		
	ИначеЕсли ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыВидовРасчета[ИмяОбъекта];
		
	ИначеЕсли Задачи.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Задачи[ИмяОбъекта];
		
	ИначеЕсли ПланыОбмена.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыОбмена[ИмяОбъекта];
		
	ИначеЕсли Перечисления.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Перечисления[ИмяОбъекта];
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции

// Создает и возвращает экземпляр объекта по полному имени объекта метаданных.
// Ограничение: поддерживаются только отчеты и обработки.
//
// Параметры:
//   ПолноеИмя - Строка - полное имя объекта метаданных. Пример: "Отчет.БизнесПроцессы".
//
// Возвращаемое значение:
//   ОтчетОбъект, ОбработкаОбъект.
// 
Функция ОбъектПоПолномуИмени(ПолноеИмя) Экспорт
	МассивСтрок = СтрРазделить(ПолноеИмя, ".");
	
	Если МассивСтрок.Количество() >= 2 Тогда
		Вид = ВРег(МассивСтрок[0]);
		Имя = МассивСтрок[1];
	Иначе
		ВызватьИсключение СтрЗаменить(ВернутьСтр("ru = 'Некорректное полное имя отчета или обработки ""%1"".'"), "%1", ПолноеИмя);
	КонецЕсли;
	
	Если Вид = "ОТЧЕТ" Тогда
		Возврат Отчеты[Имя].Создать();
	ИначеЕсли Вид = "ОБРАБОТКА" Тогда
		Возврат Обработки[Имя].Создать();
	ИначеЕсли Вид = "ВНЕШНИЙОТЧЕТ" Тогда
		Возврат ВнешниеОтчеты.Создать(Имя);
	ИначеЕсли Вид = "ВНЕШНЯЯОБРАБОТКА" Тогда
		Возврат ВнешниеОбработки.Создать(Имя);
	Иначе
		ВызватьИсключение СтрЗаменить(ВернутьСтр("ru = '""%1"" не является отчетом или обработкой.'"), "%1", ПолноеИмя);
	КонецЕсли;
КонецФункции

// Проверяет физическое наличие записи в информационной базе данных о переданном значении ссылки.
//
// Параметры:
//  ЛюбаяСсылка - значение любой ссылки информационной базы данных.
// 
// Возвращаемое значение:
//  Булево.
//
Функция СсылкаСуществует(ЛюбаяСсылка) Экспорт
	
	ТекстЗапроса = "
	|ВЫБРАТЬ
	|	Ссылка КАК Ссылка
	|ИЗ
	|	[ИмяТаблицы]
	|ГДЕ
	|	Ссылка = &Ссылка
	|";
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "[ИмяТаблицы]", ИмяТаблицыПоСсылке(ЛюбаяСсылка));
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("Ссылка", ЛюбаяСсылка);
	
	УстановитьПривилегированныйРежим(Истина);
	
	Возврат НЕ Запрос.Выполнить().Пустой();
	
КонецФункции

// Возвращает имя вида объектов метаданных по ссылке на объект.
// Ограничение: не обрабатываются точки маршрутов бизнес-процессов.
//
// Параметры:
//  Ссылка - ЛюбаяСсылка - объект, вид которого требуется получить.
//
// Возвращаемое значение:
//  Строка - имя вида объектов метаданных. Например: "Справочник", "Документ".
// 
Функция ВидОбъектаПоСсылке(Ссылка) Экспорт
	
	Возврат ВидОбъектаПоТипу(ТипЗнч(Ссылка));
	
КонецФункции 

// Возвращает имя вида объектов метаданных по типу объекта.
// Ограничение: не обрабатываются точки маршрутов бизнес-процессов.
//
// Параметры:
//  Тип - Тип - Тип прикладного объекта, определенный в конфигурации .
//
// Возвращаемое значение:
//  Строка - имя вида объектов метаданных. Например: "Справочник", "Документ".
// 
Функция ВидОбъектаПоТипу(Тип) Экспорт
	
	Если Справочники.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "Справочник";
	
	ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "Документ";
	
	ИначеЕсли БизнесПроцессы.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "БизнесПроцесс";
	
	ИначеЕсли ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ПланВидовХарактеристик";
	
	ИначеЕсли ПланыСчетов.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ПланСчетов";
	
	ИначеЕсли ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ПланВидовРасчета";
	
	ИначеЕсли Задачи.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "Задача";
	
	ИначеЕсли ПланыОбмена.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ПланОбмена";
	
	ИначеЕсли Перечисления.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "Перечисление";
	
	Иначе
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ВернутьСтр("ru='Неверный тип значения параметра (%1)'"), Строка(Тип));
	
	КонецЕсли;
	
КонецФункции 

// Возвращает полное имя объекта метаданных по переданному значению ссылки.
// Примеры:
//  "Справочник.Номенклатура";
//  "Документ.ПриходнаяНакладная".
//
// Параметры:
//  Ссылка - ЛюбаяСсылка - объект, для которого необходимо получить имя таблицы ИБ.
// 
// Возвращаемое значение:
//  Строка - полное имя объекта метаданных для указанного объекта.
//
Функция ИмяТаблицыПоСсылке(Ссылка) Экспорт
	
	Возврат Ссылка.Метаданные().ПолноеИмя();
	
КонецФункции

// Проверить, что значение имеет ссылочный тип данных.
//
// Параметры:
//  Значение - Произвольный - проверяемое значение.
//
// Возвращаемое значение:
//  Булево - Истина, если тип значения ссылочный.
//
Функция ЗначениеСсылочногоТипа(Значение) Экспорт
	
	Возврат ЭтоСсылка(ТипЗнч(Значение));
	
КонецФункции

// Проверка того, что переданный тип является ссылочным типом данных.
// Для типа "Неопределено" возвращается Ложь.
//
// Возвращаемое значение:
//  Булево.
//
Функция ЭтоСсылка(Тип) Экспорт
	
	Возврат Тип <> Тип("Неопределено") 
		И (Справочники.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ Документы.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ Перечисления.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ ПланыСчетов.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ БизнесПроцессы.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ БизнесПроцессы.ТипВсеСсылкиТочекМаршрутаБизнесПроцессов().СодержитТип(Тип)
		ИЛИ Задачи.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ ПланыОбмена.ТипВсеСсылки().СодержитТип(Тип));
	
КонецФункции

// Проверяет, является ли объект группой элементов.
//
// Параметры:
//  Объект - ЛюбаяСсылка, Объект - проверяемый объект.
//
// Возвращаемое значение:
//  Булево.
//
Функция ОбъектЯвляетсяГруппой(Объект) Экспорт
	
	Если ЗначениеСсылочногоТипа(Объект) Тогда
		Ссылка = Объект;
	Иначе
		Ссылка = Объект.Ссылка;
	КонецЕсли;
	
	МетаданныеОбъекта = Ссылка.Метаданные();
	
	Если ЭтоСправочник(МетаданныеОбъекта) Тогда
		
		Если НЕ МетаданныеОбъекта.Иерархический
		 ИЛИ МетаданныеОбъекта.ВидИерархии
		     <> Метаданные.СвойстваОбъектов.ВидИерархии.ИерархияГруппИЭлементов Тогда
			
			Возврат Ложь;
		КонецЕсли;
		
	ИначеЕсли НЕ ЭтоПланВидовХарактеристик(МетаданныеОбъекта) Тогда
		Возврат Ложь;
		
	ИначеЕсли НЕ МетаданныеОбъекта.Иерархический Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если Ссылка <> Объект Тогда
		Возврат Объект.ЭтоГруппа;
	КонецЕсли;
	
	Возврат ЗначениеРеквизитаОбъекта(Ссылка, "ЭтоГруппа") = Истина;
	
КонецФункции

// Возвращает ссылку, соответствующую объекту метаданных, для
// использования в базе данных.
//  Например:
//  Идентификатор = ОбщегоНазначения.ИдентификаторОбъектаМетаданных(ТипЗнч(Ссылка));
//  Идентификатор = ОбщегоНазначения.ИдентификаторОбъектаМетаданных(ОбъектМетаданных);
//  Идентификатор = ОбщегоНазначения.ИдентификаторОбъектаМетаданных("Справочник.Организации");
//
//  Поддерживаемые объекты метаданных:
// - Подсистемы (требуется программировать переименование).
// - Роли       (требуется программировать переименование).
// - ПланыОбмена
// - Константы
// - Справочники
// - Документы
// - ЖурналыДокументов
// - Отчеты
// - Обработки
// - ПланыВидовХарактеристик
// - ПланыСчетов
// - ПланыВидовРасчета
// - РегистрыСведений
// - РегистрыНакопления
// - РегистрыБухгалтерии
// - РегистрыРасчета
// - БизнесПроцессы
// - Задачи
// 
// Подробнее см. в функции СвойстваКоллекцийОбъектовМетаданных()
// модуля менеджера справочника ИдентификаторыОбъектовМетаданных.
//
// Параметры:
//  ОписаниеОбъектаМетаданных - ОбъектМетаданных - объект метаданных конфигурации;
//                            - Тип - тип, который можно успешно использовать в функции Метаданные.НайтиПоТипу();
//                            - Строка - полное имя объекта метаданных, которое можно успешно использовать
//                              в функции Метаданные.НайтиПоПолномуИмени().
// Возвращаемое значение:
//  СправочникСсылка.ИдентификаторыОбъектовМетаданных, СправочникСсылка.ИдентификаторыОбъектовРасширений.
//
Функция ИдентификаторОбъектаМетаданных(ОписаниеОбъектаМетаданных) Экспорт
	
	Возврат Справочники.ИдентификаторыОбъектовМетаданных.ИдентификаторОбъектаМетаданных(ОписаниеОбъектаМетаданных);
	
КонецФункции

// Возвращает объект метаданных по переданному идентификатору.
//
// Параметры:
//  Идентификатор - СправочникСсылка.ИдентификаторыОбъектовМетаданных,
//                  СправочникСсылка.ИдентификаторыОбъектовРасширений - идентификатор
//                    объекта метаданных конфигурации или расширения.
//
// Возвращаемое значение:
//  ОбъектМетаданных - для типа СправочникСсылка.ИдентификаторыОбъектовМетаданных.
//  ОбъектМетаданных, Неопределено - для типа СправочникСсылка.ИдентификаторыОбъектовРасширений.
//   Если расширение не подключено, тогда объект метаданных невозможно вернуть и возвращается Неопределено.
//   Неопределено означает, что в справочнике ИдентификаторыОбъектовРасширений найден действующий
//   идентификатор, но объекта метаданных, который ему соответствует, найти не удалось.
//
Функция ОбъектМетаданныхПоИдентификатору(Идентификатор) Экспорт
	
	Возврат Справочники.ИдентификаторыОбъектовМетаданных.ОбъектМетаданныхПоИдентификатору(Идентификатор);
	
КонецФункции

// Возвращает Истина, если объект метаданных, которому соответствует
// идентификатор объектов расширений существует в справочнике и
// не помечен на удаление, но отсутствует в кэше метаданных расширений.
//
// Параметры:
//  Идентификатор - СправочникСсылка.ИдентификаторыОбъектовРасширений - идентификатор
//                    объекта метаданных расширения.
//
// Возвращаемое значение:
// Булево.
//
Функция ОбъектРасширенияОтключен(Идентификатор) Экспорт
	
	Возврат Справочники.ИдентификаторыОбъектовРасширений.ОбъектРасширенияОтключен(Идентификатор);
	
КонецФункции

// Для использования в процедуре ПриДобавленииПереименованийОбъектовМетаданных
// общего модуля ОбщегоНазначенияПереопределяемый для описания переименований объектов метаданных.
// 
// Параметры:
//   Итог                    - Структура - передается в процедуру подсистемой БазоваяФункциональность.
//   ВерсияИБ                - Строка    - версия при переходе на которую нужно выполнить переименование.
//   СтароеПолноеИмя         - Строка    - старое полное имя объекта метаданных,    которое нужно переименовать.
//   НовоеПолноеИмя          - Строка    - новое  полное имя объекта метаданных, на которое нужно переименовать.
//   ИдентификаторБиблиотеки - Строка    - внутренний идентификатор библиотеки, к которой относится ВерсияИБ.
//                                         Для основной конфигурации не требуется.
// 
Процедура ДобавитьПереименование(Итог, ВерсияИБ, СтароеПолноеИмя, НовоеПолноеИмя, ИдентификаторБиблиотеки = "") Экспорт
	
	Справочники.ИдентификаторыОбъектовМетаданных.ДобавитьПереименование(Итог,
		ВерсияИБ, СтароеПолноеИмя, НовоеПолноеИмя, ИдентификаторБиблиотеки);
	
КонецПроцедуры

// Возвращает строковое представление типа. 
// Для ссылочных типов возвращает в формате "СправочникСсылка.ИмяОбъекта" или "ДокументСсылка.ИмяОбъекта".
// Для остальных типов приводит тип к строке, например "Число".
//
// Возвращаемое значение:
//  Строка.
//
Функция СтроковоеПредставлениеТипа(Тип) Экспорт
	
	Представление = "";
	
	Если ЭтоСсылка(Тип) Тогда
	
		ПолноеИмя = Метаданные.НайтиПоТипу(Тип).ПолноеИмя();
		ИмяОбъекта = СтрРазделить(ПолноеИмя, ".")[1];
		
		Если Справочники.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "СправочникСсылка";
		
		ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ДокументСсылка";
		
		ИначеЕсли БизнесПроцессы.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "БизнесПроцессСсылка";
		
		ИначеЕсли ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ПланВидовХарактеристикСсылка";
		
		ИначеЕсли ПланыСчетов.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ПланСчетовСсылка";
		
		ИначеЕсли ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ПланВидовРасчетаСсылка";
		
		ИначеЕсли Задачи.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ЗадачаСсылка";
		
		ИначеЕсли ПланыОбмена.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ПланОбменаСсылка";
		
		ИначеЕсли Перечисления.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ПеречислениеСсылка";
		
		КонецЕсли;
		
		Результат = ?(Представление = "", Представление, Представление + "." + ИмяОбъекта);
		
	Иначе
		
		Результат = Строка(Тип);
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Проверить, что описание типа состоит из единственного типа значения и 
// совпадает с нужным типом.
//
// Параметры:
//   ОписаниеТипа - ОписаниеТипов - проверяемая коллекция типов;
//   ТипЗначения  - Тип - проверяемый тип.
//
// Возвращаемое значение:
//   Булево      - Истина, если совпадает.
//
Функция ОписаниеТипаСостоитИзТипа(ОписаниеТипа, ТипЗначения) Экспорт
	
	Если ОписаниеТипа.Типы().Количество() = 1
	   И ОписаниеТипа.Типы().Получить(0) = ТипЗначения Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Проверяет наличие табличной части у справочника.
//
// Параметры:
//  ИмяСправочника    - Строка - имя справочника, для которого осуществляется проверка.
//  ИмяТабличнойЧасти - Строка - имя табличной части, наличие которой проверяется.
//
// Возвращаемое значение:
//  Булево - Истина, если табличная часть есть.
//
// Пример:
//  Если НЕ ОбщегоНазначения.НаличиеТабличнойЧастиУСправочника(ИмяСправочника,"КонтактнаяИнформация") Тогда
//  	Возврат;
//  КонецЕсли;
//
Функция НаличиеТабличнойЧастиУСправочника(ИмяСправочника, ИмяТабличнойЧасти) Экспорт
	
	Возврат (Метаданные.Справочники[ИмяСправочника].ТабличныеЧасти.Найти(ИмяТабличнойЧасти) <> Неопределено);
	
КонецФункции 

// Возвращает признак того, что реквизит входит в подмножество стандартных реквизитов.
//
// Параметры:
//  СтандартныеРеквизиты - ОписанияСтандартныхРеквизитов - тип и значение описывает коллекцию настроек различных
//                                                         стандартных реквизитов;
//  ИмяРеквизита         - Строка - реквизит который необходимо проверить на принадлежность множеству стандартных
//                                  реквизитов;
// 
// Возвращаемое значение:
//   Булево - Истина, если реквизит входит в подмножество стандартных реквизитов.
//
Функция ЭтоСтандартныйРеквизит(СтандартныеРеквизиты, ИмяРеквизита) Экспорт
	
	Для Каждого Реквизит Из СтандартныеРеквизиты Цикл
		Если Реквизит.Имя = ИмяРеквизита Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	Возврат Ложь;
	
КонецФункции

// Получает таблицу значений с описанием требуемых свойств всех реквизитов объекта метаданного.
// Получает значения свойств стандартных реквизитов и пользовательских реквизитов (созданных в режиме конфигуратора).
//
// Параметры:
//  ОбъектМетаданных  - ОбъектМетаданных - объект, для которого необходимо получить значение свойств реквизитов.
//                      Например: Метаданные.Документ.РеализацияТоваровИУслуг
//  Свойства - Строка - свойства реквизитов, перечисленные через запятую, значение которых необходимо получить.
//                      Например: "Имя, Тип, Синоним, Подсказка".
//
// Возвращаемое значение:
//  ТаблицаЗначений - описание требуемых свойств всех реквизитов объекта метаданных.
//
Функция ПолучитьТаблицуОписанияСвойствОбъекта(ОбъектМетаданных, Свойства) Экспорт
	
	МассивСвойств = СтрРазделить(Свойства, ",");
	
	// Возвращаемое значение функции.
	ТаблицаОписанияСвойствОбъекта = Новый ТаблицаЗначений;
	
	// Добавляем в таблицу поля согласно именам переданных свойств.
	Для Каждого ИмяСвойства Из МассивСвойств Цикл
		ТаблицаОписанияСвойствОбъекта.Колонки.Добавить(СокрЛП(ИмяСвойства));
	КонецЦикла;
	
	// Заполняем строку таблицы свойствами реквизитов объекта метаданных.
	Для Каждого Реквизит Из ОбъектМетаданных.Реквизиты Цикл
		ЗаполнитьЗначенияСвойств(ТаблицаОписанияСвойствОбъекта.Добавить(), Реквизит);
	КонецЦикла;
	
	// Заполняем строку таблицы свойствами стандартных реквизитов объекта метаданных.
	Для Каждого Реквизит Из ОбъектМетаданных.СтандартныеРеквизиты Цикл
		ЗаполнитьЗначенияСвойств(ТаблицаОписанияСвойствОбъекта.Добавить(), Реквизит);
	КонецЦикла;
	
	Возврат ТаблицаОписанияСвойствОбъекта;
	
КонецФункции

// Возвращает состояние использования элемента состава общего реквизита.
//
// Параметры:
//  ЭлементСостава            - ОбъектМетаданных - элемент состава общего реквизита, использование которого требуется
//                                                 проверить.
//  МетаданныеОбщегоРеквизита - ОбъектМетаданных - объект метаданных общего реквизита, которому принадлежит
//                                                 ЭлементСостава.
//
// Возвращаемое значение:
//  Булево - Истина, если элемент состава используется, иначе Ложь.
//
Функция ЭлементСоставаОбщегоРеквизитаИспользуется(Знач ЭлементСостава, Знач МетаданныеОбщегоРеквизита) Экспорт
	
	Если ЭлементСостава.Использование = Метаданные.СвойстваОбъектов.ИспользованиеОбщегоРеквизита.Использовать Тогда
		Возврат Истина;
	ИначеЕсли ЭлементСостава.Использование = Метаданные.СвойстваОбъектов.ИспользованиеОбщегоРеквизита.НеИспользовать Тогда
		Возврат Ложь;
	Иначе
		Возврат МетаданныеОбщегоРеквизита.АвтоИспользование = Метаданные.СвойстваОбъектов.АвтоИспользованиеОбщегоРеквизита.Использовать;
	КонецЕсли;
	
КонецФункции

// Возвращает признак того, что объект метаданных используется в общих реквизитах-разделителях.
//
// Параметры:
//  ОбъектМетаданных - Строка, ОбъектМетаданных - Если объект метаданных задан строкой, происходит обращение к модулю
//                     повторного использования.
//  Разделитель      - Строка - имя общего реквизита-разделителя, на разделение которыми проверяется объект метаданных.
//
// Возвращаемое значение:
//  Булево - Истина, если объект метаданных используется хотя бы в одном общем разделителе.
//
Функция ЭтоРазделенныйОбъектМетаданных(Знач ОбъектМетаданных, Знач Разделитель) Экспорт
	
	Если ТипЗнч(ОбъектМетаданных) = Тип("Строка") Тогда
		ПолноеИмяОбъектаМетаданных = ОбъектМетаданных;
	Иначе
		ПолноеИмяОбъектаМетаданных = ОбъектМетаданных.ПолноеИмя();
	КонецЕсли;
	
	РазделенныеОбъектыМетаданных = ОбщегоНазначенияПовтИсп.РазделенныеОбъектыМетаданных(Разделитель);
	Возврат РазделенныеОбъектыМетаданных.Получить(ПолноеИмяОбъектаМетаданных) <> Неопределено;
	
КонецФункции

// Возвращает имя предопределенного элемента по указанной ссылке.
// Для использования вместо устаревшего метода ПолучитьИмяПредопределенного в
// конфигурациях, рассчитанных на платформу версии 8.2.
//
// Параметры:
//  Ссылка - ЛюбаяСсылка - ссылка на предопределенный элемент.
//
// Возвращаемое значение:
//  Строка - имя предопределенного элемента.
//
Функция ИмяПредопределенного(Знач Ссылка) Экспорт
	
	Возврат ЗначениеРеквизитаОбъекта(Ссылка, "ИмяПредопределенныхДанных");
	
КонецФункции

// Конструктор объекта ОписаниеТипов, содержащего тип Строка.
//
// Параметры:
//  ДлинаСтроки - Число.
//
// ВозвращаемоеЗначение:
//  ОписаниеТипов.
Функция ОписаниеТипаСтрока(ДлинаСтроки) Экспорт

	Массив = Новый Массив;
	Массив.Добавить(Тип("Строка"));

	КвалификаторСтроки = Новый КвалификаторыСтроки(ДлинаСтроки, ДопустимаяДлина.Переменная);

	Возврат Новый ОписаниеТипов(Массив, , КвалификаторСтроки);

КонецФункции

// Конструктор объекта ОписаниеТипов, содержащего тип Число.
//
// Параметры:
//  Разрядность - Число - общее количество разрядов числа (количество разрядов
//                        целой части плюс количество разрядов дробной части).
//  РазрядностьДробнойЧасти - Число - число разрядов дробной части.
//  ЗнакЧисла - ДопустимыйЗнак - допустимый знак числа.
//
// ВозвращаемоеЗначение:
//  ОписаниеТипов.
Функция ОписаниеТипаЧисло(Разрядность, РазрядностьДробнойЧасти = 0, ЗнакЧисла = Неопределено) Экспорт

	Если ЗнакЧисла = Неопределено Тогда
		КвалификаторЧисла = Новый КвалификаторыЧисла(Разрядность, РазрядностьДробнойЧасти);
	Иначе
		КвалификаторЧисла = Новый КвалификаторыЧисла(Разрядность, РазрядностьДробнойЧасти, ЗнакЧисла);
	КонецЕсли;

	Возврат Новый ОписаниеТипов("Число", КвалификаторЧисла);

КонецФункции

// Конструктор объекта ОписаниеТипов, содержащего тип Дата.
//
// Параметры:
//  ЧастиДаты - ЧастиДаты - набор вариантов использования значений типа Дата.
//
// ВозвращаемоеЗначение:
//  ОписаниеТипов.
Функция ОписаниеТипаДата(ЧастиДаты) Экспорт

	Массив = Новый Массив;
	Массив.Добавить(Тип("Дата"));

	КвалификаторДаты = Новый КвалификаторыДаты(ЧастиДаты);

	Возврат Новый ОписаниеТипов(Массив, , , КвалификаторДаты);

КонецФункции

// Позволяет определить, есть ли среди реквизитов объекта реквизит с переданным именем.
//
// Параметры:
//  ИмяРеквизита - Строка - имя реквизита;
//  МетаданныеОбъекта - ОбъектМетаданных - объект, в котором требуется проверить наличие реквизита.
//
// Возвращаемое значение:
//  Булево.
//
Функция ЕстьРеквизитОбъекта(ИмяРеквизита, МетаданныеОбъекта) Экспорт

	Возврат НЕ (МетаданныеОбъекта.Реквизиты.Найти(ИмяРеквизита) = Неопределено);

КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Функции определения типов объектов метаданных.

// Ссылочные типы данных

// Определяет принадлежность объекта метаданных к общему типу "Документ".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоДокумент(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.Документы.Содержит(ОбъектМетаданных);
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Справочник".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоСправочник(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.Справочники.Содержит(ОбъектМетаданных);
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Перечисление".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоПеречисление(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.Перечисления.Содержит(ОбъектМетаданных);
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "План обмена".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоПланОбмена(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.ПланыОбмена.Содержит(ОбъектМетаданных);
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "План видов характеристик".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоПланВидовХарактеристик(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.ПланыВидовХарактеристик.Содержит(ОбъектМетаданных);
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Бизнес-процесс".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоБизнесПроцесс(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.БизнесПроцессы.Содержит(ОбъектМетаданных);
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Задача".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоЗадача(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.Задачи.Содержит(ОбъектМетаданных);
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "План счетов".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоПланСчетов(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.ПланыСчетов.Содержит(ОбъектМетаданных);
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "План видов расчета".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоПланВидовРасчета(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.ПланыВидовРасчета.Содержит(ОбъектМетаданных);
	
КонецФункции

// Регистры

// Определяет принадлежность объекта метаданных к общему типу "Регистр сведений".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоРегистрСведений(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.РегистрыСведений.Содержит(ОбъектМетаданных);
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Регистр накопления".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоРегистрНакопления(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.РегистрыНакопления.Содержит(ОбъектМетаданных);
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Регистр бухгалтерии".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоРегистрБухгалтерии(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.РегистрыБухгалтерии.Содержит(ОбъектМетаданных);
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Регистр расчета".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоРегистрРасчета(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.РегистрыРасчета.Содержит(ОбъектМетаданных);
	
КонецФункции

// Константы

// Определяет принадлежность объекта метаданных к общему типу "Константа".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоКонстанта(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.Константы.Содержит(ОбъектМетаданных);
	
КонецФункции

// Журналы документов

// Определяет принадлежность объекта метаданных к общему типу "Журнал документов".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоЖурналДокументов(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.ЖурналыДокументов.Содержит(ОбъектМетаданных);
	
КонецФункции

// Последовательности

// Определяет принадлежность объекта метаданных к общему типу "Последовательности".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоПоследовательность(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.Последовательности.Содержит(ОбъектМетаданных);
	
КонецФункции

// РегламентныеЗадания

// Определяет принадлежность объекта метаданных к общему типу "Регламентные задания".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоРегламентноеЗадание(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.РегламентныеЗадания.Содержит(ОбъектМетаданных);
	
КонецФункции

// Общие

// Определяет принадлежность объекта метаданных к типу регистр.
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоРегистр(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.РегистрыБухгалтерии.Содержит(ОбъектМетаданных)
		Или Метаданные.РегистрыНакопления.Содержит(ОбъектМетаданных)
		Или Метаданные.РегистрыРасчета.Содержит(ОбъектМетаданных)
		Или Метаданные.РегистрыСведений.Содержит(ОбъектМетаданных);
		
КонецФункции

// Определяет принадлежность объекта метаданных к ссылочному типу.
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
//  Возвращаемое значение:
//   Булево.
//
Функция ЭтоОбъектСсылочногоТипа(ОбъектМетаданных) Экспорт
	
	ИмяОбъектаМетаданных = ОбъектМетаданных.ПолноеИмя();
	Позиция = СтрНайти(ИмяОбъектаМетаданных, ".");
	Если Позиция > 0 Тогда 
		ИмяБазовогоТипа = Лев(ИмяОбъектаМетаданных, Позиция - 1);
		Возврат ИмяБазовогоТипа = "Справочник"
			Или ИмяБазовогоТипа = "Документ"
			Или ИмяБазовогоТипа = "БизнесПроцесс"
			Или ИмяБазовогоТипа = "Задача"
			Или ИмяБазовогоТипа = "ПланСчетов"
			Или ИмяБазовогоТипа = "ПланОбмена"
			Или ИмяБазовогоТипа = "ПланВидовХарактеристик"
			Или ИмяБазовогоТипа = "ПланВидовРасчета";
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Имена типов.

// Возвращает значение для идентификации общего типа "Регистры сведений".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаРегистрыСведений() Экспорт
	
	Возврат "РегистрыСведений";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Регистры накопления".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаРегистрыНакопления() Экспорт
	
	Возврат "РегистрыНакопления";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Регистры бухгалтерии".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаРегистрыБухгалтерии() Экспорт
	
	Возврат "РегистрыБухгалтерии";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Регистры расчета".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаРегистрыРасчета() Экспорт
	
	Возврат "РегистрыРасчета";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Документы".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаДокументы() Экспорт
	
	Возврат "Документы";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Справочники".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаСправочники() Экспорт
	
	Возврат "Справочники";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Перечисления".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаПеречисления() Экспорт
	
	Возврат "Перечисления";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Отчеты".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаОтчеты() Экспорт
	
	Возврат "Отчеты";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Обработки".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаОбработки() Экспорт
	
	Возврат "Обработки";
	
КонецФункции

// Возвращает значение для идентификации общего типа "ПланыОбмена".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаПланыОбмена() Экспорт
	
	Возврат "ПланыОбмена";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Планы видов характеристик".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаПланыВидовХарактеристик() Экспорт
	
	Возврат "ПланыВидовХарактеристик";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Бизнес-процессы".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаБизнесПроцессы() Экспорт
	
	Возврат "БизнесПроцессы";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Задачи".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаЗадачи() Экспорт
	
	Возврат "Задачи";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Планы счетов".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаПланыСчетов() Экспорт
	
	Возврат "ПланыСчетов";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Планы видов расчета".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаПланыВидовРасчета() Экспорт
	
	Возврат "ПланыВидовРасчета";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Константы".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаКонстанты() Экспорт
	
	Возврат "Константы";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Журналы документов".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаЖурналыДокументов() Экспорт
	
	Возврат "ЖурналыДокументов";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Последовательности".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаПоследовательности() Экспорт
	
	Возврат "Последовательности";
	
КонецФункции

// Возвращает значение для идентификации общего типа "РегламентныеЗадания".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаРегламентныеЗадания() Экспорт
	
	Возврат "РегламентныеЗадания";
	
КонецФункции

// Возвращает значение для идентификации общего типа "Перерасчеты".
//
// Возвращаемое значение:
//  Строка.
//
Функция ИмяТипаПерерасчеты() Экспорт
	
	Возврат "Перерасчеты";
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Сохранение, чтение и удаление настроек из хранилищ.

// Сохраняет настройку в хранилище общих настроек.
//
// Параметры:
//   КлючОбъекта       - Строка - Ключ объекта настройки.
//   КлючНастроек      - Строка - Ключ сохраняемых настроек.
//   Значение          - Произвольный     - Настройки, которые нужно сохранить в хранилище. 
//   ОписаниеНастроек  - ОписаниеНастроек - Вспомогательная информация о настройке.
//   ИмяПользователя   - Строка - Имя пользователя, настройки которого сохраняются.
//       Если не указано, то сохраняются настройки текущего пользователя.
//   НужноОбновитьПовторноИспользуемыеЗначения - Булево - Сбросить кэши модулей ПовтИсп.
//
// См. также:
//   "СтандартноеХранилищеНастроекМенеджер.Сохранить" в синтакс-помощнике.
//
Процедура ХранилищеОбщихНастроекСохранить(КлючОбъекта, КлючНастроек, Значение,
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено, 
	НужноОбновитьПовторноИспользуемыеЗначения = Ложь) Экспорт
	
	ХранилищеСохранить(
		ХранилищеОбщихНастроек,
		КлючОбъекта,
		КлючНастроек,
		Значение,
		ОписаниеНастроек,
		ИмяПользователя,
		НужноОбновитьПовторноИспользуемыеЗначения);
	
КонецПроцедуры

// Загружает настройку из хранилища общих настроек.
//
// Параметры:
//   КлючОбъекта  - Строка - Ключ объекта настройки.
//   КлючНастроек - Строка - Ключ сохраняемых настроек.
//   ЗначениеПоУмолчанию - Произвольный - Необязательный.
//       Значение, которое необходимо подставить если настройки не были загружены.
//   ОписаниеНастроек - ОписаниеНастроек - Необязательный. При чтении значения настройки в данный параметр
//       записывается вспомогательная информация о настройке.
//   ИмяПользователя - Строка - Необязательный. Имя пользователя, настройки которого загружаются.
//       Если не указано, то загружается настройки текущего пользователя.
//
// Возвращаемое значение: 
//   Произвольный - Настройки, загруженные из хранилища.
//   Неопределено - Если настройки не найдены и параметр ЗначениеПоУмолчанию не указан.
//
// См. также:
//   "СтандартноеХранилищеНастроекМенеджер.Загрузить" в синтакс-помощнике.
//

// { RGS LFedotova 09.08.2016 18:19:27 - вопрос SLI-0006688
//Функция ХранилищеОбщихНастроекЗагрузить(КлючОбъекта, КлючНастроек, ЗначениеПоУмолчанию = Неопределено, 
//	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено) Экспорт
Функция ХранилищеОбщихНастроекЗагрузить(КлючОбъекта, КлючНастроек = Неопределено, ЗначениеПоУмолчанию = Неопределено, 
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено) Экспорт
// } RGS LFedotova 09.08.2016 18:19:48 - вопрос SLI-0006688
	
	Возврат ХранилищеЗагрузить(
		ХранилищеОбщихНастроек,
		КлючОбъекта,
		КлючНастроек,
		ЗначениеПоУмолчанию,
		ОписаниеНастроек,
		ИмяПользователя);
	
КонецФункции

// Удаляет настройку из хранилища общих настроек.
//
// Параметры:
//   КлючОбъекта  - Строка       - Ключ объекта настройки. 
//                - Неопределено - Удаляются настройки для всех объектов.
//   КлючНастроек - Строка       - Ключ сохраняемых настроек.
//                - Неопределено - Удаляются настройки со всеми ключами.
//   ИмяПользователя - Строка       - Имя пользователя, настройки которого загружается.
//                   - Неопределено - Удаляются настройки всех пользователей.
//
// См. также:
//   "СтандартноеХранилищеНастроекМенеджер.Удалить" в синтакс-помощнике.
//
Процедура ХранилищеОбщихНастроекУдалить(КлючОбъекта, КлючНастроек, ИмяПользователя) Экспорт
	
	ХранилищеУдалить(
		ХранилищеОбщихНастроек,
		КлючОбъекта,
		КлючНастроек,
		ИмяПользователя);
	
КонецПроцедуры

// Сохраняет массив пользовательских настроек МассивСтруктур. 
// Может применяться для случаев вызова с клиента.
// 
// Параметры:
//    МассивСтруктур - Массив - массив структур с полями "Объект", "Настройка", "Значение".
//    НужноОбновитьПовторноИспользуемыеЗначения - Булево - требуется обновить повторно используемые значения.
//
Процедура ХранилищеОбщихНастроекСохранитьМассив(МассивСтруктур,
	НужноОбновитьПовторноИспользуемыеЗначения = Ложь) Экспорт
	
	Если Не ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого Элемент Из МассивСтруктур Цикл
		ХранилищеОбщихНастроек.Сохранить(Элемент.Объект, КлючНастроек(Элемент.Настройка), Элемент.Значение);
	КонецЦикла;
	
	Если НужноОбновитьПовторноИспользуемыеЗначения Тогда
		ОбновитьПовторноИспользуемыеЗначения();
	КонецЕсли;
	
КонецПроцедуры

// Сохраняет массив пользовательских настроек МассивСтруктур и обновляет повторно
//   используемые значения. Может применяться для случаев вызова с клиента.
// 
// Параметры:
//    МассивСтруктур - Массив - массив структур с полями "Объект", "Настройка", "Значение".
//
Процедура ХранилищеОбщихНастроекСохранитьМассивИОбновитьПовторноИспользуемыеЗначения(МассивСтруктур) Экспорт
	
	ХранилищеОбщихНастроекСохранитьМассив(МассивСтруктур, Истина);
	
КонецПроцедуры

// Сохраняет настройку в хранилище общих настроек и обновляет повторно используемые 
//   значения.
// 
// Параметры:
//   Соответствуют методу ХранилищеОбщихНастроекСохранить.Сохранить, 
//   подробнее - см. параметры процедуры ХранилищеСохранить().
//
Процедура ХранилищеОбщихНастроекСохранитьИОбновитьПовторноИспользуемыеЗначения(КлючОбъекта, КлючНастроек, Значение) Экспорт
	
	ХранилищеОбщихНастроекСохранить(КлючОбъекта, КлючНастроек, Значение,,,Истина);
	
КонецПроцедуры

// Сохраняет настройку в хранилище системных настроек.
//
// Параметры:
//   КлючОбъекта       - Строка - Ключ объекта настройки.
//   КлючНастроек      - Строка - Ключ сохраняемых настроек.
//   Значение          - Произвольный     - Настройки, которые нужно сохранить в хранилище. 
//   ОписаниеНастроек  - ОписаниеНастроек - Вспомогательная информация о настройке.
//   ИмяПользователя   - Строка - Имя пользователя, настройки которого сохраняются.
//       Если не указано, то сохраняются настройки текущего пользователя.
//   НужноОбновитьПовторноИспользуемыеЗначения - Булево - Сбросить кэши модулей ПовтИсп.
//
// См. также:
//   "СтандартноеХранилищеНастроекМенеджер.Сохранить" в синтакс-помощнике.
//
Процедура ХранилищеСистемныхНастроекСохранить(КлючОбъекта, КлючНастроек, Значение,
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено, 
	НужноОбновитьПовторноИспользуемыеЗначения = Ложь) Экспорт
	
	ХранилищеСохранить(
		ХранилищеСистемныхНастроек, 
		КлючОбъекта, 
		КлючНастроек, 
		Значение,
		ОписаниеНастроек, 
		ИмяПользователя, 
		НужноОбновитьПовторноИспользуемыеЗначения);
	
КонецПроцедуры

// Загружает настройку из хранилища системных настроек.
//
// Параметры:
//   КлючОбъекта  - Строка - Ключ объекта настройки.
//   КлючНастроек - Строка - Ключ сохраняемых настроек.
//   ЗначениеПоУмолчанию - Произвольный - Необязательный.
//       Значение, которое необходимо подставить если настройки не были загружены.
//   ОписаниеНастроек - ОписаниеНастроек - Необязательный. При чтении значения настройки в данный параметр
//       записывается вспомогательная информация о настройке.
//   ИмяПользователя - Строка - Необязательный. Имя пользователя, настройки которого загружаются.
//       Если не указано, то загружается настройки текущего пользователя.
//
// Возвращаемое значение: 
//   Произвольный - Настройки, загруженные из хранилища.
//   Неопределено - Если настройки не найдены и параметр ЗначениеПоУмолчанию не указан.
//
// См. также:
//   "СтандартноеХранилищеНастроекМенеджер.Загрузить" в синтакс-помощнике.
//
Функция ХранилищеСистемныхНастроекЗагрузить(КлючОбъекта, КлючНастроек, ЗначениеПоУмолчанию = Неопределено, 
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено) Экспорт
	
	Возврат ХранилищеЗагрузить(
		ХранилищеСистемныхНастроек, 
		КлючОбъекта, 
		КлючНастроек, 
		ЗначениеПоУмолчанию, 
		ОписаниеНастроек, 
		ИмяПользователя);
	
КонецФункции

// Удаляет настройку из хранилища системных настроек.
//
// Параметры:
//   КлючОбъекта  - Строка       - Ключ объекта настройки. 
//                - Неопределено - Удаляются настройки для всех объектов.
//   КлючНастроек - Строка       - Ключ сохраняемых настроек.
//                - Неопределено - Удаляются настройки со всеми ключами.
//   ИмяПользователя - Строка       - Имя пользователя, настройки которого загружается.
//                   - Неопределено - Удаляются настройки всех пользователей.
//
// См. также:
//   "СтандартноеХранилищеНастроекМенеджер.Удалить" в синтакс-помощнике.
//
Процедура ХранилищеСистемныхНастроекУдалить(КлючОбъекта, КлючНастроек, ИмяПользователя) Экспорт
	
	ХранилищеУдалить(
		ХранилищеСистемныхНастроек,
		КлючОбъекта,
		КлючНастроек,
		ИмяПользователя);
	
КонецПроцедуры

// Сохраняет настройку в хранилище настроек данных форм.
//
// Параметры:
//   КлючОбъекта       - Строка - Ключ объекта настройки.
//   КлючНастроек      - Строка - Ключ сохраняемых настроек.
//   Значение          - Произвольный     - Настройки, которые нужно сохранить в хранилище. 
//   ОписаниеНастроек  - ОписаниеНастроек - Вспомогательная информация о настройке.
//   ИмяПользователя   - Строка - Имя пользователя, настройки которого сохраняются.
//       Если не указано, то сохраняются настройки текущего пользователя.
//   НужноОбновитьПовторноИспользуемыеЗначения - Булево - Сбросить кэши модулей ПовтИсп.
//
// См. также:
//   "СтандартноеХранилищеНастроекМенеджер.Сохранить" в синтакс-помощнике.
//
Процедура ХранилищеНастроекДанныхФормСохранить(КлючОбъекта, КлючНастроек, Значение,
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено, 
	НужноОбновитьПовторноИспользуемыеЗначения = Ложь) Экспорт
	
	ХранилищеСохранить(
		ХранилищеНастроекДанныхФорм, 
		КлючОбъекта, 
		КлючНастроек, 
		Значение,
		ОписаниеНастроек, 
		ИмяПользователя, 
		НужноОбновитьПовторноИспользуемыеЗначения);
	
КонецПроцедуры

// Загружает настройку из хранилища настроек данных форм.
//
// Параметры:
//   КлючОбъекта  - Строка - Ключ объекта настройки.
//   КлючНастроек - Строка - Ключ сохраняемых настроек.
//   ЗначениеПоУмолчанию - Произвольный - Необязательный.
//       Значение, которое необходимо подставить если настройки не были загружены.
//   ОписаниеНастроек - ОписаниеНастроек - Необязательный. При чтении значения настройки в данный параметр
//       записывается вспомогательная информация о настройке.
//   ИмяПользователя - Строка - Необязательный. Имя пользователя, настройки которого загружаются.
//       Если не указано, то загружается настройки текущего пользователя.
//
// Возвращаемое значение: 
//   Произвольный - Настройки, загруженные из хранилища.
//   Неопределено - Если настройки не найдены и параметр ЗначениеПоУмолчанию не указан.
//
// См. также:
//   "СтандартноеХранилищеНастроекМенеджер.Загрузить" в синтакс-помощнике.
//
Функция ХранилищеНастроекДанныхФормЗагрузить(КлючОбъекта, КлючНастроек, ЗначениеПоУмолчанию = Неопределено, 
	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено) Экспорт
	
	Возврат ХранилищеЗагрузить(
		ХранилищеНастроекДанныхФорм, 
		КлючОбъекта, 
		КлючНастроек, 
		ЗначениеПоУмолчанию, 
		ОписаниеНастроек, 
		ИмяПользователя);
	
КонецФункции

// Удаляет настройку из хранилища настроек данных форм.
//
// Параметры:
//   КлючОбъекта  - Строка       - Ключ объекта настройки. 
//                - Неопределено - Удаляются настройки для всех объектов.
//   КлючНастроек - Строка       - Ключ сохраняемых настроек.
//                - Неопределено - Удаляются настройки со всеми ключами.
//   ИмяПользователя - Строка       - Имя пользователя, настройки которого загружается.
//                   - Неопределено - Удаляются настройки всех пользователей.
//
// См. также:
//   "СтандартноеХранилищеНастроекМенеджер.Удалить" в синтакс-помощнике.
//
Процедура ХранилищеНастроекДанныхФормУдалить(КлючОбъекта, КлючНастроек, ИмяПользователя) Экспорт
	
	ХранилищеУдалить(
		ХранилищеНастроекДанныхФорм,
		КлючОбъекта,
		КлючНастроек,
		ИмяПользователя);
	
КонецПроцедуры

// Сохраняет настройку в хранилище настроек через его менеджер.
//
// Параметры:
//   МенеджерХранилища - СтандартноеХранилищеНастроекМенеджер - Хранилище, в котором сохраняется настройка.
//   КлючОбъекта       - Строка - Ключ объекта настройки.
//   КлючНастроек      - Строка - Ключ сохраняемых настроек.
//   Значение          - Произвольный     - Настройки, которые нужно сохранить в хранилище. 
//   ОписаниеНастроек  - ОписаниеНастроек - Вспомогательная информация о настройке.
//   ИмяПользователя   - Строка - Имя пользователя, настройки которого сохраняются.
//       Если не указано, то сохраняются настройки текущего пользователя.
//   НужноОбновитьПовторноИспользуемыеЗначения - Булево - Сбросить кэши модулей ПовтИсп.
//
// См. также:
//   "СтандартноеХранилищеНастроекМенеджер.Сохранить" в синтакс-помощнике.
//   "Настройки, автоматически сохраняемые в системном хранилище" в синтакс-помощнике.
//
Процедура ХранилищеСохранить(МенеджерХранилища, КлючОбъекта, КлючНастроек, Значение,
	ОписаниеНастроек, ИмяПользователя, НужноОбновитьПовторноИспользуемыеЗначения)
	
	Если НЕ ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		Возврат;
	КонецЕсли;
	
	МенеджерХранилища.Сохранить(КлючОбъекта, КлючНастроек(КлючНастроек), Значение, ОписаниеНастроек, ИмяПользователя);
	
	Если НужноОбновитьПовторноИспользуемыеЗначения Тогда
		ОбновитьПовторноИспользуемыеЗначения();
	КонецЕсли;
	
КонецПроцедуры

// Загружает настройку из хранилища настроек через его менеджер.
//
// Параметры:
//   МенеджерХранилища - СтандартноеХранилищеНастроекМенеджер - Хранилище, из которого загружается настройка.
//   КлючОбъекта  - Строка - Ключ объекта настройки.
//   КлючНастроек - Строка - Ключ сохраняемых настроек.
//   ЗначениеПоУмолчанию - Произвольный - Необязательный.
//       Значение, которое необходимо подставить если настройки не были загружены.
//   ОписаниеНастроек - ОписаниеНастроек - Необязательный. При чтении значения настройки в данный параметр
//       записывается вспомогательная информация о настройке.
//   ИмяПользователя - Строка - Необязательный. Имя пользователя, настройки которого загружаются.
//       Если не указано, то загружается настройки текущего пользователя.
//
// Возвращаемое значение: 
//   Произвольный - Настройки, загруженные из хранилища.
//   Неопределено - Если настройки не найдены и параметр ЗначениеПоУмолчанию не указан.
//
// См. также:
//   "СтандартноеХранилищеНастроекМенеджер.Загрузить" в синтакс-помощнике.
//   "Настройки, автоматически сохраняемые в системном хранилище" в синтакс-помощнике.
//
Функция ХранилищеЗагрузить(МенеджерХранилища, КлючОбъекта, КлючНастроек, ЗначениеПоУмолчанию,
	ОписаниеНастроек, ИмяПользователя)
	
	Результат = Неопределено;
	
	Если ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		Результат = МенеджерХранилища.Загрузить(КлючОбъекта, КлючНастроек(КлючНастроек), ОписаниеНастроек, ИмяПользователя);
	КонецЕсли;
	
	Если Результат = Неопределено Тогда
		Результат = ЗначениеПоУмолчанию;
	Иначе
		УстановитьПривилегированныйРежим(Истина);
		Если УдалитьБитыеСсылки(Результат) Тогда
			Результат = ЗначениеПоУмолчанию;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
КонецФункции

// Удаляет битые ссылки из переменной.
//
// Параметры:
//   СсылкаИлиКоллекция - ЛюбаяСсылка, Произвольный - Проверяемый объект или очищаемая коллекция.
//
// Возвращаемое значение: 
//   Булево - 
//       * Истина - СсылкаИлиКоллекция ссылочного типа и объект не найден в базе данных.
//       * Ложь - Когда СсылкаИлиКоллекция не ссылочного типа или объект найден в базе данных.
//
Функция УдалитьБитыеСсылки(СсылкаИлиКоллекция)
	
	Тип = ТипЗнч(СсылкаИлиКоллекция);
	
	Если Тип = Тип("Неопределено")
		Или Тип = Тип("Булево")
		Или Тип = Тип("Строка")
		Или Тип = Тип("Число")
		Или Тип = Тип("Дата") Тогда // Оптимизация - часто используемые примитивные типы.
		
		Возврат Ложь; // Не ссылка.
		
	ИначеЕсли Тип = Тип("Массив") Тогда
		
		Количество = СсылкаИлиКоллекция.Количество();
		Для Номер = 1 По Количество Цикл
			ОбратныйИндекс = Количество - Номер;
			Значение = СсылкаИлиКоллекция[ОбратныйИндекс];
			Если УдалитьБитыеСсылки(Значение) Тогда
				СсылкаИлиКоллекция.Удалить(ОбратныйИндекс);
			КонецЕсли;
		КонецЦикла;
		
		Возврат Ложь; // Не ссылка.
		
	ИначеЕсли Тип = Тип("Структура")
		Или Тип = Тип("Соответствие") Тогда
		
		Для Каждого КлючИЗначение Из СсылкаИлиКоллекция Цикл
			Значение = КлючИЗначение.Значение;
			Если УдалитьБитыеСсылки(Значение) Тогда
				СсылкаИлиКоллекция.Вставить(КлючИЗначение.Ключ, Неопределено);
			КонецЕсли;
		КонецЦикла;
		
		Возврат Ложь; // Не ссылка.
		
	ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(Тип)
		Или Справочники.ТипВсеСсылки().СодержитТип(Тип)
		Или Перечисления.ТипВсеСсылки().СодержитТип(Тип)
		Или ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(Тип)
		Или ПланыСчетов.ТипВсеСсылки().СодержитТип(Тип)
		Или ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(Тип)
		Или ПланыОбмена.ТипВсеСсылки().СодержитТип(Тип)
		Или БизнесПроцессы.ТипВсеСсылки().СодержитТип(Тип)
		Или Задачи.ТипВсеСсылки().СодержитТип(Тип) Тогда
		// Ссылочный тип, исключая ТочкаМаршрутаБизнесПроцессаСсылка.
		
		Если СсылкаИлиКоллекция.Пустая() Тогда
			Возврат Ложь; // Ссылка пустая.
		ИначеЕсли ЗначениеРеквизитаОбъекта(СсылкаИлиКоллекция, "Ссылка") = Неопределено Тогда
			СсылкаИлиКоллекция = Неопределено;
			Возврат Истина; // "Битая" ссылка.
		Иначе
			Возврат Ложь; // Объект найден.
		КонецЕсли;
		
	Иначе
		
		Возврат Ложь; // Не ссылка.
		
	КонецЕсли;
	
КонецФункции

// Удаляет настройку из хранилища настроек через его менеджер.
//
// Параметры:
//   МенеджерХранилища - СтандартноеХранилищеНастроекМенеджер - Хранилище, из которого удаляется настройка.
//   КлючОбъекта  - Строка       - Ключ объекта настройки. 
//                - Неопределено - Удаляются настройки для всех объектов.
//   КлючНастроек - Строка       - Ключ сохраняемых настроек.
//                - Неопределено - Удаляются настройки со всеми ключами.
//   ИмяПользователя - Строка       - Имя пользователя, настройки которого загружается.
//                   - Неопределено - Удаляются настройки всех пользователей.
//
// См. также:
//   "СтандартноеХранилищеНастроекМенеджер.Удалить" в синтакс-помощнике.
//   "Настройки, автоматически сохраняемые в системном хранилище" в синтакс-помощнике.
//
Процедура ХранилищеУдалить(МенеджерХранилища, КлючОбъекта, КлючНастроек, ИмяПользователя)
	
	Если ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		МенеджерХранилища.Удалить(КлючОбъекта, КлючНастроек(КлючНастроек), ИмяПользователя);
	КонецЕсли;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Функции для работы с настройкой рабочей даты.

// Сохраняет настройку рабочей даты пользователя.
//
// Параметры:
//	НоваяРабочаяДата - Дата - Дата, которую необходимо установить в качестве рабочей даты пользователя.
//	ИмяПользователя - Строка - Имя пользователя, для которого устанавливается рабочая дата.
//		Если не задано, то устанавливается для текущего пользователя.
//			
Процедура УстановитьРабочуюДатуПользователя(НоваяРабочаяДата, ИмяПользователя = Неопределено) Экспорт

	КлючОбъекта = ВРег("РабочаяДата");
	
	ХранилищеОбщихНастроекСохранить(КлючОбъекта, "", НоваяРабочаяДата, , ИмяПользователя);

КонецПроцедуры

// Возвращает значение настройки рабочей даты для пользователя.
//
// Параметры:
//	ИмяПользователя - Строка - Имя пользователя, для которого запрашивается рабочая дата.
//		Если не задано, то устанавливается для текущего пользователя.
//
// Возвращаемое значение:
//	Дата - Значение настройки рабочей даты пользователя или пустая дата, если настройка не задана.
//
Функция РабочаяДатаПользователя(ИмяПользователя = Неопределено) Экспорт

	КлючОбъекта = ВРег("РабочаяДата");

	Результат = ХранилищеОбщихНастроекЗагрузить(КлючОбъекта, "", '0001-01-01', , ИмяПользователя);
	
	Если ТипЗнч(Результат) <> Тип("Дата") Тогда
		Результат = '0001-01-01';
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Возвращает значение настройки рабочей даты для пользователя или текущей даты сеанса,
// если рабочая дата пользователя не задана.
//
// Параметры:
//	ИмяПользователя - Строка - Имя пользователя, для которого запрашивается рабочая дата.
//		Если не задано, то устанавливается для текущего пользователя.
//
// Возвращаемое значение:
//	Дата - Значение настройки рабочей даты пользователя или текущая дата сеанса, если настройка не задана.
//
Функция ТекущаяДатаПользователя(ИмяПользователя = Неопределено) Экспорт

	Результат = РабочаяДатаПользователя(ИмяПользователя);
	
	Если НЕ ЗначениеЗаполнено(Результат) Тогда
		Результат = ТекущаяДатаСеанса();
	КонецЕсли;
	
	Возврат НачалоДня(Результат);
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Функции для работы с табличными документами.

// Проверяет, умещаются ли переданные табличные документы на страницу при печати.
//
// Параметры:
//  ТабДокумент        - ТабличныйДокумент - табличный документ.
//  ВыводимыеОбласти   - Массив, ТабличныйДокумент - массив из проверяемых таблиц или табличный документ. 
//  РезультатПриОшибке - Булево - какой возвращать результат при возникновении ошибки.
//
// Возвращаемое значение:
//   Булево   - умещаются или нет переданные документы.
//
Функция ПроверитьВыводТабличногоДокумента(ТабДокумент, ВыводимыеОбласти, РезультатПриОшибке = Истина) Экспорт

	Попытка
		Возврат ТабДокумент.ПроверитьВывод(ВыводимыеОбласти);
	Исключение
		Возврат РезультатПриОшибке;
	КонецПопытки;

КонецФункции 

////////////////////////////////////////////////////////////////////////////////
// Общие процедуры и функции для работы в режиме разделения данных.

// Устанавливает монопольный доступ к информационной базе (области данных).
//
// При включенном использовании разделителей в сеансе
// начинает транзакцию и устанавливает исключительную управляемую блокировку
// на пространства блокировок всех объектов метаданных, входящих в состав разделителя ОбластьДанных.
//
// В других случаях (например, в локальном режиме работы) устанавливает монопольный режим. 
//
// Параметры:
//   ПроверитьОтсутствиеДругихСеансов - Булево - проверить отсутствие других
//          пользовательских сеансов со значением разделителя равным текущему.
//          В случае обнаружения других сеансов будет выдано исключение.
//          Параметр используется только при работе в модели сервиса.
//
Процедура ЗаблокироватьИБ(Знач ПроверитьОтсутствиеДругихСеансов = Истина) Экспорт
	
	Если НЕ ОбщегоНазначенияПовтИсп.РазделениеВключено() 
		ИЛИ НЕ ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных() Тогда
		
		Если НЕ МонопольныйРежим() Тогда
			УстановитьМонопольныйРежим(Истина);
		КонецЕсли;
	Иначе
		Если ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса") Тогда
			МодульРаботаВМоделиСервиса = ОбщийМодуль("РаботаВМоделиСервиса");
			МодульРаботаВМоделиСервиса.ЗаблокироватьТекущуюОбластьДанных(ПроверитьОтсутствиеДругихСеансов);
		Иначе
			ВызватьИсключение(ВернутьСтр("ru = 'Подсистема ""Работа в модели сервиса"" не доступна'"));
		КонецЕсли;
	КонецЕсли;
		
КонецПроцедуры

// Снимает монопольный доступ к информационной базе (области данных).
//
// При включенном использовании разделителей в сеансе,
// - если вызов делается внутри обработчика исключения (из секции Исключении...)
//   отменяет транзакцию;
// - иначе фиксирует транзакцию.
//
// В других случаях (например, в локальном режиме работы) снимает монопольный режим. 
//
Процедура РазблокироватьИБ() Экспорт
	
	Если НЕ ОбщегоНазначенияПовтИсп.РазделениеВключено() 
		ИЛИ НЕ ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных() Тогда
		
		Если МонопольныйРежим() Тогда
			УстановитьМонопольныйРежим(Ложь);
		КонецЕсли;
	Иначе
		Если ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса") Тогда
			МодульРаботаВМоделиСервиса = ОбщийМодуль("РаботаВМоделиСервиса");
			МодульРаботаВМоделиСервиса.РазблокироватьТекущуюОбластьДанных();
		Иначе
			ВызватьИсключение(ВернутьСтр("ru = 'Подсистема ""Работа в модели сервиса"" не доступна'"));
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Устанавливает разделение сеанса.
//
// Параметры:
//   Использование - Булево - Использование разделителя ОбластьДанных в сеансе.
//   ОбластьДанных - Число - Значение разделителя ОбластьДанных.
//
Процедура УстановитьРазделениеСеанса(Знач Использование, Знач ОбластьДанных = Неопределено) Экспорт
	
	ПриУстановкеРазделенияСеанса(Использование, ОбластьДанных);
	
КонецПроцедуры

// Возвращает значение разделителя текущей области данных.
// В случае если значение не установлено выдается ошибка.
// 
// Возвращаемое значение: 
//   Тип значения разделителя - значение разделителя текущей области данных. 
// 
Функция ЗначениеРазделителяСеанса() Экспорт
	
	Если НЕ ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
		Возврат 0;
	Иначе
		ЗначениеРазделителя = Неопределено;
		ПриПолученииЗначенияРазделителяСеанса(ЗначениеРазделителя);
		Возврат ЗначениеРазделителя;
	КонецЕсли;
	
КонецФункции

// Возвращает флаг использования разделителя ОбластьДанных для текущего сеанса.
// 
// Возвращаемое значение: 
//   Булево - Истина, если разделение используется.
// 
Функция ИспользованиеРазделителяСеанса() Экспорт
	
	// {изменено rg-soft
	//ИспользованиеРазделителя = Неопределено;
	//ПриПолученииИспользованияРазделителяСеанса(ИспользованиеРазделителя);
	//Возврат ИспользованиеРазделителя; 
	Возврат Ложь; // изменено rg-soft}
	
КонецФункции

// Процедура инициализации разделенной информационной базы.
// 
// Параметры:
//   ВключитьРазделение - Булево - признак включения разделения в информационной базе.
//
Процедура УстановитьПараметрыРазделенияИнформационнойБазы(Знач ВключитьРазделение = Ложь) Экспорт
	
	Если ВключитьРазделение Тогда
		Константы.ИспользоватьРазделениеПоОбластямДанных.Установить(Истина);
	Иначе
		Константы.ИспользоватьРазделениеПоОбластямДанных.Установить(Ложь);
	КонецЕсли;
	
КонецПроцедуры

// Выполняет запись значения ссылочного типа, разделенных разделителем РазделительВспомогательныхДанных
// с переключением разделения сеанса на время записи.
//
// Параметры:
//  ОбъектВспомогательныхДанных - ЛюбаяСсылка, УдалениеОбъекта - значение ссылочного типа или УдалениеОбъекта.
//
Процедура ЗаписатьВспомогательныеДанные(ОбъектВспомогательныхДанных) Экспорт
	
	Если ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса") Тогда
		МодульРаботаВМоделиСервиса = ОбщийМодуль("РаботаВМоделиСервиса");
		МодульРаботаВМоделиСервиса.ЗаписатьВспомогательныеДанные(ОбъектВспомогательныхДанных);
	Иначе
		ОбъектВспомогательныхДанных.Записать();
	КонецЕсли;
	
КонецПроцедуры

// Выполняет удаление значения ссылочного типа, разделенных разделителем РазделительВспомогательныхДанных
// с переключением разделения сеанса на время записи.
//
// Параметры:
//  ОбъектВспомогательныхДанных - ЛюбаяСсылка - значение ссылочного типа.
//
Процедура УдалитьВспомогательныеДанные(ОбъектВспомогательныхДанных) Экспорт
	
	Если ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса") Тогда
		МодульРаботаВМоделиСервиса = ОбщийМодуль("РаботаВМоделиСервиса");
		МодульРаботаВМоделиСервиса.УдалитьВспомогательныеДанные(ОбъектВспомогательныхДанных);
	Иначе
		ОбъектВспомогательныхДанных.Удалить();
	КонецЕсли;
	
КонецПроцедуры

/////////////////////////////////////////////////////////////////////////////////
// Версионирование программных интерфейсов.

// Возвращает массив номеров версий, поддерживаемых интерфейсом удаленной системы.
//
// Параметры:
//  Адрес - Строка - адрес web-сервиса версионирования интерфейсов;
//  Пользователь - Строка - имя пользователя;
//  Пароль - Строка - пароль пользователя;
//  Интерфейс - Строка - имя интерфейса.
//
// Возвращаемое значение:
//   ФиксированныйМассив - массив строк, каждая строка является представлением номера версии интерфейса. Например,
//                         "1.0.2.1".
//
// Пример использования:
//	  ПараметрыПодключения = Новый Структура;
//	  ПараметрыПодключения.Вставить("URL", "http://vsrvx/sm");
//	  ПараметрыПодключения.Вставить("UserName", "ivanov");
//	  МассивВерсий = ПолучитьВерсииИнтерфейса(ПараметрыПодключения, "СервисПередачиФайлов");
//
// Примечание: при получении версий используется кэш, время обновления которого составляет
//  одни сутки. Если для целей отладки требуется обновить значения в кэше, раньше этого 
//  времени, следует удалить из регистра сведений КэшПрограммныхИнтерфейсов соответствующие 
//  записи.
//
Функция ПолучитьВерсииИнтерфейса(Знач Адрес, Знач Пользователь, Знач Пароль = Неопределено, Знач Интерфейс = Неопределено) Экспорт
	
	Если ТипЗнч(Адрес) = Тип("Структура") Тогда
		ПараметрыПодключения = Адрес;
		ИмяИнтерфейса = Пользователь;
	Иначе
		ПараметрыПодключения = Новый Структура;
		ПараметрыПодключения.Вставить("URL", Адрес);
		ПараметрыПодключения.Вставить("UserName", Пользователь);
		ПараметрыПодключения.Вставить("Password", Пароль);
		ИмяИнтерфейса = Интерфейс;
	КонецЕсли;
	
	Если Не ПараметрыПодключения.Свойство("URL") 
		Или Не ЗначениеЗаполнено(ПараметрыПодключения.URL) Тогда
		
		ВызватьИсключение(ВернутьСтр("ru = 'Не задан URL сервиса.'"));
	КонецЕсли;
	
	ПараметрыПолучения = Новый Массив;
	ПараметрыПолучения.Добавить(ПараметрыПодключения);
	ПараметрыПолучения.Добавить(ИмяИнтерфейса);
	
	Возврат ОбщегоНазначенияПовтИсп.ДанныеКэшаВерсий(
		ИдентификаторЗаписиКэшаВерсий(ПараметрыПодключения.URL, ИмяИнтерфейса), 
		Перечисления.ТипыДанныхКэшаПрограммныхИнтерфейсов.ВерсииИнтерфейса, 
		ЗначениеВСтрокуXML(ПараметрыПолучения),
		Истина);
	
КонецФункции

// Возвращает массив номеров версий, поддерживаемых интерфейсом системы, подключенной через внешнее соединение.
//
// Параметры:
//   ВнешнееСоединение - COMОбъект - объект COM-соединение, которое используется для работы с корреспондентом.
//   ИмяИнтерфейса - Строка -.
//
// Возвращаемое значение:
//   ФиксированныйМассив - массив строк, каждая строка является представлением номера версии интерфейса. Например,
//                         "1.0.2.1".
//
// Пример использования:
//  Параметры = ...
//  ВнешнееСоединение = ОбщегоНазначения.УстановитьВнешнееСоединение(Параметры);
//  МассивВерсий = ОбщегоНазначения.ПолучитьВерсииИнтерфейсаЧерезВнешнееСоединение(ВнешнееСоединение, "ОбменДанными");
//
Функция ПолучитьВерсииИнтерфейсаЧерезВнешнееСоединение(ВнешнееСоединение, Знач ИмяИнтерфейса) Экспорт
	Попытка
		ВерсииИнтерфейсаXML = ВнешнееСоединение.СтандартныеПодсистемыСервер.ПоддерживаемыеВерсии(ИмяИнтерфейса);
	Исключение
		СтрокаСообщения = ВернутьСтр("ru = 'Корреспондент не поддерживает версионирование интерфейсов подсистем.
			|Описание ошибки: %1'");
		СтрокаСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СтрокаСообщения, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ЗаписьЖурналаРегистрации(ВернутьСтр("ru = 'Получение версий интерфейса'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Ошибка, , , СтрокаСообщения);
		
		Возврат Новый ФиксированныйМассив(Новый Массив);
	КонецПопытки;
	
	Возврат Новый ФиксированныйМассив(ЗначениеИзСтрокиXML(ВерсииИнтерфейсаXML));
КонецФункции

// Удаляет записи кэша версий содержащих в идентификаторе указанную
// подстроку. В качестве подстроки может использоваться, например,
// имя интерфейса более не используемого в конфигурации.
//
// Параметры:
//  ПодстрокаПоискаИдентификаторов - Строка - подстрока поиска 
//   идентификаторов. Строка не может содержать символов
//   %, _ и [
//
Процедура УдалитьЗаписиКэшаВерсий(Знач ПодстрокаПоискаИдентификаторов) Экспорт
	
	НачатьТранзакцию();
	
	Попытка
		
		Блокировка = Новый БлокировкаДанных;
		Блокировка.Добавить("РегистрСведений.КэшПрограммныхИнтерфейсов");
		ПодстрокаПоиска = СформироватьСтрокуДляПоискаВЗапросе(ПодстрокаПоискаИдентификаторов);

		ТекстЗапроса =
			"ВЫБРАТЬ
			|	ТаблицаКэша.Идентификатор КАК Идентификатор,
			|	ТаблицаКэша.ТипДанных КАК ТипДанных
			|ИЗ
			|	РегистрСведений.КэшПрограммныхИнтерфейсов КАК ТаблицаКэша
			|ГДЕ
			|	ТаблицаКэша.Идентификатор ПОДОБНО ""%" + ПодстрокаПоиска + "%""
			|		СПЕЦСИМВОЛ ""~""";
		
		Запрос = Новый Запрос(ТекстЗапроса);
		Результат = Запрос.Выполнить();
		Выборка = Результат.Выбрать();
		Пока Выборка.Следующий() Цикл
			
			Запись = РегистрыСведений.КэшПрограммныхИнтерфейсов.СоздатьМенеджерЗаписи();
			Запись.Идентификатор = Выборка.Идентификатор;
			Запись.ТипДанных = Выборка.ТипДанных;
			
			Запись.Удалить();
			
		КонецЦикла;
		
		ЗафиксироватьТранзакцию();
	Исключение
		
		ОтменитьТранзакцию();
		ВызватьИсключение;
		
	КонецПопытки;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для работы с хранилищем паролей.

// Записывает конфиденциальные данные в безопасное хранилище.
// Вызывающий код должен самостоятельно устанавливать привилегированный режим.
//
// Параметры:
//  Владелец - ПланОбменаСсылка, СправочникСсылка - ссылка на объект информационной базы,
//              представляющий объект-владелец сохраняемого пароля.
//              Для объектов других типов в качестве Владельца рекомендуется использовать ссылку на 
//              элемент метаданных этого типа в справочнике ИдентификаторыОбъектовМетаданных.
//              Например, Владелец = ОбщегоНазначения.ИдентификаторОбъектаМетаданных("РегистрСведений.АдресныеОбъекты");
//  Данные  - Произвольный - Данные помещаемые в безопасное хранилище. Неопределенно - удаляет данные.
//  Ключ    - Строка       - Ключ сохраняемых настроек, по умолчанию "Пароль".
//
Процедура ЗаписатьДанныеВБезопасноеХранилище(Владелец, Данные, Ключ = "Пароль") Экспорт
	
	ОбщегоНазначенияКлиентСервер.Проверить(ЗначениеЗаполнено(Владелец), 
		СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ВернутьСтр("ru = 'Недопустимое значение параметра %1 в %2. 
		|параметр должен содержать ссылку; передано значение: %3 (тип %4).'"),
			"Владелец", "ОбщегоНазначения.ЗаписатьДанныеВБезопасноеХранилище", Владелец, ТипЗнч(Владелец)));
	
	ЭтоОбластьДанных = ОбщегоНазначенияПовтИсп.РазделениеВключено() И ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных();
	Если ЭтоОбластьДанных Тогда
		БезопасноеХранилищеДанных = РегистрыСведений.БезопасноеХранилищеДанныхОбластейДанных.СоздатьМенеджерЗаписи();
	Иначе
		БезопасноеХранилищеДанных = РегистрыСведений.БезопасноеХранилищеДанных.СоздатьМенеджерЗаписи();
	КонецЕсли;
	
	Отбор = Новый Структура("Владелец", Владелец);
	БезопасноеХранилищеДанных.Владелец = Владелец;
	БезопасноеХранилищеДанных.Прочитать();
	Если Данные <> Неопределено Тогда
		Если БезопасноеХранилищеДанных.Выбран() Тогда
			ДанныеДляСохранения = БезопасноеХранилищеДанных.Данные.Получить();
			ДанныеДляСохранения.Вставить(Ключ, Данные);
			ДанныеДляХранилищеЗначения = Новый ХранилищеЗначения(ДанныеДляСохранения, Новый СжатиеДанных(6));
			БезопасноеХранилищеДанных.Данные = ДанныеДляХранилищеЗначения;
			БезопасноеХранилищеДанных.Записать();
		Иначе
			ДанныеДляСохранения = Новый Структура(Ключ, Данные);
			ДанныеДляХранилищеЗначения = Новый ХранилищеЗначения(ДанныеДляСохранения, Новый СжатиеДанных(6));
			БезопасноеХранилищеДанных.Данные = ДанныеДляХранилищеЗначения;
			БезопасноеХранилищеДанных.Владелец = Владелец;
			БезопасноеХранилищеДанных.Записать();
		КонецЕсли;
	Иначе
		БезопасноеХранилищеДанных.Удалить();
	КонецЕсли;
	
КонецПроцедуры

// Возвращает данные из безопасного хранилища.
// Вызывающий код должен самостоятельно устанавливать привилегированный режим.
//
// Параметры:
//  Владелец    -  ПланОбменаСсылка, СправочникСсылка - ссылка на объект информационной базы,
//                            представляющий объект-владелец сохраняемого пароля.
//  Ключи       - Строка - Содержит список имен сохраненных данных, указанных через запятую.
//  ОбщиеДанные - Булево - Истина, если требуется в модели сервиса получить данные из общих данных в разделенном режиме.
// 
// Возвращаемое значение:
//  Произвольный, Структура - Данные из безопасного хранилища. Если указан один ключ,
//                            то возвращается его значение, иначе структура.
//                            Если данные отсутствуют - Неопределенно.
//
Функция ПрочитатьДанныеИзБезопасногоХранилища(Владелец, Ключи = "Пароль", ОбщиеДанные = Неопределено) Экспорт
	
	ОбщегоНазначенияКлиентСервер.Проверить(ЗначениеЗаполнено(Владелец), 
		СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ВернутьСтр("ru = 'Недопустимое значение параметра %1 в %2. 
		|параметр должен содержать ссылку; передано значение: %3 (тип %4).'"),
			"Владелец", "ОбщегоНазначения.ПрочитатьДанныеИзБезопасногоХранилища", Владелец, ТипЗнч(Владелец)));
	
	Если ОбщегоНазначенияПовтИсп.РазделениеВключено()
			И ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных() Тогда
		Если ОбщиеДанные = Истина Тогда
			ИмяБезопасноеХранилищеДанных = "БезопасноеХранилищеДанных";
		Иначе
			ИмяБезопасноеХранилищеДанных = "БезопасноеХранилищеДанныхОбластейДанных";
		КонецЕсли;
	Иначе
		ИмяБезопасноеХранилищеДанных = "БезопасноеХранилищеДанных";
		
	КонецЕсли;
	Результат = ДанныеИзБезопасногоХранилища(Владелец, ИмяБезопасноеХранилищеДанных, Ключи);
	
	Если Результат <> Неопределено И Результат.Количество() = 1 Тогда
		Возврат ?(Результат.Свойство(Ключи), Результат[Ключи], Неопределено);
	КонецЕсли;
	
	Возврат Результат;

КонецФункции

// Удаляет конфиденциальные данные в безопасное хранилище.
// Вызывающий код должен самостоятельно устанавливать привилегированный режим.
//
// Параметры:
//  Владелец - ПланОбменаСсылка, СправочникСсылка - ссылка на объект информационной базы,
//                            представляющий объект-владелец сохраняемого пароля.
//  Ключи - Строка - Содержит список имен удаляемых данных, указанных через запятую. 
//                   Неопределенно - удаляет все данные.
//
Процедура УдалитьДанныеИзБезопасногоХранилища(Владелец, Ключи = Неопределено) Экспорт
	
	ОбщегоНазначенияКлиентСервер.Проверить(ЗначениеЗаполнено(Владелец), 
		СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ВернутьСтр("ru = 'Недопустимое значение параметра %1 в %2. 
		|параметр должен содержать ссылку; передано значение: %3 (тип %4).'"),
			"Владелец", "ОбщегоНазначения.УдалитьДанныеИзБезопасногоХранилища", Владелец, ТипЗнч(Владелец)));
	
	Если ОбщегоНазначенияПовтИсп.РазделениеВключено() И ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных() Тогда
		БезопасноеХранилищеДанных = РегистрыСведений.БезопасноеХранилищеДанныхОбластейДанных.СоздатьМенеджерЗаписи();
	Иначе
		БезопасноеХранилищеДанных = РегистрыСведений.БезопасноеХранилищеДанных.СоздатьМенеджерЗаписи();
	КонецЕсли;
	
	Отбор = Новый Структура("Владелец", Владелец);
	БезопасноеХранилищеДанных.Владелец = Владелец;
	БезопасноеХранилищеДанных.Прочитать();
	Если Ключи <> Неопределено Тогда
		СписокКлючей = СтрРазделить(Ключи, ",", Ложь);
		Если БезопасноеХранилищеДанных.Выбран() И СписокКлючей.Количество() > 0 Тогда
			ДанныеДляСохранения = БезопасноеХранилищеДанных.Данные.Получить();
			Для каждого КлючДляУдаления Из СписокКлючей Цикл
				Если ДанныеДляСохранения.Свойство(КлючДляУдаления) Тогда
					ДанныеДляСохранения.Удалить(КлючДляУдаления);
				КонецЕсли;
			КонецЦикла;
			ДанныеДляХранилищеЗначения = Новый ХранилищеЗначения(ДанныеДляСохранения, Новый СжатиеДанных(6));
			БезопасноеХранилищеДанных.Данные = ДанныеДляХранилищеЗначения;
			БезопасноеХранилищеДанных.Записать();
		КонецЕсли;
	Иначе
		БезопасноеХранилищеДанных.Удалить();
	КонецЕсли;

КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для вызова необязательных подсистем.

// Возвращает Истина, если "функциональная" подсистема существует в конфигурации.
// Предназначена для реализации вызова необязательной подсистемы (условного вызова).
//
// У "функциональной" подсистемы снят флажок "Включать в командный интерфейс".
//
// Параметры:
//  ПолноеИмяПодсистемы - Строка - полное имя объекта метаданных подсистема
//                        без слов "Подсистема." и с учетом регистра символов.
//                        Например: "СтандартныеПодсистемы.ВариантыОтчетов".
//
// Пример:
//
//  Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ВариантыОтчетов") Тогда
//  	МодульВариантыОтчетов = ОбщегоНазначения.ОбщийМодуль("ВариантыОтчетов");
//  	МодульВариантыОтчетов.<Имя метода>();
//  КонецЕсли;
//
// Возвращаемое значение:
//  Булево.
//
Функция ПодсистемаСуществует(ПолноеИмяПодсистемы) Экспорт
	
	ИменаПодсистем = СтандартныеПодсистемыПовтИсп.ИменаПодсистем();
	Возврат ИменаПодсистем.Получить(ПолноеИмяПодсистемы) <> Неопределено;
	
КонецФункции

// Возвращает ссылку на общий модуль по имени.
//
// Параметры:
//  Имя          - Строка - имя общего модуля, например:
//                 "ОбщегоНазначения",
//                 "ОбщегоНазначенияКлиент".
//
// Возвращаемое значение:
//  ОбщийМодуль.
//
Функция ОбщийМодуль(Имя) Экспорт
	
	Если Метаданные.ОбщиеМодули.Найти(Имя) <> Неопределено Тогда
		Модуль = РаботаВБезопасномРежиме.ВычислитьВБезопасномРежиме(Имя);
	ИначеЕсли СтрЧислоВхождений(Имя, ".") = 1 Тогда
		Возврат СерверныйМодульМенеджера(Имя);
	Иначе
		Модуль = Неопределено;
	КонецЕсли;
	
	Если ТипЗнч(Модуль) <> Тип("ОбщийМодуль") Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ВернутьСтр("ru = 'Общий модуль ""%1"" не найден.'"), Имя);
	КонецЕсли;
	
	Возврат Модуль;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для работы с буфером обмена.

// Помещает выделенные строки табличной части в буфер обмена.
//
// Параметры:
//  ТабличнаяЧасть   - ДанныеФормыКоллекция - Табличная часть, строки которой
//                                            необходимо поместить в буфер обмена.
//  ВыделенныеСтроки - Массив - Массив идентификаторов выделенных строк.
//  Источник         - Строка - Произвольный строковый идентификатор, например, имя объекта,
//                              строки табличной части которого помещаются в буфер обмена.
//
Процедура СкопироватьСтрокиВБуферОбмена(ТабличнаяЧасть, ВыделенныеСтроки, Источник = Неопределено) Экспорт
	
	Если ВыделенныеСтроки = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ТаблицаЗначений = ТабличнаяЧасть.Выгрузить();
	ТаблицаЗначений.Очистить();
	
	УдаляемыеКолонки = Новый Массив;
	УдаляемыеКолонки.Добавить("ИсходныйНомерСтроки");
	УдаляемыеКолонки.Добавить("НомерСтроки");
	
	Для Каждого ИмяКолонки Из УдаляемыеКолонки Цикл
		Колонка = ТаблицаЗначений.Колонки.Найти(ИмяКолонки);
		Если Колонка = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		ТаблицаЗначений.Колонки.Удалить(Колонка);
	КонецЦикла;
	
	Для Каждого ИдентификаторСтроки Из ВыделенныеСтроки Цикл
		КопируемаяСтрока = ТабличнаяЧасть.НайтиПоИдентификатору(ИдентификаторСтроки);
		ЗаполнитьЗначенияСвойств(ТаблицаЗначений.Добавить(), КопируемаяСтрока);
	КонецЦикла;
	
	СкопироватьВБуферОбмена(ТаблицаЗначений, Источник);
	
КонецПроцедуры

// Помещает произвольные данные в буфер обмена.
//
// Параметры:
//  Данные           - Произвольный - Данные, которые необходимо поместить в буфер обмена.
//  Источник         - Строка       - Произвольный строковый идентификатор, например, имя объекта,
//                                    строки табличной части которого помещаются в буфер обмена.
//
Процедура СкопироватьВБуферОбмена(Данные, Источник = Неопределено) Экспорт
	
	ТекущийБуферОбмена = ПараметрыСеанса.БуферОбмена;
	
	Если ЗначениеЗаполнено(ТекущийБуферОбмена.Данные) Тогда
		Адрес = ТекущийБуферОбмена.Данные;
	Иначе
		Адрес = Новый УникальныйИдентификатор;
	КонецЕсли;
	
	ДанныеВХранилище = ПоместитьВоВременноеХранилище(Данные, Адрес);
	
	СтруктураБуфераОбмена = Новый Структура;
	СтруктураБуфераОбмена.Вставить("Источник", Источник);
	СтруктураБуфераОбмена.Вставить("Данные", ДанныеВХранилище);
	
	ПараметрыСеанса.БуферОбмена = Новый ФиксированнаяСтруктура(СтруктураБуфераОбмена);
	
КонецПроцедуры

// Получает строки табличной части, помещенные в буфер обмена.
//
// Возвращаемое значение:
//  Структура - со свойствами:
//     * Данные   - Произвольный - Данные из буфера обмена. 
//                                 Например, ТаблицаЗначений при вызове СкопироватьСтрокиВБуферОбмена. 
//     * Источник - Строка       - Объект, к которому относятся данные.
//                                 Если при помещении в буфер не был указан, то Неопределено.
//
Функция СтрокиИзБуфераОбмена() Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("Источник", Неопределено);
	Результат.Вставить("Данные", Неопределено);
	
	Если ПустойБуферОбмена() Тогда
		Возврат Результат;
	КонецЕсли;
	
	ТекущийБуферОбмена = ПараметрыСеанса.БуферОбмена;
	Результат.Источник = ТекущийБуферОбмена.Источник;
	Результат.Данные = ПолучитьИзВременногоХранилища(ТекущийБуферОбмена.Данные);
	
	Возврат Результат;
КонецФункции

// Проверяет наличие сохраненных данных в буфере обмена.
//
// Параметры:
//  Источник - Строка - Если передан, то проверяется наличие данных
//             в буфере обмена с этим ключем.
//             По умолчанию - Неопределено.
// Возвращаемое значение:
//   Булево 
//
Функция ПустойБуферОбмена(Источник = Неопределено) Экспорт
	
	ТекущийБуферОбмена = ПараметрыСеанса.БуферОбмена;
	ИсточникСовпадает = Истина;
	Если Источник <> Неопределено Тогда
		ИсточникСовпадает = (Источник = ТекущийБуферОбмена.Источник);
	КонецЕсли;
	Возврат (Не ИсточникСовпадает Или Не ЗначениеЗаполнено(ТекущийБуферОбмена.Данные));
	
КонецФункции

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для обработки служебных событий.

// Возвращает обработчики указанного серверного служебного события.
//
// Параметры:
//  Событие  - Строка - например,
//             "СтандартныеПодсистемы.БазоваяФункциональность\ПриОпределенииПоддерживаемыхВерсийПрограммныхИнтерфейсов".
//
// Возвращаемое значение:
//  ФиксированныйМассив со значениями типа ФиксированнаяСтруктура со свойствами:
//    * Версия - Строка      - версия обработчика, например, "2.1.3.4". Пустая строка, если не указана.
//    * Модуль - ОбщийМодуль - серверный общий модуль.
// 
Функция ОбработчикиСлужебногоСобытия(Событие) Экспорт
	
	Возврат СтандартныеПодсистемыПовтИсп.ОбработчикиСерверногоСобытия(Событие, Истина);
	
КонецФункции

// Выгружает запрос в строку XML, которую можно вставить в Консоль запросов.
//   Для переноса запроса и всех его параметров в Консоль запросов, необходимо вызвать функцию в окне
//   «Вычислить выражение»(Shift + F9), скопировать полученный XML в поле "Текст запроса"
//   консоли запросов и выполнить команду "Заполнить из XML" из меню "Еще".
//   Подробнее об использование функции смотрите в справке к консоли запросов.
//
// Параметры:
//   Запрос - Запрос - Запрос, который необходимо выгрузить в формат строки XML.
//
// Возвращаемое значение:
//   Строка - строка в формате XML, которую можно извлечь при помощи метода "ОбщегоНазначения.ЗначениеИзСтрокиXML".
//       После извлечения получится объект типа "Структура" с полями:
//       * Текст     - Строка - Текст запроса.
//       * Параметры - Структура - Параметры запроса.
//
Функция ЗапросВСтрокуXML(Запрос) Экспорт
	Структура = Новый Структура("Текст, Параметры");
	ЗаполнитьЗначенияСвойств(Структура, Запрос);
	Возврат ЗначениеВСтрокуXML(Структура);
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Обновляет данные в кэше версий.
//
// Параметры:
//  Идентификатор      - Строка - идентификатор записи кэша.
//  ТипДанных          - ПеречислениеСсылка.ТипыДанныхКэшаПрограммныхИнтерфейсов - тип обновляемых данных.
//  ПараметрыПолучения - Массив - дополнительные параметры получения данных в кэш.
//
Процедура ОбновитьДанныеКэшаВерсий(Знач Идентификатор, Знач ТипДанных, Знач ПараметрыПолучения) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	СтруктураКлюча = Новый Структура("Идентификатор, ТипДанных", Идентификатор, ТипДанных);
	Ключ = РегистрыСведений.КэшПрограммныхИнтерфейсов.СоздатьКлючЗаписи(СтруктураКлюча);
	
	Попытка
		ЗаблокироватьДанныеДляРедактирования(Ключ);
	Исключение
		// Данные уже обновляются из другого сеанса.
		Возврат;
	КонецПопытки;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
		"ВЫБРАТЬ
		|	ТаблицаКэша.ДатаОбновления КАК ДатаОбновления,
		|	ТаблицаКэша.Данные КАК Данные,
		|	ТаблицаКэша.ТипДанных КАК ТипДанных
		|ИЗ
		|	РегистрСведений.КэшПрограммныхИнтерфейсов КАК ТаблицаКэша
		|ГДЕ
		|	ТаблицаКэша.Идентификатор = &Идентификатор
		|	И ТаблицаКэша.ТипДанных = &ТипДанных";
	Идентификатор = Идентификатор;
	Запрос.УстановитьПараметр("Идентификатор", Идентификатор);
	Запрос.УстановитьПараметр("ТипДанных", ТипДанных);
	
	НачатьТранзакцию();
	
	Попытка
		
		Блокировка = Новый БлокировкаДанных;
		ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.КэшПрограммныхИнтерфейсов");
		ЭлементБлокировки.УстановитьЗначение("Идентификатор", Идентификатор);
		ЭлементБлокировки.УстановитьЗначение("ТипДанных", ТипДанных);
		Блокировка.Заблокировать();
		
		Результат = Запрос.Выполнить();
		
		// Не удерживаем транзакцию для того, чтобы другие сеансы могли выполнять чтение данных.
		ЗафиксироватьТранзакцию();
		
	Исключение
		
		ОтменитьТранзакцию();
		РазблокироватьДанныеДляРедактирования(Ключ);
		ВызватьИсключение;
		
	КонецПопытки;
	
	Попытка	
		// Убедимся, что данные требуют обновления.
		Если Не Результат.Пустой() Тогда
			
			Выборка = Результат.Выбрать();
			Выборка.Следующий();
			Если Не ЗаписьКэшаВерсийУстарела(Выборка) Тогда
				РазблокироватьДанныеДляРедактирования(Ключ);
				Возврат;
			КонецЕсли;
			
		КонецЕсли;
		
		Набор = РегистрыСведений.КэшПрограммныхИнтерфейсов.СоздатьНаборЗаписей();
		Набор.Отбор.Идентификатор.Установить(Идентификатор);
		Набор.Отбор.ТипДанных.Установить(ТипДанных);
		
		Запись = Набор.Добавить();
		Запись.Идентификатор = Идентификатор;
		Запись.ТипДанных = ТипДанных;
		Запись.ДатаОбновления = ТекущаяУниверсальнаяДата();
		
		Набор.ДополнительныеСвойства.Вставить("ПараметрыПолучения", ПараметрыПолучения);
		Набор.ПодготовитьДанныеДляЗаписи();
		
		Набор.Записать();
		
		РазблокироватьДанныеДляРедактирования(Ключ);
		
	Исключение
		
		РазблокироватьДанныеДляРедактирования(Ключ);
		ВызватьИсключение;
		
	КонецПопытки;
	
КонецПроцедуры

// Подготавливает данные для кэша программных интерфейсов.
//
// Параметры:
//  ТипДанных          - ПеречислениеСсылка.ТипыДанныхКэшаПрограммныхИнтерфейсов - тип обновляемых данных.
//  ПараметрыПолучения - Массив - дополнительные параметры получения данных в кэш.
//
Функция ПодготовитьДанныеКэшаВерсий(Знач ТипДанных, Знач ПараметрыПолучения) Экспорт
	
	Если ТипДанных = Перечисления.ТипыДанныхКэшаПрограммныхИнтерфейсов.ВерсииИнтерфейса Тогда
		Данные = ПолучитьВерсииИнтерфейсаВКэш(ПараметрыПолучения[0], ПараметрыПолучения[1]);
	ИначеЕсли ТипДанных = Перечисления.ТипыДанныхКэшаПрограммныхИнтерфейсов.ОписаниеWebСервиса Тогда
		Данные = ПолучитьWSDL(ПараметрыПолучения[0], ПараметрыПолучения[1], ПараметрыПолучения[2], ПараметрыПолучения[3]);
	Иначе
		ШаблонТекста = ВернутьСтр("ru = 'Неизвестный тип данных кэша версий: %1'");
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонТекста, ТипДанных);
		ВызватьИсключение(ТекстСообщения);
	КонецЕсли;
	
	Возврат Данные;
	
КонецФункции

// Возвращает факт устаревания записи кэша версий.
//
// Параметры:
//  Запись - РегистрСведенийМенеджерЗаписи.КэшПрограммныхИнтерфейсов - запись, факт устаревания которой требуется
//                                                                     проверить.
//
// Возвращаемое значение:
//  Булево - признак устаревания записи.
//
Функция ЗаписьКэшаВерсийУстарела(Знач Запись) Экспорт
	
	Если Запись.ТипДанных = Перечисления.ТипыДанныхКэшаПрограммныхИнтерфейсов.ОписаниеWebСервиса Тогда
		Возврат НЕ ЗначениеЗаполнено(Запись.ДатаОбновления)
	Иначе
		Возврат Запись.ДатаОбновления + 86400 < ТекущаяУниверсальнаяДата();
	КонецЕсли;
	
КонецФункции

// Формирует идентификатор записи кэша версий из адреса сервера и имени ресурса.
//
// Параметры:
//  Адрес - Строка - адрес сервера.
//  Имя   - Строка - имя ресурса.
//
// Возвращаемое значение:
//  Строка - идентификатор записи кэша версий.
//
Функция ИдентификаторЗаписиКэшаВерсий(Знач Адрес, Знач Имя)
	
	Возврат Адрес + "|" + Имя;
	
КонецФункции

// Функция возвращает объект WSОпределения созданный с переданными параметрами.
//
// Примечание: при получении определения используется кэш, обновление которого осуществляется
//  при смене версии конфигурации. Если для целей отладки требуется обновить
//  значения в кэше, раньше этого времени, следует удалить из регистра сведений.
//  КэшПрограммныхИнтерфейсов соответствующие записи.
//
// Параметры:
//  АдресWSDL       - Строка - месторасположение wsdl.
//  ИмяПользователя - Строка - имя пользователя для входа на сервер.
//  Пароль          - Строка - пароль пользователя.
//  Таймаут         - Число  - таймаут на получение wsdl.
//
// Возвращаемое значение:
//  WSОпределения 
//
Функция WSОпределения(Знач АдресWSDL, Знач ИмяПользователя, Знач Пароль, Знач Таймаут = 10) Экспорт
	
	Если Не ПодсистемаСуществует("СтандартныеПодсистемы.ПолучениеФайловИзИнтернета") Тогда
		Возврат Новый WSОпределения(АдресWSDL, ИмяПользователя, Пароль, ,Таймаут);
	КонецЕсли;
	
	ПараметрыПолучения = Новый Массив;
	ПараметрыПолучения.Добавить(АдресWSDL);
	ПараметрыПолучения.Добавить(ИмяПользователя);
	ПараметрыПолучения.Добавить(Пароль);
	ПараметрыПолучения.Добавить(Таймаут);
	
	ДанныеWSDL = ОбщегоНазначенияПовтИсп.ДанныеКэшаВерсий(
		АдресWSDL, 
		Перечисления.ТипыДанныхКэшаПрограммныхИнтерфейсов.ОписаниеWebСервиса, 
		ЗначениеВСтрокуXML(ПараметрыПолучения),
		Ложь);
		
	ИмяФайлаWSDL = ПолучитьИмяВременногоФайла("wsdl");
	
	ДанныеWSDL.Записать(ИмяФайлаWSDL);
	
	ИнтернетПрокси = Неопределено;
	Если ПодсистемаСуществует("СтандартныеПодсистемы.ПолучениеФайловИзИнтернета") Тогда
		МодульПолучениеФайловИзИнтернетаКлиентСервер = ОбщийМодуль("ПолучениеФайловИзИнтернетаКлиентСервер");
		ИнтернетПрокси = МодульПолучениеФайловИзИнтернетаКлиентСервер.ПолучитьПрокси(АдресWSDL);
	КонецЕсли;
	Определения = Новый WSОпределения(ИмяФайлаWSDL, ИмяПользователя, Пароль, ИнтернетПрокси, Таймаут);
	
	Попытка
		УдалитьФайлы(ИмяФайлаWSDL);
	Исключение
		ЗаписьЖурналаРегистрации(ВернутьСтр("ru = 'Получение WSDL'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
	КонецПопытки;
	
	Возврат Определения;
КонецФункции

// Функция возвращает объект WSПрокси созданный с переданными параметрами.
//
// Параметры:
//  АдресWSDL           - Строка - месторасположение wsdl.
//  URIПространстваИмен - Строка - URI пространства имен web-сервиса.
//  ИмяСервиса          - Строка - имя сервиса.
//  ИмяТочкиПодключения - Строка - если не задано, образуется как <ИмяСервиса>Soap.
//  ИмяПользователя     - Строка - имя пользователя для входа на сервер.
//  Пароль              - Строка - пароль пользователя.
//  Таймаут             - Число  - таймаут на операции выполняемые через полученное прокси.
//
// Возвращаемое значение:
//  WSПрокси
//
Функция ВнутренняяWSПрокси(Знач АдресWSDL, Знач URIПространстваИмен, Знач ИмяСервиса,
	Знач ИмяТочкиПодключения, Знач ИмяПользователя, Знач Пароль, Знач Таймаут) Экспорт
	
	WSОпределения = ОбщегоНазначенияПовтИсп.WSОпределения(АдресWSDL, ИмяПользователя, Пароль);
	
	Если ПустаяСтрока(ИмяТочкиПодключения) Тогда
		ИмяТочкиПодключения = ИмяСервиса + "Soap";
	КонецЕсли;
	
	ИнтернетПрокси = Неопределено;
	Если ПодсистемаСуществует("СтандартныеПодсистемы.ПолучениеФайловИзИнтернета") Тогда
		МодульПолучениеФайловИзИнтернетаКлиентСервер = ОбщийМодуль("ПолучениеФайловИзИнтернетаКлиентСервер");
		ИнтернетПрокси = МодульПолучениеФайловИзИнтернетаКлиентСервер.ПолучитьПрокси(АдресWSDL);
	КонецЕсли;
	
	Протокол = "";
	Позиция = СтрНайти(АдресWSDL, "://");
	Если Позиция > 0 Тогда
		Протокол = НРег(Лев(АдресWSDL, Позиция - 1));
	КонецЕсли;
	
	ЗащищенноеСоединение = Неопределено;
	Если (Протокол = "https" Или Протокол = "ftps")  Тогда
		ЗащищенноеСоединение = Новый ЗащищенноеСоединениеOpenSSL;
	КонецЕсли;
	
	Прокси = Новый WSПрокси(WSОпределения, URIПространстваИмен, ИмяСервиса, ИмяТочкиПодключения, ИнтернетПрокси, Таймаут, ЗащищенноеСоединение);
	Прокси.Пользователь = ИмяПользователя;
	Прокси.Пароль       = Пароль;
	
	Возврат Прокси;
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ВСПОМОГАТЕЛЬНЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ

Функция ДанныеИзБезопасногоХранилища(Владелец, ИмяБезопасноеХранилищеДанных, Ключ)
	
	Результат = Новый Структура(Ключ);
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	БезопасноеХранилищеДанных.Данные КАК Данные
	|ИЗ
	|	РегистрСведений." + ИмяБезопасноеХранилищеДанных + " КАК БезопасноеХранилищеДанных
	|ГДЕ
	|	БезопасноеХранилищеДанных.Владелец = &Владелец";
	
	Запрос.УстановитьПараметр("Владелец", Владелец);
	РезультатЗапроса = Запрос.Выполнить().Выбрать();
	
	Если РезультатЗапроса.Следующий() Тогда
		Если ЗначениеЗаполнено(РезультатЗапроса.Данные) Тогда
			СохраненныеДанные = РезультатЗапроса.Данные.Получить();
			Если ЗначениеЗаполнено(СохраненныеДанные) Тогда
				ЗаполнитьЗначенияСвойств(Результат, СохраненныеДанные);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
КонецФункции

Процедура НоваяСтрокаКоллекцииОбъектовМетаданных(Имя, Синоним, Картинка, КартинкаОбъекта, Таб)
	
	НоваяСтрока = Таб.Добавить();
	НоваяСтрока.Имя               = Имя;
	НоваяСтрока.Синоним           = Синоним;
	НоваяСтрока.Картинка          = Картинка;
	НоваяСтрока.КартинкаОбъекта   = КартинкаОбъекта;
	
КонецПроцедуры

Функция ПолучитьВерсииИнтерфейсаВКэш(Знач ПараметрыПодключения, Знач ИмяИнтерфейса)
	
	Если Не ПараметрыПодключения.Свойство("URL") 
		Или Не ЗначениеЗаполнено(ПараметрыПодключения.URL) Тогда
		
		ВызватьИсключение(ВернутьСтр("ru = 'Не задан URL сервиса.'"));
	КонецЕсли;
	
	Если ПараметрыПодключения.Свойство("UserName")
		И ЗначениеЗаполнено(ПараметрыПодключения.UserName) Тогда
		
		ИмяПользователя = ПараметрыПодключения.UserName;
		
		Если ПараметрыПодключения.Свойство("Password") Тогда
			ПарольПользователя = ПараметрыПодключения.Password;
		Иначе
			ПарольПользователя = Неопределено;
		КонецЕсли;
		
	Иначе
		ИмяПользователя = Неопределено;
		ПарольПользователя = Неопределено;
	КонецЕсли;
	
	АдресСервиса = ПараметрыПодключения.URL + "/ws/InterfaceVersion?wsdl";
	
	ПроксиВерсионирования = WSПрокси(АдресСервиса, "http://www.1c.ru/SaaS/1.0/WS",
		"InterfaceVersion", , ИмяПользователя, ПарольПользователя, 3);
		
	МассивXDTO = ПроксиВерсионирования.GetVersions(ИмяИнтерфейса);
	Если МассивXDTO = Неопределено Тогда
		Возврат Новый ФиксированныйМассив(Новый Массив);
	Иначе	
		Сериализатор = Новый СериализаторXDTO(ПроксиВерсионирования.ФабрикаXDTO);
		Возврат Новый ФиксированныйМассив(Сериализатор.ПрочитатьXDTO(МассивXDTO));
	КонецЕсли;
	
КонецФункции

Функция ПолучитьWSDL(Знач Адрес, Знач ИмяПользователя, Знач Пароль, Знач Таймаут)
	
	ПараметрыПолучения = Новый Структура;
	Если НЕ ПустаяСтрока(ИмяПользователя) Тогда
		ПараметрыПолучения.Вставить("Пользователь", ИмяПользователя);
		ПараметрыПолучения.Вставить("Пароль", Пароль);
	КонецЕсли;
	ПараметрыПолучения.Вставить("Таймаут", Таймаут);
	
	ОписаниеФайла = Неопределено;
	
	ПриСкачиванииФайлаНаСервере(Адрес, ПараметрыПолучения, ОписаниеФайла);
	
	Если НЕ ОписаниеФайла.Статус Тогда
		ВызватьИсключение(ВернутьСтр("ru = 'Ошибка получения файла описания web-сервиса:'") + Символы.ПС + ОписаниеФайла.СообщениеОбОшибке)
	КонецЕсли;
	
	ИнтернетПрокси = Неопределено;
	Если ПодсистемаСуществует("СтандартныеПодсистемы.ПолучениеФайловИзИнтернета") Тогда
		МодульПолучениеФайловИзИнтернетаКлиентСервер = ОбщийМодуль("ПолучениеФайловИзИнтернетаКлиентСервер");
		ИнтернетПрокси = МодульПолучениеФайловИзИнтернетаКлиентСервер.ПолучитьПрокси(Адрес);
	КонецЕсли;
	Определения = Новый WSОпределения(ОписаниеФайла.Путь, ИмяПользователя, Пароль, ИнтернетПрокси, Таймаут);
	
	Если Определения.Сервисы.Количество() = 0 Тогда
		ШаблонСообщения = ВернутьСтр("ru = 'Ошибка получения файла описания web-сервиса:
			|В полученном файле не содержится ни одного описания сервиса.
			|
			|Возможно, адрес файла описания указан неверно:
			|%1'");
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, Адрес);
		ВызватьИсключение(ТекстСообщения);
	КонецЕсли;
	Определения = Неопределено;
	
	ДанныеФайла = Новый ДвоичныеДанные(ОписаниеФайла.Путь);
	
	Попытка
		УдалитьФайлы(ОписаниеФайла.Путь);
	Исключение
		ЗаписьЖурналаРегистрации(ВернутьСтр("ru = 'Получение WSDL'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
	КонецПопытки;
	
	Возврат ДанныеФайла;
	
КонецФункции

Процедура ПроверкаФиксированностиДанных(Данные, ДанныеВЗначенииФиксированныхТипов = Ложь)
	
	ТипДанных = ТипЗнч(Данные);
	
	Если ТипДанных = Тип("ХранилищеЗначения")
	 ИЛИ ТипДанных = Тип("ФиксированныйМассив")
	 ИЛИ ТипДанных = Тип("ФиксированнаяСтруктура")
	 ИЛИ ТипДанных = Тип("ФиксированноеСоответствие") Тогда
		
		Возврат;
	КонецЕсли;
	
	Если ДанныеВЗначенииФиксированныхТипов Тогда
		
		Если ТипДанных = Тип("Булево")
		 ИЛИ ТипДанных = Тип("Строка")
		 ИЛИ ТипДанных = Тип("Число")
		 ИЛИ ТипДанных = Тип("Дата")
		 ИЛИ ТипДанных = Тип("Неопределено")
		 ИЛИ ТипДанных = Тип("УникальныйИдентификатор")
		 ИЛИ ТипДанных = Тип("Null")
		 ИЛИ ТипДанных = Тип("Тип")
		 ИЛИ ТипДанных = Тип("ХранилищеЗначения")
		 ИЛИ ТипДанных = Тип("ОбщийМодуль")
		 ИЛИ ТипДанных = Тип("ОбъектМетаданных")
		 ИЛИ ТипДанных = Тип("ТипЗначенияXDTO")
		 ИЛИ ТипДанных = Тип("ТипОбъектаXDTO")
		 ИЛИ ЭтоСсылка(ТипДанных) Тогда
			
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		ВернутьСтр("ru = 'Ошибка в функции ФиксированныеДанные общего модуля ОбщегоНазначения.
		           |Данные типа ""%1"" не могут быть зафиксированы.'"),
		Строка(ТипДанных) );
	
КонецПроцедуры

Процедура ДобавитьИсключенияПоискаСсылок(Результат, МассивИсключений)
	Для Каждого ЭлементМассива Из МассивИсключений Цикл
		Если ТипЗнч(ЭлементМассива) = Тип("Строка") Тогда
			ЭлементМетаданные = Метаданные.НайтиПоПолномуИмени(ЭлементМассива);
		Иначе
			ЭлементМетаданные = ЭлементМассива;
		КонецЕсли;
		
		РодительМетаданные = ЭлементМетаданные.Родитель();
		
		// Регистрация исключаемого объекта метаданных целиком (всех ссылок, которые он может содержать).
		Если ТипЗнч(РодительМетаданные) = Тип("ОбъектМетаданныхКонфигурация") Тогда
			Результат.Вставить(ЭлементМетаданные, "*");
			Продолжить;
		КонецЕсли;
		
		// Регистрация исключаемого реквизита объекта метаданных.
		ОтносительныйПутьКРеквизиту = ЭлементМетаданные.Имя;
		РодительРодителя = РодительМетаданные.Родитель();
		Пока ТипЗнч(РодительРодителя) <> Тип("ОбъектМетаданныхКонфигурация") Цикл
			ОтносительныйПутьКРеквизиту = РодительМетаданные.Имя + "." + ОтносительныйПутьКРеквизиту;
			РодительМетаданные = РодительРодителя;
			РодительРодителя   = РодительМетаданные.Родитель();
		КонецЦикла;
		
		ПутиКРеквизитам = Результат.Получить(РодительМетаданные);
		Если ПутиКРеквизитам = "*" Тогда
			Продолжить; // - Пропуск, если весь объект метаданных уже исключен.
		ИначеЕсли ПутиКРеквизитам = Неопределено Тогда
			ПутиКРеквизитам = Новый Массив;
		КонецЕсли;
		ПутиКРеквизитам.Добавить(ОтносительныйПутьКРеквизиту);
		
		Результат.Вставить(РодительМетаданные, ПутиКРеквизитам);
	КонецЦикла;
КонецПроцедуры

// Возвращает строку ключа настроек, не превышающую допустимую длину.
// Проверяет длину строки на входе и, в случае превышения 128, преобразует ее конец по алгоритму MD5 в короткий
// вариант, в результате чего строка становится длиной 128 символов.
// Если исходная строка менее 128 символов, она возвращается в неизменном виде.
//
// Параметры:
//  Строка - Строка - строка произвольной длины.
//
Функция КлючНастроек(Знач Строка)
	Результат = Строка;
	Если СтрДлина(Строка) > 128 Тогда // Ключ более 128 символов вызовет исключение при обращении к хранилищу настроек.
		Результат = Лев(Строка, 96);
		ХешированиеДанных = Новый ХешированиеДанных(ХешФункция.MD5);
		ХешированиеДанных.Добавить(Сред(Строка, 97));
		Результат = Результат + СтрЗаменить(ХешированиеДанных.ХешСумма, " ", "");
	КонецЕсли;
	Возврат Результат;
КонецФункции

// Возвращает серверный модуль менеджера по имени объекта.
Функция СерверныйМодульМенеджера(Имя)
	ОбъектНайден = Ложь;
	
	ЧастиИмени = СтрРазделить(Имя, ".");
	Если ЧастиИмени.Количество() = 2 Тогда
		
		ИмяВида = ВРег(ЧастиИмени[0]);
		ИмяОбъекта = ЧастиИмени[1];
		
		Если ИмяВида = ВРег(ИмяТипаКонстанты()) Тогда
			Если Метаданные.Константы.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег(ИмяТипаРегистрыСведений()) Тогда
			Если Метаданные.РегистрыСведений.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег(ИмяТипаРегистрыНакопления()) Тогда
			Если Метаданные.РегистрыНакопления.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег(ИмяТипаРегистрыБухгалтерии()) Тогда
			Если Метаданные.РегистрыБухгалтерии.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег(ИмяТипаРегистрыРасчета()) Тогда
			Если Метаданные.РегистрыРасчета.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег(ИмяТипаСправочники()) Тогда
			Если Метаданные.Справочники.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег(ИмяТипаДокументы()) Тогда
			Если Метаданные.Документы.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег(ИмяТипаОтчеты()) Тогда
			Если Метаданные.Отчеты.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег(ИмяТипаОбработки()) Тогда
			Если Метаданные.Обработки.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег(ИмяТипаБизнесПроцессы()) Тогда
			Если Метаданные.БизнесПроцессы.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег(ИмяТипаЖурналыДокументов()) Тогда
			Если Метаданные.ЖурналыДокументов.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег(ИмяТипаЗадачи()) Тогда
			Если Метаданные.Задачи.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег(ИмяТипаПланыСчетов()) Тогда
			Если Метаданные.ПланыСчетов.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег(ИмяТипаПланыОбмена()) Тогда
			Если Метаданные.ПланыОбмена.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег(ИмяТипаПланыВидовХарактеристик()) Тогда
			Если Метаданные.ПланыВидовХарактеристик.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег(ИмяТипаПланыВидовРасчета()) Тогда
			Если Метаданные.ПланыВидовРасчета.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли;
	
	Если Не ОбъектНайден Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			ВернутьСтр("ru = 'Объект метаданных ""%1"" не найден,
			|либо для него не поддерживается получение модуля менеджера.'"), Имя);
	КонецЕсли;
	
	Модуль = РаботаВБезопасномРежиме.ВычислитьВБезопасномРежиме(Имя);
	
	Возврат Модуль;
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Обработчики условных вызовов в другие подсистемы.

// Получить файл из Интернета по протоколу http(s), либо ftp и сохранить его во временный файл.
//
// Параметры:
//   URL                  - Строка - url файла в формате.
//                                   [Протокол://]<Сервер>/<Путь к файлу на сервере>.
//   ПараметрыПолучения   - Структура со свойствами.
//     ПутьДляСохранения    - Строка - путь на сервере (включая имя файла), для сохранения скачанного файла.
//     Пользователь         - Строка - пользователь от имени которого установлено соединение.
//     Пароль               - Строка - пароль пользователя от которого установлено соединение.
//     Порт                 - Число  - порт сервера с которым установлено соединение.
//     ЗащищенноеСоединение - Булево - для случая http загрузки флаг указывает,
//                                     что соединение должно производиться через https.
//     ПассивноеСоединение  - Булево - для случая ftp загрузки флаг указывает,
//                                     что соединение должно пассивным (или активным).
//   ВозвращаемоеЗначение - (выходной параметр).
//     Структура, со свойствами.
//       Статус - Булево - ключ присутствует в структуре всегда, значения.
//                         Истина - вызов функции успешно завершен.
//                         Ложь   - вызов функции завершен неудачно.
//       Путь   - Строка - путь к файлу на сервере, ключ используется только
//                         если статус Истина.
//       СообщениеОбОшибке - Строка - сообщение об ошибке, если статус Ложь.
//
Процедура ПриСкачиванииФайлаНаСервере(Знач Адрес, Знач ПараметрыПолучения, ВозвращаемоеЗначение)
	
	Если ПодсистемаСуществует("СтандартныеПодсистемы.ПолучениеФайловИзИнтернета") Тогда
		МодульПолучениеФайловИзИнтернета = ОбщийМодуль("ПолучениеФайловИзИнтернета");
		ВозвращаемоеЗначение = МодульПолучениеФайловИзИнтернета.СкачатьФайлНаСервере(Адрес, ПараметрыПолучения);
	КонецЕсли;
	
КонецПроцедуры

// Устанавливает разделение сеанса.
//
// Параметры:
// Использование - Булево - Использование разделителя ОбластьДанных в сеансе.
// ОбластьДанных - Число - Значение разделителя ОбластьДанных.
//
Процедура ПриУстановкеРазделенияСеанса(Знач Использование, Знач ОбластьДанных = Неопределено)
	
	Если ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса") Тогда
		МодульРаботаВМоделиСервиса = ОбщийМодуль("РаботаВМоделиСервиса");
		МодульРаботаВМоделиСервиса.УстановитьРазделениеСеанса(Использование, ОбластьДанных);
	КонецЕсли;
	
КонецПроцедуры

// Возвращает значение разделителя текущей области данных.
// В случае если значение не установлено выдается ошибка.
// 
// Параметры:
//  ЗначениеРазделителя - Значение разделителя текущей области данных. Возвращаемый параметр.
//
Процедура ПриПолученииЗначенияРазделителяСеанса(ЗначениеРазделителя)
	
	Если ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса") Тогда
		МодульРаботаВМоделиСервиса = ОбщийМодуль("РаботаВМоделиСервиса");
		ЗначениеРазделителя = МодульРаботаВМоделиСервиса.ЗначениеРазделителяСеанса();
	Иначе
		ВызватьИсключение(ВернутьСтр("ru = 'Подсистема ""Работа в модели сервиса"" не доступна'"));
	КонецЕсли;
	
КонецПроцедуры

// Возвращает флаг использования разделителя ОбластьДанных для текущего сеанса.
// 
// Параметры:
// ИспользованиеРазделителя - Булево - Истина разделение используется, иначе нет. Возвращаемый параметр.
// 
Процедура ПриПолученииИспользованияРазделителяСеанса(ИспользованиеРазделителя)
	
	Если ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса") Тогда
		МодульРаботаВМоделиСервиса = ОбщийМодуль("РаботаВМоделиСервиса");
		ИспользованиеРазделителя = МодульРаботаВМоделиСервиса.ИспользованиеРазделителяСеанса();
	Иначе
		ВызватьИсключение(ВернутьСтр("ru = 'Подсистема ""Работа в модели сервиса"" не доступна'"));
	КонецЕсли;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ВСПОМОГАТЕЛЬНЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ Замена ссылок.

Функция ОписаниеТипаКлючиЗаписей()
	
	ДобавляемыеТипы = Новый Массив;
	Для Каждого Мета Из Метаданные.РегистрыСведений Цикл
		ДобавляемыеТипы.Добавить(Тип("РегистрСведенийКлючЗаписи." + Мета.Имя));
	КонецЦикла;
	Для Каждого Мета Из Метаданные.РегистрыНакопления Цикл
		ДобавляемыеТипы.Добавить(Тип("РегистрНакопленияКлючЗаписи." + Мета.Имя));
	КонецЦикла;
	Для Каждого Мета Из Метаданные.РегистрыБухгалтерии Цикл
		ДобавляемыеТипы.Добавить(Тип("РегистрБухгалтерииКлючЗаписи." + Мета.Имя));
	КонецЦикла;
	Для Каждого Мета Из Метаданные.РегистрыРасчета Цикл
		ДобавляемыеТипы.Добавить(Тип("РегистрРасчетаКлючЗаписи." + Мета.Имя));
	КонецЦикла;
	
	Возврат Новый ОписаниеТипов(ДобавляемыеТипы); 
КонецФункции

Функция РазметитьМестаИспользования(Знач ПараметрыВыполнения, Знач Ссылка, Знач ЦелеваяСсылка, Знач ТаблицаПоиска)
	УстановитьПривилегированныйРежим(Истина);
	
	// Устанавливаем порядок известных и проверяем наличие неопознанных объектов.
	Результат = Новый Структура;
	Результат.Вставить("МестаИспользования", ТаблицаПоиска.НайтиСтроки(Новый Структура("Ссылка", Ссылка)));
	Результат.Вставить("ОшибкиРазметки",     Новый Массив);
	Результат.Вставить("Успех",              Истина);
	
	Для Каждого МестоИспользования Из Результат.МестаИспользования Цикл
		Если МестоИспользования.ВспомогательныеДанные Тогда
			Продолжить; // Зависимые данные не обрабатываются.
		КонецЕсли;
		
		Информация = ИнформацияОТипе(МестоИспользования.Метаданные, ПараметрыВыполнения);
		Если Информация.Вид = "КОНСТАНТА" Тогда
			МестоИспользования.КлючЗамены = "Константа";
			МестоИспользования.ЦелеваяСсылка = ЦелеваяСсылка;
			
		ИначеЕсли Информация.Вид = "ПОСЛЕДОВАТЕЛЬНОСТЬ" Тогда
			МестоИспользования.КлючЗамены = "Последовательность";
			МестоИспользования.ЦелеваяСсылка = ЦелеваяСсылка;
			
		ИначеЕсли Информация.Вид = "РЕГИСТРСВЕДЕНИЙ" Тогда
			МестоИспользования.КлючЗамены = "РегистрСведений";
			МестоИспользования.ЦелеваяСсылка = ЦелеваяСсылка;
			
		ИначеЕсли Информация.Вид = "РЕГИСТРБУХГАЛТЕРИИ"
			Или Информация.Вид = "РЕГИСТРНАКОПЛЕНИЯ"
			Или Информация.Вид = "РЕГИСТРРАСЧЕТА" Тогда
			МестоИспользования.КлючЗамены = "КлючЗаписи";
			МестоИспользования.ЦелеваяСсылка = ЦелеваяСсылка;
			
		ИначеЕсли Информация.Ссылочный Тогда
			МестоИспользования.КлючЗамены = "Объект";
			МестоИспользования.ЦелеваяСсылка = ЦелеваяСсылка;
			
		Иначе
			// Неизвестный объект для замены ссылок.
			Результат.Успех = Ложь;
			Текст = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ВернутьСтр("ru = 'Замена ссылок в ""%1"" не поддерживается.'"), Информация.ПолноеИмя);
			ОписаниеОшибки = Новый Структура("Объект, Текст", МестоИспользования.Данные, Текст);
			Результат.ОшибкиРазметки.Добавить(ОписаниеОшибки);
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

Процедура ПроизвестиЗаменуВКонстанте(Результат, Знач МестоИспользования, Знач ПараметрыЗаписи, Знач ВнутренняяТранзакция = Истина)
	
	УстановитьПривилегированныйРежим(Истина);
	
	Данные = МестоИспользования.Данные;
	Мета   = МестоИспользования.Метаданные;
	
	ПредставлениеДанных = Строка(Данные);
	
	// Будем производить сразу все замены для этих данных.
	Фильтр = Новый Структура("Данные, КлючЗамены", Данные, "Константа");
	ОбрабатываемыеСтроки = МестоИспользования.Владелец().НайтиСтроки(Фильтр);
	
	СостояниеОперации = "";
	
	Если ВнутренняяТранзакция Тогда
		НачатьТранзакцию();
		
		Блокировка = Новый БлокировкаДанных;
		Блокировка.Добавить(Мета.ПолноеИмя());
	
		Попытка
			Блокировка.Заблокировать();
		Исключение
			// Добавляем запись в результат о неудачной попытке блокировке.
			Ошибка = ВернутьСтр("ru = 'Не удалось заблокировать константу %1'");
			Ошибка = СтрЗаменить(Ошибка, "%1", ПредставлениеДанных);
			
			СостояниеОперации = "ОшибкаБлокировки";
		КонецПопытки;
		
	КонецЕсли;	// Необходимость блокировки
	
	Если СостояниеОперации = "" Тогда
		Менеджер = Константы[Мета.Имя].СоздатьМенеджерЗначения();
		Менеджер.Прочитать();
		
		ЗаменаПроизведена = Истина;
		Для Каждого Строка Из ОбрабатываемыеСтроки Цикл
			Если Менеджер.Значение = Строка.Ссылка Тогда
				Менеджер.Значение = Строка.ЦелеваяСсылка;
				ЗаменаПроизведена = Истина;
			КонецЕсли;
		КонецЦикла;
		
		Если ЗаменаПроизведена Тогда
			// Пытаемся сохранить
			Если Не ПараметрыЗаписи.ПривилегированнаяЗапись Тогда
				УстановитьПривилегированныйРежим(Ложь);
			КонецЕсли;
			
			Попытка
				ЗаписатьОбъект(Менеджер, ПараметрыЗаписи);
			Исключение
				// Сохраняем причину
				Информация = ИнформацияОбОшибке();
				ЗаписьЖурналаРегистрации(СобытиеЖурналаРегистрацииЗаменыСсылок(),
					УровеньЖурналаРегистрации.Ошибка, Мета, ПодробноеПредставлениеОшибки(Информация));
				
				// Добавляем запись в результат о ошибке записи.
				ОписаниеОшибки = КраткоеПредставлениеОшибки(Информация);
				Если ПустаяСтрока(ОписаниеОшибки) Тогда
					ОписаниеОшибки = Информация.Описание;
				КонецЕсли;
				
				Ошибка = ВернутьСтр("ru = 'Не удалось записать %1 по причине: %2'");
				Ошибка = СтрЗаменить(Ошибка, "%1", ПредставлениеДанных);
				Ошибка = СтрЗаменить(Ошибка, "%2", ОписаниеОшибки);
				
				Для Каждого Строка Из ОбрабатываемыеСтроки Цикл
					ЗарегистрироватьОшибкуЗамены(Результат, Строка.Ссылка, 
						ОписаниеОшибкиЗамены("ОшибкаЗаписи", Данные, ПредставлениеДанных, Ошибка));
				КонецЦикла;
				
				СостояниеОперации = "ОшибкаЗаписи";
			КонецПопытки;
			
			Если Не ПараметрыЗаписи.ПривилегированнаяЗапись Тогда
				УстановитьПривилегированныйРежим(Истина);
			КонецЕсли;
			
		КонецЕсли;
	КонецЕсли;
	
	Если ВнутренняяТранзакция Тогда
		Если СостояниеОперации = "" Тогда
			ЗафиксироватьТранзакцию();
		Иначе
			ОтменитьТранзакцию();
		КонецЕсли;
	КонецЕсли;
	
	// Помечаем как обработанные
	Для Каждого Строка Из ОбрабатываемыеСтроки Цикл
		Строка.КлючЗамены = "";
	КонецЦикла;

КонецПроцедуры

Процедура ПроизвестиЗаменуВОбъекте(Результат, Знач МестоИспользования, Знач ПараметрыВыполнения, Знач ВнутренняяТранзакция = Истина)
	
	УстановитьПривилегированныйРежим(Истина);
	
	Данные = МестоИспользования.Данные;
	
	// Будем производить сразу все замены для этих данных.
	Фильтр = Новый Структура("Данные, КлючЗамены", Данные, "Объект");
	ОбрабатываемыеСтроки = МестоИспользования.Владелец().НайтиСтроки(Фильтр);
	
	ПредставлениеДанных = ПредметСтрокой(Данные);
	
	СостояниеОперации = "";
	
	Если ВнутренняяТранзакция Тогда
		НачатьТранзакцию();
		
		Блокировка = Новый БлокировкаДанных;
		ЗаблокироватьМестоИспользования(ПараметрыВыполнения, Блокировка, МестоИспользования);
		
		ИнформацияОбОшибке = Неопределено;
		Попытка
			Блокировка.Заблокировать();
		Исключение
			ИнформацияОбОшибке = ИнформацияОбОшибке();
		КонецПопытки;
		Если ИнформацияОбОшибке <> Неопределено Тогда
			СостояниеОперации = "ОшибкаБлокировки";
			ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				ВернутьСтр("ru = 'Не удалось заблокировать объект ""%1"":
				|%2'"),
				ПредставлениеДанных,
				СтандартныеПодсистемыКлиентСервер.ИсходнаяПричинаОшибки(ИнформацияОбОшибке));
			ОписаниеОшибки = ОписаниеОшибкиЗамены("ОшибкаБлокировки", Данные, ПредставлениеДанных, ТекстОшибки);
			ЗарегистрироватьОшибкуЗамены(Результат, МестоИспользования.Ссылка, ОписаниеОшибки);
			Для Каждого Строка Из ОбрабатываемыеСтроки Цикл
				ЗарегистрироватьОшибкуЗамены(Результат, Строка.Ссылка, ОписаниеОшибки);
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
	Если СостояниеОперации = "" Тогда
		ОбъектыЗаписи = ИзмененныеОбъектыПриЗаменеВОбъекте(ПараметрыВыполнения, МестоИспользования, ОбрабатываемыеСтроки);
		
		// Пытаемся сохранить, сам объект идет последним.
		Если Не ПараметрыВыполнения.ПривилегированнаяЗапись Тогда
			УстановитьПривилегированныйРежим(Ложь);
		КонецЕсли;
		
		Попытка
			Если ПараметрыВыполнения.ВключатьБизнесЛогику Тогда
				// Первая запись без контроля, чтобы устранить циклические ссылки.
				НовыеПараметрыВыполнения = ОбщегоНазначенияКлиентСервер.СкопироватьСтруктуру(ПараметрыВыполнения);
				НовыеПараметрыВыполнения.ВключатьБизнесЛогику = Ложь;
				Для Каждого КлючЗначение Из ОбъектыЗаписи Цикл
					ЗаписатьОбъект(КлючЗначение.Ключ, НовыеПараметрыВыполнения);
				КонецЦикла;
				// Вторая запись c контролем.
				НовыеПараметрыВыполнения.ВключатьБизнесЛогику = Истина;
				Для Каждого КлючЗначение Из ОбъектыЗаписи Цикл
					ЗаписатьОбъект(КлючЗначение.Ключ, НовыеПараметрыВыполнения);
				КонецЦикла;
			Иначе
				// Запись без контроля бизнес-логики.
				Для Каждого КлючЗначение Из ОбъектыЗаписи Цикл
					ЗаписатьОбъект(КлючЗначение.Ключ, ПараметрыВыполнения);
				КонецЦикла;
			КонецЕсли;
		Исключение
			// Сохраняем причину
			Информация = ИнформацияОбОшибке();
			ЗаписьЖурналаРегистрации(
				СобытиеЖурналаРегистрацииЗаменыСсылок(),
				УровеньЖурналаРегистрации.Ошибка,
				МестоИспользования.Метаданные,
				ПодробноеПредставлениеОшибки(Информация));
			
			ОписаниеОшибки = КраткоеПредставлениеОшибки(Информация);
			Если ПустаяСтрока(ОписаниеОшибки) Тогда
				ОписаниеОшибки = Информация.Описание;
			КонецЕсли;
			
			// Добавляем запись в результат о ошибке записи.
			Ошибка = ВернутьСтр("ru = 'Не удалось записать %1 по причине: %2'");
			Ошибка = СтрЗаменить(Ошибка, "%1", ПредставлениеДанных);
			Ошибка = СтрЗаменить(Ошибка, "%2", ОписаниеОшибки);
			
			Для Каждого Строка Из ОбрабатываемыеСтроки Цикл
				ЗарегистрироватьОшибкуЗамены(Результат, Строка.Ссылка, 
					ОписаниеОшибкиЗамены("ОшибкаЗаписи", Данные, ПредставлениеДанных, Ошибка));
			КонецЦикла;
			
			СостояниеОперации = "ОшибкаЗаписи";
		КонецПопытки;
		
		Если Не ПараметрыВыполнения.ПривилегированнаяЗапись Тогда
			УстановитьПривилегированныйРежим(Истина);
		КонецЕсли;
		
		// Удаляем обработанные движения и последовательности из таблицы поиска.
	КонецЕсли;
	
	Если ВнутренняяТранзакция Тогда
		Если СостояниеОперации = "" Тогда
			ЗафиксироватьТранзакцию();
		Иначе
			ОтменитьТранзакцию();
		КонецЕсли;
	КонецЕсли;
	
	// Помечаем как обработанные
	Для Каждого Строка Из ОбрабатываемыеСтроки Цикл
		Строка.КлючЗамены = "";
	КонецЦикла;
	
КонецПроцедуры

Процедура ПроизвестиЗаменуВНаборе(Результат, Знач МестоИспользования, Знач ПараметрыВыполнения, Знач ВнутренняяТранзакция = Истина)
	УстановитьПривилегированныйРежим(Истина);
	
	Данные = МестоИспользования.Данные;
	Мета   = МестоИспользования.Метаданные;
	
	ПредставлениеДанных = Строка(Данные);
	
	// Будем производить сразу все замены для этих данных.
	Фильтр = Новый Структура("Данные, КлючЗамены");
	ЗаполнитьЗначенияСвойств(Фильтр, МестоИспользования);
	ОбрабатываемыеСтроки = МестоИспользования.Владелец().НайтиСтроки(Фильтр);
	
	ОписаниеНабора = ОписаниеКлючаЗаписи(Мета);
	НаборЗаписей = ОписаниеНабора.НаборЗаписей;
	
	ПарыЗамен = Новый Соответствие;
	Для Каждого Строка Из ОбрабатываемыеСтроки Цикл
		ПарыЗамен.Вставить(Строка.Ссылка, Строка.ЦелеваяСсылка);
	КонецЦикла;
	
	СостояниеОперации = "";
	
	Если ВнутренняяТранзакция Тогда
		НачатьТранзакцию();
		
		// Блокировка и подготовка набора.
		Блокировка = Новый БлокировкаДанных;
		Для Каждого КлючЗначение Из ОписаниеНабора.СписокИзмерений Цикл
			ТипИзмерения = КлючЗначение.Значение;
			Имя          = КлючЗначение.Ключ;
			Значение     = Данные[Имя];
			
			Для Каждого Строка Из ОбрабатываемыеСтроки Цикл
				ТекущаяСсылка = Строка.Ссылка;
				Если ТипИзмерения.СодержитТип(ТипЗнч(ТекущаяСсылка)) Тогда
					Блокировка.Добавить(ОписаниеНабора.ПространствоБлокировки).УстановитьЗначение(Имя, ТекущаяСсылка);
				КонецЕсли;
			КонецЦикла;
			
			НаборЗаписей.Отбор[Имя].Установить(Значение);
		КонецЦикла;
		
		Попытка
			Блокировка.Заблокировать();
		Исключение
			// Добавляем запись в результат о неудачной попытке блокировке.
			Ошибка = ВернутьСтр("ru = 'Не удалось заблокировать набор  %1'");
			Ошибка = СтрЗаменить(Ошибка, "%1", ПредставлениеДанных);
			
			СостояниеОперации = "ОшибкаБлокировки";
		КонецПопытки;
		
	КонецЕсли;	// Необходимость блокировки
		
	Если СостояниеОперации = "" Тогда
		НаборЗаписей.Прочитать();
		ЗаменитьВКоллекцииСтрок("НаборЗаписей", "НаборЗаписей", НаборЗаписей, НаборЗаписей, ОписаниеНабора.СписокПолей, ПарыЗамен);
		
		Если НаборЗаписей.Модифицированность() Тогда
			// Пытаемся сохранить
			Если Не ПараметрыВыполнения.ПривилегированнаяЗапись Тогда
				УстановитьПривилегированныйРежим(Ложь);
			КонецЕсли;
			
			Попытка
				ЗаписатьОбъект(НаборЗаписей, ПараметрыВыполнения);
			Исключение
				// Сохраняем причину
				Информация = ИнформацияОбОшибке();
				ЗаписьЖурналаРегистрации(СобытиеЖурналаРегистрацииЗаменыСсылок(),
					УровеньЖурналаРегистрации.Ошибка, Мета, ПодробноеПредставлениеОшибки(Информация));
					
				ОписаниеОшибки = КраткоеПредставлениеОшибки(Информация);
				Если ПустаяСтрока(ОписаниеОшибки) Тогда
					ОписаниеОшибки = Информация.Описание;
				КонецЕсли;
				
				// Добавляем запись в результат о ошибке записи.
				Ошибка = ВернутьСтр("ru = 'Не удалось записать %1 по причине: %2'");
				Ошибка = СтрЗаменить(Ошибка, "%1", ПредставлениеДанных);
				Ошибка = СтрЗаменить(Ошибка, "%2", ОписаниеОшибки);
				
				Для Каждого Строка Из ОбрабатываемыеСтроки Цикл
					ЗарегистрироватьОшибкуЗамены(Результат, Строка.Ссылка, 
						ОписаниеОшибкиЗамены("ОшибкаЗаписи", Данные, ПредставлениеДанных, Ошибка));
				КонецЦикла;
				
				СостояниеОперации = "ОшибкаЗаписи";
			КонецПопытки;
			
			Если Не ПараметрыВыполнения.ПривилегированнаяЗапись Тогда
				УстановитьПривилегированныйРежим(Истина);
			КонецЕсли;
			
		КонецЕсли;
	КонецЕсли;
	
	Если ВнутренняяТранзакция Тогда
		Если СостояниеОперации = "" Тогда
			ЗафиксироватьТранзакцию();
		Иначе
			ОтменитьТранзакцию();
		КонецЕсли;
	КонецЕсли;
	
	// Помечаем как обработанные
	Для Каждого Строка Из ОбрабатываемыеСтроки Цикл
		Строка.КлючЗамены = "";
	КонецЦикла;
	
КонецПроцедуры

Процедура ПроизвестиЗаменуВРегистреСведений(Результат, Знач МестоИспользования, Знач ПараметрыВыполнения, Знач ВнутренняяТранзакция = Истина)
	Если МестоИспользования.Обработано Тогда
		Возврат;
	КонецЕсли;
	МестоИспользования.Обработано = Истина;
	
	// В случае, если дубль указан в измерениях набора, тогда используется 2 набора записей:
	//     НаборЗаписейДубля - чтение старых значений (по старым измерениям) и удаление старых значений.
	//     НаборЗаписейОригинала - чтение актуальных значений (по новым измерениям) и запись новых значений.
	//     Данные дублей и оригиналов объединяются по правилам:
	//         Приоритет у данных оригинала.
	//         Если в оригинале нет данных, то берутся данные из дубля.
	//     Набор оригинала записывается, а набор дубля удаляется.
	//
	// В случае, если дубль не указан в измерениях набора, тогда используется 1 набор записей:
	//     НаборЗаписейДубля - чтение старых значений и запись новых значений.
	//
	// Замена ссылок в ресурсах и реквизитах производится в обоих случаях.
	
	УстановитьПривилегированныйРежим(Истина);
	
	Дубль    = МестоИспользования.Ссылка;
	Оригинал = МестоИспользования.ЦелеваяСсылка;
	
	МетаданныеРегистра = МестоИспользования.Метаданные;
	КлючЗаписиРегистра = МестоИспользования.Данные;
	
	Информация = ИнформацияОТипе(МетаданныеРегистра, ПараметрыВыполнения);
	
	ТребуетсяДваНабора = Ложь;
	Для Каждого КлючЗначение Из Информация.Измерения Цикл
		ЗначениеИзмеренияДубля = КлючЗаписиРегистра[КлючЗначение.Ключ];
		Если ЗначениеИзмеренияДубля = Дубль
			Или ПараметрыВыполнения.УспешныеЗамены[ЗначениеИзмеренияДубля] = Дубль Тогда
			ТребуетсяДваНабора = Истина; // Дубль указан в измерениях.
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Менеджер = МенеджерОбъектаПоПолномуИмени(Информация.ПолноеИмя);
	НаборЗаписейДубля = Менеджер.СоздатьНаборЗаписей();
	
	Если ТребуетсяДваНабора Тогда
		ЗначенияИзмеренийОригинала = Новый Структура;
		НаборЗаписейОригинала = Менеджер.СоздатьНаборЗаписей();
	КонецЕсли;
	
	Если ВнутренняяТранзакция Тогда
		НачатьТранзакцию();
		Блокировка = Новый БлокировкаДанных;
		БлокировкаДубля = Блокировка.Добавить(Информация.ПолноеИмя);
		Если ТребуетсяДваНабора Тогда
			БлокировкаОригинала = Блокировка.Добавить(Информация.ПолноеИмя);
		КонецЕсли;
	КонецЕсли;
	
	Для Каждого КлючЗначение Из Информация.Измерения Цикл
		ЗначениеИзмеренияДубля = КлючЗаписиРегистра[КлючЗначение.Ключ];
		
		// Для решения проблемы уникальности
		//   выполняется замена старых значений измерений ключа записи на актуальные.
		//   Соответствие старых и актуальных обеспечивает соответствием УспешныеЗамены.
		//   Данные соответствия актуальны на текущий момент времени,
		//   т.к. пополняются только после успешной обработки очередной пары и фиксации транзакции.
		НовоеЗначениеИзмеренияДубля = ПараметрыВыполнения.УспешныеЗамены[ЗначениеИзмеренияДубля];
		Если НовоеЗначениеИзмеренияДубля <> Неопределено Тогда
			ЗначениеИзмеренияДубля = НовоеЗначениеИзмеренияДубля;
		КонецЕсли;
		
		НаборЗаписейДубля.Отбор[КлючЗначение.Ключ].Установить(ЗначениеИзмеренияДубля);
		
		Если ВнутренняяТранзакция Тогда // Замена в конкретной паре и блокировка на конкретную замену
			БлокировкаДубля.УстановитьЗначение(КлючЗначение.Ключ, ЗначениеИзмеренияДубля);
		КонецЕсли;
		
		Если ТребуетсяДваНабора Тогда
			Если ЗначениеИзмеренияДубля = Дубль Тогда
				ЗначениеИзмеренияОригинала = Оригинал;
			Иначе
				ЗначениеИзмеренияОригинала = ЗначениеИзмеренияДубля;
			КонецЕсли;
			
			НаборЗаписейОригинала.Отбор[КлючЗначение.Ключ].Установить(ЗначениеИзмеренияОригинала);
			ЗначенияИзмеренийОригинала.Вставить(КлючЗначение.Ключ, ЗначениеИзмеренияОригинала);
			
			Если ВнутренняяТранзакция Тогда // Замена в конкретной паре и блокировка на конкретную замену
				БлокировкаОригинала.УстановитьЗначение(КлючЗначение.Ключ, ЗначениеИзмеренияОригинала);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	// Установка блокировки.
	Если ВнутренняяТранзакция Тогда
		ИнформацияОбОшибке = Неопределено;
		Попытка
			Блокировка.Заблокировать();
		Исключение
			ИнформацияОбОшибке = ИнформацияОбОшибке();
		КонецПопытки;
		Если ИнформацияОбОшибке <> Неопределено Тогда
			ЗарегистрироватьОшибкуВТаблицу(Результат, Дубль, Оригинал, КлючЗаписиРегистра, Информация, "БлокировкаДляРегистра", ИнформацияОбОшибке);
			ОтменитьТранзакцию();
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	// Откуда читаем?
	НаборЗаписейДубля.Прочитать();
	Если НаборЗаписейДубля.Количество() = 0 Тогда // Нечего писать.
		Если ВнутренняяТранзакция Тогда
			ОтменитьТранзакцию(); // Замена не требуется.
		КонецЕсли;
		Возврат;
	КонецЕсли;
	ЗаписьДубля = НаборЗаписейДубля[0];
	
	// Куда пишем?
	ЗаписьОригиналаЭтоНовый = Ложь;
	Если ТребуетсяДваНабора Тогда
		// Пишем в набор с другими измерениями.
		НаборЗаписейОригинала.Прочитать();
		Если НаборЗаписейОригинала.Количество() = 0 Тогда
			ЗаписьОригиналаЭтоНовый = Истина;
			ЗаписьОригинала = НаборЗаписейОригинала.Добавить();
			ЗаполнитьЗначенияСвойств(ЗаписьОригинала, ЗаписьДубля);
			ЗаполнитьЗначенияСвойств(ЗаписьОригинала, ЗначенияИзмеренийОригинала);
		Иначе
			ЗаписьОригинала = НаборЗаписейОригинала[0];
		КонецЕсли;
	Иначе
		// Пишем туда-же, откуда и читаем.
		НаборЗаписейОригинала = НаборЗаписейДубля;
		ЗаписьОригинала = ЗаписьДубля; // Ситуация с нулевым количеством записей в наборе обработана выше.
	КонецЕсли;
	
	// Замена дубля на оригинал в ресурсах и реквизитах.
	Для Каждого КлючЗначение Из Информация.Ресурсы Цикл
		ЗначениеРеквизитаВОригинале = ЗаписьОригинала[КлючЗначение.Ключ];
		Если ЗначениеРеквизитаВОригинале = Дубль Тогда
			ЗаписьОригинала[КлючЗначение.Ключ] = Оригинал;
			Модифицированность = Истина;
		КонецЕсли;
	КонецЦикла;
	Для Каждого КлючЗначение Из Информация.Реквизиты Цикл
		ЗначениеРеквизитаВОригинале = ЗаписьОригинала[КлючЗначение.Ключ];
		Если ЗначениеРеквизитаВОригинале = Дубль Тогда
			ЗаписьОригинала[КлючЗначение.Ключ] = Оригинал;
			Модифицированность = Истина;
		КонецЕсли;
	КонецЦикла;
	
	Если Не ПараметрыВыполнения.ПривилегированнаяЗапись Тогда
		УстановитьПривилегированныйРежим(Ложь);
	КонецЕсли;
	
	ЕстьЧтоФиксировать = Ложь;
	
	// Удаление данных дубля.
	Если ТребуетсяДваНабора Тогда
		НаборЗаписейДубля.Очистить();
		ИнформацияОбОшибке = Неопределено;
		Попытка
			ЗаписатьОбъект(НаборЗаписейДубля, ПараметрыВыполнения);
			ЕстьЧтоФиксировать = Истина;
		Исключение
			ИнформацияОбОшибке = ИнформацияОбОшибке();
		КонецПопытки;
		Если ИнформацияОбОшибке <> Неопределено Тогда
			ЗарегистрироватьОшибкуВТаблицу(Результат, Дубль, Оригинал, КлючЗаписиРегистра, Информация, "УдалитьНаборДубля", ИнформацияОбОшибке);
		КонецЕсли;
	КонецЕсли;
	
	// Запись данных оригинала.
	Если НаборЗаписейОригинала.Модифицированность() Тогда
		ИнформацияОбОшибке = Неопределено;
		Попытка
			ЗаписатьОбъект(НаборЗаписейОригинала, ПараметрыВыполнения);
			ЕстьЧтоФиксировать = Истина;
		Исключение
			ИнформацияОбОшибке = ИнформацияОбОшибке();
		КонецПопытки;
		Если ИнформацияОбОшибке <> Неопределено Тогда
			ЗарегистрироватьОшибкуВТаблицу(Результат, Дубль, Оригинал, КлючЗаписиРегистра, Информация, "ЗаписатьНаборОригинала", ИнформацияОбОшибке);
		КонецЕсли;
	КонецЕсли;
	
	Если ВнутренняяТранзакция Тогда
		Если ЕстьЧтоФиксировать Тогда
			ЗафиксироватьТранзакцию();
		Иначе
			ОтменитьТранзакцию();
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

Функция ИзмененныеОбъектыПриЗаменеВОбъекте(ПараметрыВыполнения, МестоИспользования, ОбрабатываемыеСтроки)
	Данные = МестоИспользования.Данные;
	ОписаниеПоследовательностей = ОписаниеПоследовательностей(МестоИспользования.Метаданные);
	ОписаниеДвижений            = ОписаниеДвижений(МестоИспользования.Метаданные);
	
	УстановитьПривилегированныйРежим(Истина);
	
	// Возвращаем измененные обработанные объекты.
	Измененные = Новый Соответствие;
	
	// Считываем
	Описание = ОписаниеОбъекта(Данные.Метаданные());
	Попытка
		Объект = Данные.ПолучитьОбъект();
	Исключение
		// Был уже обработан с ошибками.
		Объект = Неопределено;
	КонецПопытки;
	
	Если Объект = Неопределено Тогда
		Возврат Измененные;
	КонецЕсли;
	
	Для Каждого ОписаниеДвижения Из ОписаниеДвижений Цикл
		ОписаниеДвижения.НаборЗаписей.Отбор.Регистратор.Установить(Данные);
		ОписаниеДвижения.НаборЗаписей.Прочитать();
	КонецЦикла;
	
	Для Каждого ОписаниеПоследовательности Из ОписаниеПоследовательностей Цикл
		ОписаниеПоследовательности.НаборЗаписей.Отбор.Регистратор.Установить(Данные);
		ОписаниеПоследовательности.НаборЗаписей.Прочитать();
	КонецЦикла;
	
	// Заменяем сразу все варианты.
	ПарыЗамен = Новый Соответствие;
	Для Каждого МестоИспользования Из ОбрабатываемыеСтроки Цикл
		ПарыЗамен.Вставить(МестоИспользования.Ссылка, МестоИспользования.ЦелеваяСсылка);
	КонецЦикла;
	
	// Реквизиты
	Для Каждого КлючЗначение Из Описание.Реквизиты Цикл
		Имя = КлючЗначение.Ключ;
		ЦелеваяСсылка = ПарыЗамен[ Объект[Имя] ];
		Если ЦелеваяСсылка <> Неопределено Тогда
			ЗарегистрироватьФактЗамены(Объект, Объект[Имя], ЦелеваяСсылка, "Реквизиты", Имя);
			Объект[Имя] = ЦелеваяСсылка;
		КонецЕсли;
	КонецЦикла;
	
	// Стандартные реквизиты
	Для Каждого КлючЗначение Из Описание.СтандартныеРеквизиты Цикл
		Имя = КлючЗначение.Ключ;
		ЦелеваяСсылка = ПарыЗамен[ Объект[Имя] ];
		Если ЦелеваяСсылка <> Неопределено Тогда
			ЗарегистрироватьФактЗамены(Объект, Объект[Имя], ЦелеваяСсылка, "СтандартныеРеквизиты", Имя);
			Объект[Имя] = ЦелеваяСсылка;
		КонецЕсли;
	КонецЦикла;
		
	// Табличные части
	Для Каждого Элемент Из Описание.ТабличныеЧасти Цикл
		ЗаменитьВКоллекцииСтрок(
			"ТабличныеЧасти",
			Элемент.Имя,
			Объект,
			Объект[Элемент.Имя],
			Элемент.СписокПолей,
			ПарыЗамен);
	КонецЦикла;
	
	// Стандартные табличные части.
	Для Каждого Элемент Из Описание.СтандартныеТабличныеЧасти Цикл
		ЗаменитьВКоллекцииСтрок(
			"СтандартныеТабличныеЧасти",
			Элемент.Имя,
			Объект,
			Объект[Элемент.Имя],
			Элемент.СписокПолей,
			ПарыЗамен);
	КонецЦикла;
		
	// Движения
	Для Каждого ОписаниеДвижения Из ОписаниеДвижений Цикл
		ЗаменитьВКоллекцииСтрок(
			"Движения",
			ОписаниеДвижения.ПространствоБлокировки,
			ОписаниеДвижения.НаборЗаписей,
			ОписаниеДвижения.НаборЗаписей,
			ОписаниеДвижения.СписокПолей,
			ПарыЗамен);
	КонецЦикла;
	
	// Последовательности
	Для Каждого ОписаниеПоследовательности Из ОписаниеПоследовательностей Цикл
		ЗаменитьВКоллекцииСтрок(
			"Последовательности",
			ОписаниеПоследовательности.ПространствоБлокировки,
			ОписаниеПоследовательности.НаборЗаписей,
			ОписаниеПоследовательности.НаборЗаписей,
			ОписаниеПоследовательности.СписокПолей,
			ПарыЗамен);
	КонецЦикла;
	
	Для Каждого ОписаниеДвижения Из ОписаниеДвижений Цикл
		Если ОписаниеДвижения.НаборЗаписей.Модифицированность() Тогда
			Измененные.Вставить(ОписаниеДвижения.НаборЗаписей, Ложь);
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого ОписаниеПоследовательности Из ОписаниеПоследовательностей Цикл
		Если ОписаниеПоследовательности.НаборЗаписей.Модифицированность() Тогда
			Измененные.Вставить(ОписаниеПоследовательности.НаборЗаписей, Ложь);
		КонецЕсли;
	КонецЦикла;
	
	// Сам объект последний - для возможного перепроведения.
	Если Объект.Модифицированность() Тогда
		Измененные.Вставить(Объект, Описание.МожетБытьПроведен);
	КонецЕсли;
	
	Возврат Измененные;
КонецФункции

Процедура ЗарегистрироватьФактЗамены(Объект, СсылкаДубля, СсылкаОригинала, ВидРеквизита, ИмяРеквизита, Индекс = Неопределено, ИмяКолонки = Неопределено)
	Структура = Новый Структура("ДополнительныеСвойства");
	ЗаполнитьЗначенияСвойств(Структура, Объект);
	Если ТипЗнч(Структура.ДополнительныеСвойства) <> Тип("Структура") Тогда
		Возврат;
	КонецЕсли;
	ДопСвойства = Объект.ДополнительныеСвойства;
	ДопСвойства.Вставить("ЗаменаСсылок", Истина);
	ВыполненныеЗамены = ОбщегоНазначенияКлиентСервер.СвойствоСтруктуры(ДопСвойства, "ВыполненныеЗамены");
	Если ВыполненныеЗамены = Неопределено Тогда
		ВыполненныеЗамены = Новый Массив;
		ДопСвойства.Вставить("ВыполненныеЗамены", ВыполненныеЗамены);
	КонецЕсли;
	ОписаниеЗамены = Новый Структура;
	ОписаниеЗамены.Вставить("СсылкаДубля", СсылкаДубля);
	ОписаниеЗамены.Вставить("СсылкаОригинала", СсылкаОригинала);
	ОписаниеЗамены.Вставить("ВидРеквизита", ВидРеквизита);
	ОписаниеЗамены.Вставить("ИмяРеквизита", ИмяРеквизита);
	ОписаниеЗамены.Вставить("Индекс", Индекс);
	ОписаниеЗамены.Вставить("ИмяКолонки", ИмяКолонки);
	ВыполненныеЗамены.Добавить(ОписаниеЗамены);
КонецПроцедуры

Процедура УдалитьСсылкиПометкой(Результат, Знач СписокСсылок, Знач ПараметрыВыполнения, Знач ВнутренняяТранзакция = Истина)
	
	УдалитьСсылкиНемонопольно(Результат, СписокСсылок, ПараметрыВыполнения, ВнутренняяТранзакция, Ложь);
	
КонецПроцедуры

Процедура УдалитьСсылкиНепосредственно(Результат, Знач СписокСсылок, Знач ПараметрыВыполнения, Знач ВнутренняяТранзакция = Истина)
	
	УдалитьСсылкиНемонопольно(Результат, СписокСсылок, ПараметрыВыполнения, ВнутренняяТранзакция, Истина);
	
КонецПроцедуры

Процедура УдалитьСсылкиНемонопольно(Результат, Знач СписокСсылок, Знач ПараметрыВыполнения, Знач ВнутренняяТранзакция, Знач УдалятьНепосредственно)
	
	УстановитьПривилегированныйРежим(Истина);
	
	Удаляемые = Новый Массив;
	
	ЛокальнаяТранзакция = Не ТранзакцияАктивна();
	Если ЛокальнаяТранзакция Тогда
		НачатьТранзакцию();
	КонецЕсли;
	
	Для Каждого Ссылка Из СписокСсылок Цикл
		Информация = ИнформацияОТипе(ТипЗнч(Ссылка), ПараметрыВыполнения);
		Блокировка = Новый БлокировкаДанных;
		Блокировка.Добавить(Информация.ПолноеИмя).УстановитьЗначение("Ссылка", Ссылка);
		ИнформацияОбОшибке = Неопределено;
		Попытка
			Блокировка.Заблокировать();
			Удаляемые.Добавить(Ссылка);
		Исключение
			ИнформацияОбОшибке = ИнформацияОбОшибке();
		КонецПопытки;
		Если ИнформацияОбОшибке <> Неопределено Тогда
			ЗарегистрироватьОшибкуВТаблицу(Результат, Ссылка, Неопределено, Ссылка, Информация, "БлокировкаДляУдаленияДубля", ИнформацияОбОшибке);
		КонецЕсли;
	КонецЦикла;
	
	ТаблицаПоиска = МестаИспользования(Удаляемые);
	Фильтр = Новый Структура("Ссылка");
	
	Для Каждого Ссылка Из Удаляемые Цикл
		ПредставлениеСсылки = ПредметСтрокой(Ссылка);
		
		Фильтр.Ссылка = Ссылка;
		МестаИспользования = ТаблицаПоиска.НайтиСтроки(Фильтр);
		
		Индекс = МестаИспользования.ВГраница();
		Пока Индекс >= 0 Цикл
			Если МестаИспользования[Индекс].ВспомогательныеДанные Тогда
				МестаИспользования.Удалить(Индекс);
			КонецЕсли;
			Индекс = Индекс - 1;
		КонецЦикла;
		
		Если МестаИспользования.Количество() > 0 Тогда
			// Остались места использования, нельзя удалять.
			ДобавитьРезультатыЗаменыИзмененныхОбъектов(Результат, МестаИспользования);
			Продолжить;
		КонецЕсли;
		
		Объект = Ссылка.ПолучитьОбъект();
		Если Объект = Неопределено Тогда
			// Уже удален
			Продолжить;
		КонецЕсли;
			
		Если Не ПараметрыВыполнения.ПривилегированнаяЗапись Тогда
			УстановитьПривилегированныйРежим(Ложь);
		КонецЕсли;
			
		Попытка
			Если УдалятьНепосредственно Тогда
				ОбработатьОбъектСПерехватомСообщений(Объект, "НепосредственноеУдаление", Неопределено, ПараметрыВыполнения);
			Иначе
				ОбработатьОбъектСПерехватомСообщений(Объект, "ПометкаУдаления", Неопределено, ПараметрыВыполнения);
			КонецЕсли;
		Исключение
			ИнформацияОбОшибке = ИнформацияОбОшибке();
			ЗарегистрироватьОшибкуЗамены(Результат, Ссылка, 
				ОписаниеОшибкиЗамены("ОшибкаУдаления", Ссылка, ПредставлениеСсылки,
				ВернутьСтр("ru = 'Ошибка удаления'") + Символы.ПС + СокрЛП( КраткоеПредставлениеОшибки(ИнформацияОбОшибке))));
		КонецПопытки;
			
		Если Не ПараметрыВыполнения.ПривилегированнаяЗапись Тогда
			УстановитьПривилегированныйРежим(Истина);
		КонецЕсли;
	КонецЦикла;
	
	Если ЛокальнаяТранзакция Тогда
		ЗафиксироватьТранзакцию();
	КонецЕсли;
КонецПроцедуры

Процедура ДобавитьРезультатыЗаменыИзмененныхОбъектов(Результат, ТаблицаПовторногоПоиска)
	
	ТипКлючЗаписи = ОписаниеТипаКлючиЗаписей();
	
	Фильтр = Новый Структура("ТипОшибки, Ссылка, ОбъектОшибки", "");
	Для Каждого Строка Из ТаблицаПовторногоПоиска Цикл
		Тест = Новый Структура("ВспомогательныеДанные", Ложь);
		ЗаполнитьЗначенияСвойств(Тест, Строка);
		Если Тест.ВспомогательныеДанные Тогда
			Продолжить;
		КонецЕсли;
		
		Данные = Строка.Данные;
		Ссылка = Строка.Ссылка;
		
		ПредставлениеДанных = Строка(Данные);
		
		Фильтр.ОбъектОшибки = Данные;
		Фильтр.Ссылка       = Ссылка;
		Если Результат.Ошибки.НайтиСтроки(Фильтр).Количество() > 0 Тогда
			Продолжить; // По данной проблеме уже записана ошибка.
		КонецЕсли;
		ЗарегистрироватьОшибкуЗамены(Результат, Ссылка, 
			ОписаниеОшибкиЗамены("ДанныеИзменены", Данные, ПредставлениеДанных,
			ВернутьСтр("ru = 'Заменены не все места использования. Возможно места использования были добавлены или изменены другим пользователем.'")));
	КонецЦикла;
	
КонецПроцедуры

Функция ОписаниеИзмеренийНабора(Знач Мета, Кэш)
	
	ОписаниеИзмерений = Кэш[Мета];
	Если ОписаниеИзмерений<>Неопределено Тогда
		Возврат ОписаниеИзмерений;
	КонецЕсли;
	
	// Период и регистратор, если есть.
	ОписаниеИзмерений = Новый Структура;
	
	ДанныеИзмерения = Новый Структура("Ведущее, Представление, Формат, Тип", Ложь);
	
	Если Метаданные.РегистрыСведений.Содержит(Мета) Тогда
		// Возможно есть период
		МетаПериод = Мета.ПериодичностьРегистраСведений; 
		Периодичность = Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений;
		
		Если МетаПериод = Периодичность.ПозицияРегистратора Тогда
			ДанныеИзмерения.Тип           = Документы.ТипВсеСсылки();
			ДанныеИзмерения.Представление = ВернутьСтр("ru='Регистратор'");
			ДанныеИзмерения.Ведущее       = Истина;
			ОписаниеИзмерений.Вставить("Регистратор", ДанныеИзмерения);
			
		ИначеЕсли МетаПериод = Периодичность.Год Тогда
			ДанныеИзмерения.Тип           = Новый ОписаниеТипов("Дата");
			ДанныеИзмерения.Представление = ВернутьСтр("ru='Период'");
			ДанныеИзмерения.Формат        = "Л=ru_RU; ДФ='yyyy ""г.""'; ДП='Дата не задана'";
			ОписаниеИзмерений.Вставить("Период", ДанныеИзмерения);
			
		ИначеЕсли МетаПериод = Периодичность.День Тогда
			ДанныеИзмерения.Тип           = Новый ОписаниеТипов("Дата");
			ДанныеИзмерения.Представление = ВернутьСтр("ru='Период'");
			ДанныеИзмерения.Формат        = "Л=ru_RU; ДЛФ=D; ДП='Дата не задана'";
			ОписаниеИзмерений.Вставить("Период", ДанныеИзмерения);
			
		ИначеЕсли МетаПериод = Периодичность.Квартал Тогда
			ДанныеИзмерения.Тип           = Новый ОписаниеТипов("Дата");
			ДанныеИзмерения.Представление = ВернутьСтр("ru='Период'");
			ДанныеИзмерения.Формат        =  "Л=ru_RU; ДФ='к ""квартал ""yyyy ""г.""'; ДП='Дата не задана'";
			ОписаниеИзмерений.Вставить("Период", ДанныеИзмерения);
			
		ИначеЕсли МетаПериод = Периодичность.Месяц Тогда
			ДанныеИзмерения.Тип           = Новый ОписаниеТипов("Дата");
			ДанныеИзмерения.Представление = ВернутьСтр("ru='Период'");
			ДанныеИзмерения.Формат        = "Л=ru_RU; ДФ='ММММ yyyy ""г.""'; ДП='Дата не задана'";
			ОписаниеИзмерений.Вставить("Период", ДанныеИзмерения);
			
		ИначеЕсли МетаПериод = Периодичность.Секунда Тогда
			ДанныеИзмерения.Тип           = Новый ОписаниеТипов("Дата");
			ДанныеИзмерения.Представление = ВернутьСтр("ru='Период'");
			ДанныеИзмерения.Формат        = "Л=ru_RU; ДЛФ=DT; ДП='Дата не задана'";
			ОписаниеИзмерений.Вставить("Период", ДанныеИзмерения);
			
		КонецЕсли;
		
	Иначе
		ДанныеИзмерения.Тип           = Документы.ТипВсеСсылки();
		ДанныеИзмерения.Представление = ВернутьСтр("ru='Регистратор'");
		ДанныеИзмерения.Ведущее       = Истина;
		ОписаниеИзмерений.Вставить("Регистратор", ДанныеИзмерения);
		
	КонецЕсли;
	
	// Все измерения
	Для Каждого МетаИзмерение Из Мета.Измерения Цикл
		ДанныеИзмерения = Новый Структура("Ведущее, Представление, Формат, Тип");
		ДанныеИзмерения.Тип           = МетаИзмерение.Тип;
		ДанныеИзмерения.Представление = МетаИзмерение.Представление();
		ДанныеИзмерения.Ведущее       = МетаИзмерение.Ведущее;
		ОписаниеИзмерений.Вставить(МетаИзмерение.Имя, ДанныеИзмерения);
	КонецЦикла;
	
	Кэш[Мета] = ОписаниеИзмерений;
	Возврат ОписаниеИзмерений;
КонецФункции

Функция ОписаниеДвижений(Знач Мета)
	// можно закэшировать по Мета
	
	ОписаниеДвижений = Новый Массив;
	Если Не Метаданные.Документы.Содержит(Мета) Тогда
		Возврат ОписаниеДвижений;
	КонецЕсли;
	
	Для Каждого Движение Из Мета.Движения Цикл
		
		Если Метаданные.РегистрыНакопления.Содержит(Движение) Тогда
			НаборЗаписей = РегистрыНакопления[Движение.Имя].СоздатьНаборЗаписей();
			ИсключатьПоля = "Активность, НомерСтроки, Период, Регистратор"; 
			
		ИначеЕсли Метаданные.РегистрыСведений.Содержит(Движение) Тогда
			НаборЗаписей = РегистрыСведений[Движение.Имя].СоздатьНаборЗаписей();
			ИсключатьПоля = "Активность, ВидДвижения, НомерСтроки, Период, Регистратор"; 
			
		ИначеЕсли Метаданные.РегистрыБухгалтерии.Содержит(Движение) Тогда
			НаборЗаписей = РегистрыБухгалтерии[Движение.Имя].СоздатьНаборЗаписей();
			ИсключатьПоля = "Активность, ВидДвижения, НомерСтроки, Период, Регистратор"; 
			
		ИначеЕсли Метаданные.РегистрыРасчета.Содержит(Движение) Тогда
			НаборЗаписей = РегистрыРасчета[Движение.Имя].СоздатьНаборЗаписей();
			ИсключатьПоля = "Активность, БазовыйПериодКонец, БазовыйПериодНачало, НомерСтроки, ПериодДействия,
			                |ПериодДействияКонец, ПериодДействияНачало, ПериодРегистрации, Регистратор, Сторно,
			                |ФактическийПериодДействия";
		Иначе
			// Неизвестный тип
			Продолжить;
		КонецЕсли;
		
		// Поля ссылочного типа и измерения - кандидаты.
		Описание = СпискиПолейПоТипу(НаборЗаписей, Движение.Измерения, ИсключатьПоля);
		Если Описание.СписокПолей.Количество() = 0 Тогда
			// Незачем обрабатывать
			Продолжить;
		КонецЕсли;
		
		Описание.Вставить("НаборЗаписей", НаборЗаписей);
		Описание.Вставить("ПространствоБлокировки", Движение.ПолноеИмя() );
		
		ОписаниеДвижений.Добавить(Описание);
	КонецЦикла;	// Метаданные движений
	
	Возврат ОписаниеДвижений;
КонецФункции

Функция ОписаниеПоследовательностей(Знач Мета)
	
	ОписаниеПоследовательностей = Новый Массив;
	Если Не Метаданные.Документы.Содержит(Мета) Тогда
		Возврат ОписаниеПоследовательностей;
	КонецЕсли;
	
	Для Каждого Последовательность Из Метаданные.Последовательности Цикл
		Если Не Последовательность.Документы.Содержит(Мета) Тогда
			Продолжить;
		КонецЕсли;
		
		ИмяТаблицы = Последовательность.ПолноеИмя();
		
		// Список полей и измерений
		Описание = СпискиПолейПоТипу(ИмяТаблицы, Последовательность.Измерения, "Регистратор");
		Если Описание.СписокПолей.Количество() > 0 Тогда
			
			Описание.Вставить("НаборЗаписей",           Последовательности[Последовательность.Имя].СоздатьНаборЗаписей());
			Описание.Вставить("ПространствоБлокировки", ИмяТаблицы + ".Записи");
			Описание.Вставить("Измерения",              Новый Структура);
			
			ОписаниеПоследовательностей.Добавить(Описание);
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ОписаниеПоследовательностей;
КонецФункции

Функция ОписаниеОбъекта(Знач Мета)
	// можно закэшировать по Мета
	
	ТипВсеСсылки = ОписаниеТипаВсеСсылки();
	
	Кандидаты = Новый Структура("Реквизиты, СтандартныеРеквизиты, ТабличныеЧасти, СтандартныеТабличныеЧасти");
	ЗаполнитьЗначенияСвойств(Кандидаты, Мета);
	
	ОписаниеОбъекта = Новый Структура;
	
	ОписаниеОбъекта.Вставить("Реквизиты", Новый Структура);
	Если Кандидаты.Реквизиты <> Неопределено Тогда
		Для Каждого МетаРеквизит Из Кандидаты.Реквизиты Цикл
			Если ОписанияТиповПересекаются(МетаРеквизит.Тип, ТипВсеСсылки) Тогда
				ОписаниеОбъекта.Реквизиты.Вставить(МетаРеквизит.Имя);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	ОписаниеОбъекта.Вставить("СтандартныеРеквизиты", Новый Структура);
	Если Кандидаты.СтандартныеРеквизиты <> Неопределено Тогда
		Исключаемые = Новый Структура("Ссылка");
		
		Для Каждого МетаРеквизит Из Кандидаты.СтандартныеРеквизиты Цикл
			Имя = МетаРеквизит.Имя;
			Если Не Исключаемые.Свойство(Имя) И ОписанияТиповПересекаются(МетаРеквизит.Тип, ТипВсеСсылки) Тогда
				ОписаниеОбъекта.Реквизиты.Вставить(МетаРеквизит.Имя);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	ОписаниеОбъекта.Вставить("ТабличныеЧасти", Новый Массив);
	Если Кандидаты.ТабличныеЧасти <> Неопределено Тогда
		Для Каждого МетаТаблица Из Кандидаты.ТабличныеЧасти Цикл
			
			СписокПолей = Новый Структура;
			Для Каждого МетаРеквизит Из МетаТаблица.Реквизиты Цикл
				Если ОписанияТиповПересекаются(МетаРеквизит.Тип, ТипВсеСсылки) Тогда
					СписокПолей.Вставить(МетаРеквизит.Имя);
				КонецЕсли;
			КонецЦикла;
			
			Если СписокПолей.Количество() > 0 Тогда
				ОписаниеОбъекта.ТабличныеЧасти.Добавить(Новый Структура("Имя, СписокПолей", МетаТаблица.Имя, СписокПолей));
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	ОписаниеОбъекта.Вставить("СтандартныеТабличныеЧасти", Новый Массив);
	Если Кандидаты.СтандартныеТабличныеЧасти <> Неопределено Тогда
		Для Каждого МетаТаблица Из Кандидаты.СтандартныеТабличныеЧасти Цикл
			
			СписокПолей = Новый Структура;
			Для Каждого МетаРеквизит Из МетаТаблица.СтандартныеРеквизиты Цикл
				Если ОписанияТиповПересекаются(МетаРеквизит.Тип, ТипВсеСсылки) Тогда
					СписокПолей.Вставить(МетаРеквизит.Имя);
				КонецЕсли;
			КонецЦикла;
			
			Если СписокПолей.Количество() > 0 Тогда
				ОписаниеОбъекта.СтандартныеТабличныеЧасти.Добавить(Новый Структура("Имя, СписокПолей", МетаТаблица.Имя, СписокПолей));
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	ОписаниеОбъекта.Вставить("МожетБытьПроведен", Метаданные.Документы.Содержит(Мета));
	Возврат ОписаниеОбъекта;
КонецФункции

Функция ОписаниеКлючаЗаписи(Знач Мета)
	// можно закэшировать по Мета
	
	ИмяТаблицы = Мета.ПолноеИмя();
	
	// Поля ссылочного типа - кандидаты и набор измерений.
	ОписаниеКлюча = СпискиПолейПоТипу(ИмяТаблицы, Мета.Измерения, "Период, Регистратор");
	
	Если Метаданные.РегистрыСведений.Содержит(Мета) Тогда
		НаборЗаписей = РегистрыСведений[Мета.Имя].СоздатьНаборЗаписей();
	
	ИначеЕсли Метаданные.РегистрыНакопления.Содержит(Мета) Тогда
		НаборЗаписей = РегистрыНакопления[Мета.Имя].СоздатьНаборЗаписей();
	
	ИначеЕсли Метаданные.РегистрыБухгалтерии.Содержит(Мета) Тогда
		НаборЗаписей = РегистрыБухгалтерии[Мета.Имя].СоздатьНаборЗаписей();
	
	ИначеЕсли Метаданные.РегистрыРасчета.Содержит(Мета) Тогда
		НаборЗаписей = РегистрыРасчета[Мета.Имя].СоздатьНаборЗаписей();
	
	ИначеЕсли Метаданные.Последовательности.Содержит(Мета) Тогда
		НаборЗаписей = Последовательности[Мета.Имя].СоздатьНаборЗаписей();
	
	Иначе
		НаборЗаписей = Неопределено;
	
	КонецЕсли;
	
	ОписаниеКлюча.Вставить("НаборЗаписей", НаборЗаписей);
	ОписаниеКлюча.Вставить("ПространствоБлокировки", ИмяТаблицы);
	
	Возврат ОписаниеКлюча;
КонецФункции

Функция ОписанияТиповПересекаются(Знач Описание1, Знач Описание2)
	
	Для Каждого Тип Из Описание1.Типы() Цикл
		Если Описание2.СодержитТип(Тип) Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
КонецФункции

// Возвращает описание по имени таблицы или по набору записей.
Функция СпискиПолейПоТипу(Знач ИсточникДанных, Знач МетаИзмерения, Знач ИсключатьПоля)
	// можно закэшировать
	
	Описание = Новый Структура;
	Описание.Вставить("СписокПолей",     Новый Структура);
	Описание.Вставить("СтруктураИзмерений", Новый Структура);
	Описание.Вставить("СписокВедущих",   Новый Структура);
	
	ТипКонтроля = ОписаниеТипаВсеСсылки();
	Исключаемые = Новый Структура(ИсключатьПоля);
	
	ТипИсточникаДанных = ТипЗнч(ИсточникДанных);
	
	Если ТипИсточникаДанных = Тип("Строка") Тогда
		// Источник - имя таблицы, получаем поля запросом.
		Запрос = Новый Запрос("ВЫБРАТЬ * ИЗ " + ИсточникДанных + " ГДЕ ЛОЖЬ");
		ИсточникПолей = Запрос.Выполнить();
	Иначе
		// Источник - набор записей
		ИсточникПолей = ИсточникДанных.ВыгрузитьКолонки();
	КонецЕсли;
	
	Для Каждого Колонка Из ИсточникПолей.Колонки Цикл
		Имя = Колонка.Имя;
		Если Не Исключаемые.Свойство(Имя) И ОписанияТиповПересекаются(Колонка.ТипЗначения, ТипКонтроля) Тогда
			Описание.СписокПолей.Вставить(Имя);
			
			// И проверка на ведущее измерение.
			Мета = МетаИзмерения.Найти(Имя);
			Если Мета <> Неопределено Тогда
				Описание.СтруктураИзмерений.Вставить(Имя, Мета.Тип);
				Тест = Новый Структура("Ведущее", Ложь);
				ЗаполнитьЗначенияСвойств(Тест, Мета);
				Если Тест.Ведущее Тогда
					Описание.СписокВедущих.Вставить(Имя, Мета.Тип);
				КонецЕсли;
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Описание;
КонецФункции

Процедура ЗаменитьВКоллекцииСтрок(ВидКоллекции, ИмяКоллекции, Объект, Коллекция, Знач СписокПолей, Знач ПарыЗамен)
	РабочаяКоллекция = Коллекция.Выгрузить();
	Модифицировано = Ложь;
	
	Для Каждого Строка Из РабочаяКоллекция Цикл
		
		Для Каждого КлючЗначение Из СписокПолей Цикл
			Имя = КлючЗначение.Ключ;
			ЦелеваяСсылка = ПарыЗамен[ Строка[Имя] ];
			Если ЦелеваяСсылка <> Неопределено Тогда
				ЗарегистрироватьФактЗамены(Объект, Строка[Имя], ЦелеваяСсылка, ВидКоллекции, ИмяКоллекции, РабочаяКоллекция.Индекс(Строка), Имя);
				Строка[Имя] = ЦелеваяСсылка;
				Модифицировано = Истина;
			КонецЕсли;
		КонецЦикла;
		
	КонецЦикла;
	
	Если Модифицировано Тогда
		Коллекция.Загрузить(РабочаяКоллекция);
	КонецЕсли;
КонецПроцедуры

Процедура СообщитьОтложенныеСообщения(Знач Сообщения)
	
	Для Каждого Сообщение Из Сообщения Цикл
		Сообщение.Сообщить();
	КонецЦикла;
	
КонецПроцедуры

Процедура ОбработатьОбъектСПерехватомСообщений(Знач Объект, Знач Действие, Знач РежимЗаписи, Знач ПараметрыЗаписи)
	
	// Текущие сообщения до исключения запоминаем.
	ПредыдущиеСообщения = ПолучитьСообщенияПользователю(Истина);
	СообщатьПовторно    = ТекущийРежимЗапуска() <> Неопределено;
	
	Попытка
		
		Объект.ОбменДанными.Загрузка = Не ПараметрыЗаписи.ВключатьБизнесЛогику;
		
		Если Действие = "Запись" Тогда
			Если РежимЗаписи = Неопределено Тогда
				Объект.Записать();
			Иначе
				Объект.Записать(РежимЗаписи);
			КонецЕсли;
			
		ИначеЕсли Действие = "ПометкаУдаления" Тогда
			Объект.УстановитьПометкуУдаления(Истина, Ложь);
			
		ИначеЕсли Действие = "НепосредственноеУдаление" Тогда
			Объект.Удалить();
			
		КонецЕсли;
		
	Исключение
		Информация = ИнформацияОбОшибке(); 
		
		// Перехватываем все сообщенное при ошибке и добавляем их в одно исключение.
		ТекстИсключения = "";
		Для Каждого Сообщение Из ПолучитьСообщенияПользователю(Ложь) Цикл
			ТекстИсключения = ТекстИсключения + Символы.ПС + Сообщение.Текст;
		КонецЦикла;
		
		// Сообщаем предыдущие
		Если СообщатьПовторно Тогда
			СообщитьОтложенныеСообщения(ПредыдущиеСообщения);
		КонецЕсли;
		
		ВызватьИсключение СокрЛП(КраткоеПредставлениеОшибки(Информация) + Символы.ПС + СокрЛП(ТекстИсключения));
	КонецПопытки;
	
	Если СообщатьПовторно Тогда
		СообщитьОтложенныеСообщения(ПредыдущиеСообщения);
	КонецЕсли;
	
КонецПроцедуры

Процедура ЗаписатьОбъект(Знач Объект, Знач ПараметрыЗаписи)
	
	МетаданныеОбъекта = Объект.Метаданные();
	
	Если ЭтоДокумент(МетаданныеОбъекта) Тогда
		ОбработатьОбъектСПерехватомСообщений(Объект, "Запись", РежимЗаписиДокумента.Запись, ПараметрыЗаписи);
		Возврат;
	КонецЕсли;
	
	// Проверка на возможные циклические ссылки.
	ТестРеквизитов= Новый Структура("Иерархический, ВидыСубконто, Владельцы", Ложь, Неопределено, Новый Массив);
	ЗаполнитьЗначенияСвойств(ТестРеквизитов, МетаданныеОбъекта);
	
	// По родителю
	Если ТестРеквизитов.Иерархический Или ТестРеквизитов.ВидыСубконто <> Неопределено Тогда 
		
		Если Объект.Родитель = Объект.Ссылка Тогда
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				ВернутьСтр("ru = 'При записи ""%1"" возникает циклическая ссылка в иерархии.'"),
				Строка(Объект));
			КонецЕсли;
			
	КонецЕсли;
	
	// По владельцу
	Для Каждого МетаВладелец Из ТестРеквизитов.Владельцы Цикл
		
		Если Объект.Владелец = Объект.Ссылка Тогда
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				ВернутьСтр("ru = 'При записи ""%1"" возникает циклическая ссылка в подчинении.'"),
				Строка(Объект));
		КонецЕсли;
		Прервать;
		
	КонецЦикла;
	
	// Для последовательностей право "Изменение" может отсутствовать даже у роли "АдминистраторСистемы".
	Если ЭтоПоследовательность(МетаданныеОбъекта)
		И Не ПравоДоступа("Изменение", МетаданныеОбъекта)
		И ОбщегоНазначенияПовтИсп.РежимРаботыПрограммы().ЭтоАдминистраторПрограммы Тогда
		УстановитьПривилегированныйРежим(Истина);
	КонецЕсли;
	
	// Просто запись
	ОбработатьОбъектСПерехватомСообщений(Объект, "Запись", Неопределено, ПараметрыЗаписи);
КонецПроцедуры

Функция СобытиеЖурналаРегистрацииЗаменыСсылок()
	Возврат ВернутьСтр("ru='Поиск и удаление ссылок'", Метаданные.ОсновнойЯзык.КодЯзыка);
КонецФункции

Процедура ЗаменитьСсылкиКороткимиТранзакциями(Результат, Знач ПараметрыВыполнения, Знач Дубли, Знач ТаблицаПоиска)
	
	// Основной цикл обработки
	ФильтрСсылок = Новый Структура("Ссылка, КлючЗамены");
	Для Каждого Дубль Из Дубли Цикл
		БылиОшибки = Результат.ЕстьОшибки;
		Результат.ЕстьОшибки = Ложь;
		
		ФильтрСсылок.Ссылка = Дубль;
		
		ФильтрСсылок.КлючЗамены = "Константа";
		МестаИспользования = ТаблицаПоиска.НайтиСтроки(ФильтрСсылок);
		Для Каждого МестоИспользования Из МестаИспользования Цикл
			ПроизвестиЗаменуВКонстанте(Результат, МестоИспользования, ПараметрыВыполнения, Истина);
		КонецЦикла;
		
		ФильтрСсылок.КлючЗамены = "Объект";
		МестаИспользования = ТаблицаПоиска.НайтиСтроки(ФильтрСсылок);
		Для Каждого МестоИспользования Из МестаИспользования Цикл
			ПроизвестиЗаменуВОбъекте(Результат, МестоИспользования, ПараметрыВыполнения, Истина);
		КонецЦикла;
		
		ФильтрСсылок.КлючЗамены = "КлючЗаписи";
		МестаИспользования = ТаблицаПоиска.НайтиСтроки(ФильтрСсылок);
		Для Каждого МестоИспользования Из МестаИспользования Цикл
			ПроизвестиЗаменуВНаборе(Результат, МестоИспользования, ПараметрыВыполнения, Истина);
		КонецЦикла;
		
		ФильтрСсылок.КлючЗамены = "Последовательность";
		МестаИспользования = ТаблицаПоиска.НайтиСтроки(ФильтрСсылок);
		Для Каждого МестоИспользования Из МестаИспользования Цикл
			ПроизвестиЗаменуВНаборе(Результат, МестоИспользования, ПараметрыВыполнения, Истина);
		КонецЦикла;
		
		ФильтрСсылок.КлючЗамены = "РегистрСведений";
		МестаИспользования = ТаблицаПоиска.НайтиСтроки(ФильтрСсылок);
		Для Каждого МестоИспользования Из МестаИспользования Цикл
			ПроизвестиЗаменуВРегистреСведений(Результат, МестоИспользования, ПараметрыВыполнения, Истина);
		КонецЦикла;
		
		Если Не Результат.ЕстьОшибки Тогда
			ПараметрыВыполнения.УспешныеЗамены.Вставить(Дубль, ПараметрыВыполнения.ПарыЗамен[Дубль]);
		КонецЕсли;
		Результат.ЕстьОшибки = Результат.ЕстьОшибки Или БылиОшибки;
		
	КонецЦикла;
	
	// Окончательные действия
	Если ПараметрыВыполнения.УдалятьНепосредственно Тогда
		УдалитьСсылкиНепосредственно(Результат, Дубли, ПараметрыВыполнения, Истина);
		
	ИначеЕсли ПараметрыВыполнения.ПомечатьНаУдаление Тогда
		УдалитьСсылкиПометкой(Результат, Дубли, ПараметрыВыполнения);
		
	Иначе
		// Поиск новых
		ТаблицаПовторногоПоиска = МестаИспользования(Дубли);
		ДобавитьРезультатыЗаменыИзмененныхОбъектов(Результат, ТаблицаПовторногоПоиска);
	КонецЕсли;
	
КонецПроцедуры

Процедура ЗаменитьСсылкуДлиннойТранзакцией(Результат, Знач Дубль, Знач ПараметрыВыполнения, Знач ТаблицаПоиска)
	УстановитьПривилегированныйРежим(Истина);
	
	СостояниеОперации = "";
	
	// 1. Блокирование всех мест использования.
	Блокировка = Новый БлокировкаДанных;
	
	МестаИспользования = ТаблицаПоиска.НайтиСтроки(Новый Структура("Ссылка", Дубль));
	ЗаблокироватьМестаИспользования(ПараметрыВыполнения, Блокировка, МестаИспользования);
	
	НачатьТранзакцию();
	Попытка
		Блокировка.Заблокировать();
	Исключение
		// Добавляем запись в результат о неудачной попытке блокировке.
		ПредставлениеОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		Ошибка = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ВернутьСтр("ru = 'Не удалось заблокировать все места использования %1:'") + Символы.ПС + ПредставлениеОшибки, Дубль);
		ЗарегистрироватьОшибкуЗамены(Результат, Дубль, 
			ОписаниеОшибкиЗамены("ОшибкаБлокировки", Неопределено, Неопределено, Ошибка));
		СостояниеОперации = "ОшибкаБлокировки";
	КонецПопытки;
	
	УстановитьПривилегированныйРежим(Ложь);
	
	БылиОшибки = Результат.ЕстьОшибки;
	
	// 2. Замена везде до первой ошибки.
	Если СостояниеОперации = "" Тогда
		Результат.ЕстьОшибки = Ложь;
		
		Для Каждого МестоИспользования Из МестаИспользования Цикл
			
			Если МестоИспользования.КлючЗамены = "Константа" Тогда
				
				ПроизвестиЗаменуВКонстанте(Результат, МестоИспользования, ПараметрыВыполнения, Ложь);
				
			ИначеЕсли МестоИспользования.КлючЗамены = "Объект" Тогда
				
				ПроизвестиЗаменуВОбъекте(Результат, МестоИспользования, ПараметрыВыполнения, Ложь);
				
			ИначеЕсли МестоИспользования.КлючЗамены = "Последовательность" Тогда
				
				ПроизвестиЗаменуВНаборе(Результат, МестоИспользования, ПараметрыВыполнения, Ложь);
				
			ИначеЕсли МестоИспользования.КлючЗамены = "КлючЗаписи" Тогда
				
				ПроизвестиЗаменуВНаборе(Результат, МестоИспользования, ПараметрыВыполнения, Ложь);
				
			ИначеЕсли МестоИспользования.КлючЗамены = "РегистрСведений" Тогда
				
				ПроизвестиЗаменуВРегистреСведений(Результат, МестоИспользования, ПараметрыВыполнения, Ложь);
				
			КонецЕсли;
			
			Если Результат.ЕстьОшибки Тогда
				СостояниеОперации = "ОшибкаЗаписи";
				Прервать;
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЕсли;
	
	// 3. Удаление 
	ПроизводимыеЗамены = Новый Массив;
	ПроизводимыеЗамены.Добавить(Дубль);
	
	Если СостояниеОперации = "" Тогда
		Результат.ЕстьОшибки = Ложь;
		
		Если ПараметрыВыполнения.УдалятьНепосредственно Тогда
			УдалитьСсылкиНепосредственно(Результат, ПроизводимыеЗамены, ПараметрыВыполнения, Ложь);
			
		ИначеЕсли ПараметрыВыполнения.ПомечатьНаУдаление Тогда
			УдалитьСсылкиПометкой(Результат, ПроизводимыеЗамены, ПараметрыВыполнения, Ложь);
			
		Иначе 
			// Поиск новых
			ТаблицаПовторногоПоиска = МестаИспользования(ПроизводимыеЗамены);
			ДобавитьРезультатыЗаменыИзмененныхОбъектов(Результат, ТаблицаПовторногоПоиска);
		КонецЕсли;
		
		Если Результат.ЕстьОшибки Тогда
			СостояниеОперации = "ДанныеИзменены";
		КонецЕсли;
	КонецЕсли;
	
	Результат.ЕстьОшибки = Результат.ЕстьОшибки Или БылиОшибки;
	
	Если СостояниеОперации = "" Тогда
		ЗафиксироватьТранзакцию();
		ПараметрыВыполнения.УспешныеЗамены.Вставить(Дубль, ПараметрыВыполнения.ПарыЗамен[Дубль]);
	Иначе
		ОтменитьТранзакцию();
	КонецЕсли;
	
КонецПроцедуры

Процедура ЗаблокироватьМестаИспользования(ПараметрыВыполнения, Блокировка, МестаИспользования)
	
	Для Каждого МестоИспользования Из МестаИспользования Цикл
		
		ЗаблокироватьМестоИспользования(ПараметрыВыполнения, Блокировка, МестоИспользования);
		
	КонецЦикла;
	
КонецПроцедуры

Процедура ЗаблокироватьМестоИспользования(ПараметрыВыполнения, Блокировка, МестоИспользования)
	
	Если МестоИспользования.КлючЗамены = "Константа" Тогда
		
		Блокировка.Добавить(МестоИспользования.Метаданные.ПолноеИмя());
		
	ИначеЕсли МестоИспользования.КлючЗамены = "Объект" Тогда
		
		СсылкаОбъекта     = МестоИспользования.Данные;
		МетаданныеОбъекта = МестоИспользования.Метаданные;
		
		// Сам объект.
		Блокировка.Добавить(МетаданныеОбъекта.ПолноеИмя()).УстановитьЗначение("Ссылка", СсылкаОбъекта);
		
		// Движения по регистратору.
		ОписаниеДвижений = ОписаниеДвижений(МетаданныеОбъекта);
		Для Каждого Элемент Из ОписаниеДвижений Цикл
			Блокировка.Добавить(Элемент.ПространствоБлокировки + ".НаборЗаписей").УстановитьЗначение("Регистратор", СсылкаОбъекта);
		КонецЦикла;
		
		// Последовательности.
		ОписаниеПоследовательностей = ОписаниеПоследовательностей(МетаданныеОбъекта);
		Для Каждого Элемент Из ОписаниеПоследовательностей Цикл
			Блокировка.Добавить(Элемент.ПространствоБлокировки).УстановитьЗначение("Регистратор", СсылкаОбъекта);
		КонецЦикла;
		
	ИначеЕсли МестоИспользования.КлючЗамены = "Последовательность" Тогда
		
		СсылкаОбъекта     = МестоИспользования.Данные;
		МетаданныеОбъекта = МестоИспользования.Метаданные;
		
		ОписаниеПоследовательностей = ОписаниеПоследовательностей(МетаданныеОбъекта);
		Для Каждого Элемент Из ОписаниеПоследовательностей Цикл
			Блокировка.Добавить(Элемент.ПространствоБлокировки).УстановитьЗначение("Регистратор", СсылкаОбъекта);
		КонецЦикла;
		
	ИначеЕсли МестоИспользования.КлючЗамены = "КлючЗаписи"
		Или МестоИспользования.КлючЗамены = "РегистрСведений" Тогда
		
		Информация = ИнформацияОТипе(МестоИспользования.Метаданные, ПараметрыВыполнения);
		ТипДубля = МестоИспользования.ТипСсылки;
		ТипОригинала = ТипЗнч(МестоИспользования.ЦелеваяСсылка);
		
		Для Каждого КлючЗначение Из Информация.Измерения Цикл
			ТипИзмерения = КлючЗначение.Значение.Тип;
			Если ТипИзмерения.СодержитТип(ТипДубля) Тогда
				БлокировкаПоИзмерению = Блокировка.Добавить(Информация.ПолноеИмя);
				БлокировкаПоИзмерению.УстановитьЗначение(КлючЗначение.Ключ, МестоИспользования.Ссылка);
			КонецЕсли;
			Если ТипИзмерения.СодержитТип(ТипОригинала) Тогда
				БлокировкаПоИзмерению = Блокировка.Добавить(Информация.ПолноеИмя);
				БлокировкаПоИзмерению.УстановитьЗначение(КлючЗначение.Ключ, МестоИспользования.ЦелеваяСсылка);
			КонецЕсли;
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

Процедура ЗарегистрироватьОшибкуЗамены(Результат, Знач Ссылка, Знач ОписаниеОшибки)
	
	Результат.ЕстьОшибки = Истина;
	
	Строка = Результат.Ошибки.Добавить();
	Строка.Ссылка = Ссылка;
	Строка.ПредставлениеОбъектаОшибки = ОписаниеОшибки.ПредставлениеОбъектаОшибки;
	Строка.ОбъектОшибки               = ОписаниеОшибки.ОбъектОшибки;
	Строка.ТекстОшибки                = ОписаниеОшибки.ТекстОшибки;
	Строка.ТипОшибки                  = ОписаниеОшибки.ТипОшибки;
	
КонецПроцедуры

Функция ОписаниеОшибкиЗамены(Знач ТипОшибки, Знач ОбъектОшибки, Знач ПредставлениеОбъектаОшибки, Знач ТекстОшибки)
	Результат = Новый Структура;
	
	Результат.Вставить("ТипОшибки",                  ТипОшибки);
	Результат.Вставить("ОбъектОшибки",               ОбъектОшибки);
	Результат.Вставить("ПредставлениеОбъектаОшибки", ПредставлениеОбъектаОшибки);
	Результат.Вставить("ТекстОшибки",                ТекстОшибки);
	
	Возврат Результат;
КонецФункции

Процедура ЗарегистрироватьОшибкуВТаблицу(Результат, Дубль, Оригинал, Данные, Информация, ТипОшибки, ИнформацияОбОшибке)
	Результат.ЕстьОшибки = Истина;
	
	ОшибкаВНовомФормате = Результат.ТаблицаОшибок.Добавить();
	ОшибкаВНовомФормате.Дубль              = Дубль;
	ОшибкаВНовомФормате.Оригинал           = Оригинал;
	ОшибкаВНовомФормате.Данные             = Данные;
	ОшибкаВНовомФормате.Информация         = Информация;
	ОшибкаВНовомФормате.ТипОшибки          = ТипОшибки;
	ОшибкаВНовомФормате.ИнформацияОбОшибке = ИнформацияОбОшибке;
	
	ЗаписьЖурналаРегистрации(
		СобытиеЖурналаРегистрацииЗаменыСсылок(),
		УровеньЖурналаРегистрации.Ошибка,
		,
		ПодробноеПредставлениеОшибки(ИнформацияОбОшибке));
	
	ПолноеПредставлениеДанных = Строка(Данные) + " (" + Информация.ПредставлениеЭлемента + ")";
	
	ОшибкаВСтаромФормате = Результат.Ошибки.Добавить();
	ОшибкаВСтаромФормате.Ссылка       = Дубль;
	ОшибкаВСтаромФормате.ОбъектОшибки = Данные;
	ОшибкаВСтаромФормате.ПредставлениеОбъектаОшибки = ПолноеПредставлениеДанных;
	
	Если ТипОшибки = "БлокировкаДляРегистра" Тогда
		НовыйШаблон = ВернутьСтр("ru = 'Не удалось начать редактирование %1: %2'");
		ОшибкаВСтаромФормате.ТипОшибки = "ОшибкаБлокировки";
	ИначеЕсли ТипОшибки = "БлокировкаДляУдаленияДубля" Тогда
		НовыйШаблон = ВернутьСтр("ru = 'Не удалось начать удаление: %2'");
		ОшибкаВСтаромФормате.ТипОшибки = "ОшибкаБлокировки";
	ИначеЕсли ТипОшибки = "УдалитьНаборДубля" Тогда
		НовыйШаблон = ВернутьСтр("ru = 'Не удалось очистить сведения о дубле в %1: %2'");
		ОшибкаВСтаромФормате.ТипОшибки = "ОшибкаЗаписи";
	ИначеЕсли ТипОшибки = "ЗаписатьНаборОригинала" Тогда
		НовыйШаблон = ВернутьСтр("ru = 'Не удалось обновить сведения в %1: %2'");
		ОшибкаВСтаромФормате.ТипОшибки = "ОшибкаЗаписи";
	Иначе
		НовыйШаблон = ТипОшибки + " (%1): %2";
		ОшибкаВСтаромФормате.ТипОшибки = ТипОшибки;
	КонецЕсли;
	
	НовыйШаблон = НовыйШаблон + Символы.ПС + Символы.ПС + ВернутьСтр("ru = 'Подробности в журнале регистрации.'");
	
	КраткоеПредставление = СтандартныеПодсистемыКлиентСервер.ИсходнаяПричинаОшибки(ИнформацияОбОшибке);
	ОшибкаВСтаромФормате.ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НовыйШаблон, ПолноеПредставлениеДанных, КраткоеПредставление);
	
КонецПроцедуры

// Формирует информацию о типе объекта метаданных, как то: полное имя, представления, вид и т.п.
Функция ИнформацияОТипе(ПолноеИмяИлиМетаданныеИлиТип, ПараметрыВыполнения)
	ТипПервогоПараметра = ТипЗнч(ПолноеИмяИлиМетаданныеИлиТип);
	Если ТипПервогоПараметра = Тип("Строка") Тогда
		ОбъектМетаданных = Метаданные.НайтиПоПолномуИмени(ПолноеИмяИлиМетаданныеИлиТип);
	Иначе
		Если ТипПервогоПараметра = Тип("Тип") Тогда // Поиск объекта метаданных.
			ОбъектМетаданных = Метаданные.НайтиПоТипу(ПолноеИмяИлиМетаданныеИлиТип);
		Иначе
			ОбъектМетаданных = ПолноеИмяИлиМетаданныеИлиТип;
		КонецЕсли;
	КонецЕсли;
	ПолноеИмя = ВРег(ОбъектМетаданных.ПолноеИмя());
	
	Если Не ПараметрыВыполнения.Свойство("ИнформацияОТипах") Тогда
		ПараметрыВыполнения.Вставить("ИнформацияОТипах", Новый Соответствие);
	КонецЕсли;
	Информация = ПараметрыВыполнения.ИнформацияОТипах.Получить(ПолноеИмя); // Кэш.
	Если Информация <> Неопределено Тогда
		Возврат Информация;
	КонецЕсли;
	
	Информация = Новый Структура("ПолноеИмя, ПредставлениеЭлемента, ПредставлениеСписка,
	|Вид, Ссылочный, Технический, Разделенный,
	|Иерархический,
	|ЕстьПодчиненные, ИменаПодчиненных,
	|Измерения, Реквизиты, Ресурсы");
	ПараметрыВыполнения.ИнформацияОТипах.Вставить(ПолноеИмя, Информация);
	
	// Заполнение базовой информации.
	Информация.ПолноеИмя = ПолноеИмя;
	
	// Представления: элемента и списка.
	СтандартныеСвойства = Новый Структура("ПредставлениеОбъекта, РасширенноеПредставлениеОбъекта, ПредставлениеСписка, РасширенноеПредставлениеСписка");
	ЗаполнитьЗначенияСвойств(СтандартныеСвойства, ОбъектМетаданных);
	Если ЗначениеЗаполнено(СтандартныеСвойства.ПредставлениеОбъекта) Тогда
		Информация.ПредставлениеЭлемента = СтандартныеСвойства.ПредставлениеОбъекта;
	ИначеЕсли ЗначениеЗаполнено(СтандартныеСвойства.РасширенноеПредставлениеОбъекта) Тогда
		Информация.ПредставлениеЭлемента = СтандартныеСвойства.РасширенноеПредставлениеОбъекта;
	Иначе
		Информация.ПредставлениеЭлемента = ОбъектМетаданных.Представление();
	КонецЕсли;
	Если ЗначениеЗаполнено(СтандартныеСвойства.ПредставлениеСписка) Тогда
		Информация.ПредставлениеСписка = СтандартныеСвойства.ПредставлениеСписка;
	ИначеЕсли ЗначениеЗаполнено(СтандартныеСвойства.РасширенноеПредставлениеСписка) Тогда
		Информация.ПредставлениеСписка = СтандартныеСвойства.РасширенноеПредставлениеСписка;
	Иначе
		Информация.ПредставлениеСписка = ОбъектМетаданных.Представление();
	КонецЕсли;
	
	// Вид и его свойства.
	Информация.Вид = Лев(Информация.ПолноеИмя, СтрНайти(Информация.ПолноеИмя, ".")-1);
	Если Информация.Вид = "СПРАВОЧНИК"
		Или Информация.Вид = "ДОКУМЕНТ"
		Или Информация.Вид = "ПЕРЕЧИСЛЕНИЕ"
		Или Информация.Вид = "ПЛАНВИДОВХАРАКТЕРИСТИК"
		Или Информация.Вид = "ПЛАНСЧЕТОВ"
		Или Информация.Вид = "ПЛАНВИДОВРАСЧЕТА"
		Или Информация.Вид = "БИЗНЕСПРОЦЕСС"
		Или Информация.Вид = "ЗАДАЧА"
		Или Информация.Вид = "ПЛАНОБМЕНА" Тогда
		Информация.Ссылочный = Истина;
	Иначе
		Информация.Ссылочный = Ложь;
	КонецЕсли;
	
	Если Информация.Вид = "СПРАВОЧНИК"
		Или Информация.Вид = "ПЛАНВИДОВХАРАКТЕРИСТИК" Тогда
		Информация.Иерархический = ОбъектМетаданных.Иерархический;
	ИначеЕсли Информация.Вид = "ПЛАНСЧЕТОВ" Тогда
		Информация.Иерархический = Истина;
	Иначе
		Информация.Иерархический = Ложь;
	КонецЕсли;
	
	Информация.ЕстьПодчиненные = Ложь;
	Если Информация.Вид = "СПРАВОЧНИК"
		Или Информация.Вид = "ПЛАНВИДОВХАРАКТЕРИСТИК"
		Или Информация.Вид = "ПЛАНОБМЕНА"
		Или Информация.Вид = "ПЛАНСЧЕТОВ"
		Или Информация.Вид = "ПЛАНВИДОВРАСЧЕТА" Тогда
		Для Каждого Справочник Из Метаданные.Справочники Цикл
			Если Справочник.Владельцы.Содержит(ОбъектМетаданных) Тогда
				Если Информация.ЕстьПодчиненные = Ложь Тогда
					Информация.ЕстьПодчиненные = Истина;
					Информация.ИменаПодчиненных = Новый Массив;
				КонецЕсли;
				Информация.ИменаПодчиненных.Добавить(Справочник.ПолноеИмя());
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Если Информация.ПолноеИмя = "СПРАВОЧНИК.ИДЕНТИФИКАТОРЫОБЪЕКТОВМЕТАДАННЫХ"
		Или Информация.ПолноеИмя = "СПРАВОЧНИК.ПРЕДОПРЕДЕЛЕННЫЕВАРИАНТЫОТЧЕТОВ" Тогда
		Информация.Технический = Истина;
		Информация.Разделенный = Ложь;
	Иначе
		Информация.Технический = Ложь;
		Если Не ПараметрыВыполнения.Свойство("МодельСервиса") Тогда
			ПараметрыВыполнения.Вставить("МодельСервиса", ОбщегоНазначенияПовтИсп.РазделениеВключено());
			Если ПараметрыВыполнения.МодельСервиса Тогда
				ПараметрыВыполнения.Вставить("ВОбластиДанных", ИспользованиеРазделителяСеанса());
				ПараметрыВыполнения.Вставить("РазделительОсновныхДанных",        ОбщегоНазначенияПовтИсп.РазделительОсновныхДанных());
				ПараметрыВыполнения.Вставить("РазделительВспомогательныхДанных", ОбщегоНазначенияПовтИсп.РазделительВспомогательныхДанных());
			КонецЕсли;
		КонецЕсли;
		Если ПараметрыВыполнения.МодельСервиса Тогда
			Информация.Разделенный = ЭтоРазделенныйОбъектМетаданных(ОбъектМетаданных, ПараметрыВыполнения.РазделительОсновныхДанных)
				Или ЭтоРазделенныйОбъектМетаданных(ОбъектМетаданных, ПараметрыВыполнения.РазделительВспомогательныхДанных);
		КонецЕсли;
	КонецЕсли;
	
	Информация.Измерения = Новый Структура;
	Информация.Реквизиты = Новый Структура;
	Информация.Ресурсы = Новый Структура;
	
	ВидыРеквизитов = Новый Структура("СтандартныеРеквизиты, Реквизиты, Измерения, Ресурсы");
	ЗаполнитьЗначенияСвойств(ВидыРеквизитов, ОбъектМетаданных);
	Для Каждого КлючИЗначение Из ВидыРеквизитов Цикл
		Коллекция = КлючИЗначение.Значение;
		Если ТипЗнч(Коллекция) = Тип("КоллекцияОбъектовМетаданных") Тогда
			КудаПишем = ?(Информация.Свойство(КлючИЗначение.Ключ), Информация[КлючИЗначение.Ключ], Информация.Реквизиты);
			Для Каждого Реквизит Из Коллекция Цикл
				КудаПишем.Вставить(Реквизит.Имя, ИнформацияПоРеквизиту(Реквизит));
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Информация;
КонецФункции

Функция ИнформацияПоРеквизиту(МетаданныеРеквизита)
	// ОписаниеСтандартногоРеквизита
	// ОбъектМетаданных: Измерение
	// ОбъектМетаданных: Ресурс
	// ОбъектМетаданных: Реквизит
	Информация = Новый Структура("Ведущее, Представление, Формат, Тип, ЗначениеПоУмолчанию, ЗаполнятьИзДанныхЗаполнения");
	ЗаполнитьЗначенияСвойств(Информация, МетаданныеРеквизита);
	Информация.Представление = МетаданныеРеквизита.Представление();
	Если Информация.ЗаполнятьИзДанныхЗаполнения = Истина Тогда
		Информация.ЗначениеПоУмолчанию = МетаданныеРеквизита.ЗначениеЗаполнения;
	Иначе
		Информация.ЗначениеПоУмолчанию = МетаданныеРеквизита.Тип.ПривестиЗначение();
	КонецЕсли;
	Возврат Информация;
КонецФункции

Функция ВычислитьЗначениеДанныхПоПути(Знач Данные, Знач ПутьДанных)
	Результат = Данные;
	
	Имена = СтрРазделить(ПутьДанных, ".", Ложь);
	Для Каждого ИмяРеквизита Из Имена Цикл
		Тест = Новый Структура(ИмяРеквизита, Неопределено);
		ЗаполнитьЗначенияСвойств(Тест, Результат);
		Если Тест[ИмяРеквизита] = Неопределено Тогда
			Тест[ИмяРеквизита] = -1;
			ЗаполнитьЗначенияСвойств(Тест, Результат);
			Если Тест[ИмяРеквизита] = Неопределено Тогда
				ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ВернутьСтр("ru='Ошибка вычисления %1 для объекта %2. Реквизит %3 не найден'"),
					ПутьДанных, Данные, ИмяРеквизита);
			КонецЕсли;
		КонецЕсли;
		
		Результат = Тест[ИмяРеквизита];
		Если Результат = Неопределено Тогда // Не можем дальше читать.
			Возврат Неопределено;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

// Поиск дублей для указанного значения.
//
// Параметры:
//     ОбластьПоиска - Строка - Имя таблицы данных (полное имя метаданных) области поиска.
//                              Например "Справочник.Номенклатура". Поддерживается поиск в справочниках, 
//                              планах видов характеристик, видах расчетов, планах счетов.
//
//     Элемент - Произвольный - объект с данными элемента, для которого производится поиск дублей
//
//     ДополнительныеПараметры - Произвольный - Параметр для передачи в обработчики событий менеджера
//
// Возвращаемое значение:
//     ТаблицаЗначений - содержит строки с описаниями дублей.
// 
Функция НайтиДублиЭлемента(Знач ОбластьПоиска, Знач ЭталонныйОбъект, Знач ДополнительныеПараметры) Экспорт
	
	ПараметрыПоискаДублей = Новый Структура;
	ПараметрыПоискаДублей.Вставить("КомпоновщикПредварительногоОтбора");
	ПараметрыПоискаДублей.Вставить("ОбластьПоискаДублей", ОбластьПоиска);
	ПараметрыПоискаДублей.Вставить("УчитыватьПрикладныеПравила", Истина);
	
	// Из параметров
	ПараметрыПоискаДублей.Вставить("ПравилаПоиска", Новый ТаблицаЗначений);
	ПараметрыПоискаДублей.ПравилаПоиска.Колонки.Добавить("Реквизит", Новый ОписаниеТипов("Строка"));
	ПараметрыПоискаДублей.ПравилаПоиска.Колонки.Добавить("Правило",  Новый ОписаниеТипов("Строка"));
	
	// См. Обработка.ПоискИУдалениеДублей
	ПараметрыПоискаДублей.КомпоновщикПредварительногоОтбора = Новый КомпоновщикНастроекКомпоновкиДанных;
	МетаОбласть = Метаданные.НайтиПоПолномуИмени(ОбластьПоиска);
	ДоступныеРеквизитыОтбора = ДоступныеИменаМетаРеквизитовОтбора(МетаОбласть.СтандартныеРеквизиты);
	ДоступныеРеквизитыОтбора = ?(ПустаяСтрока(ДоступныеРеквизитыОтбора), ",", ДоступныеРеквизитыОтбора)
		+ ДоступныеИменаМетаРеквизитовОтбора(МетаОбласть.Реквизиты);
	
	СхемаКомпоновки = Новый СхемаКомпоновкиДанных;
	ИсточникДанных = СхемаКомпоновки.ИсточникиДанных.Добавить();
	ИсточникДанных.ТипИсточникаДанных = "Local";
	
	НаборДанных = СхемаКомпоновки.НаборыДанных.Добавить(Тип("НаборДанныхЗапросСхемыКомпоновкиДанных"));
	НаборДанных.Запрос = "ВЫБРАТЬ " + Сред(ДоступныеРеквизитыОтбора, 2) + " ИЗ " + ОбластьПоиска;
	НаборДанных.АвтоЗаполнениеДоступныхПолей = Истина;
	
	ПараметрыПоискаДублей.КомпоновщикПредварительногоОтбора.Инициализировать( Новый ИсточникДоступныхНастроекКомпоновкиДанных(СхемаКомпоновки) );
	
	// Вызов прикладного кода
	ОбработкаПоиска = Обработки.ПоискИУдалениеДублей.Создать();
	
	МенеджерОбластиПоиска = ОбработкаПоиска.МенеджерОбластиПоискаДублей(ОбластьПоиска);
	ИспользоватьПрикладныеПравила = ОбработкаПоиска.ЕстьПрикладныеПравилаОбластиПоискаДублей(МенеджерОбластиПоиска);
	Если ИспользоватьПрикладныеПравила Тогда
		ПрикладныеПараметры = Новый Структура;
		ПрикладныеПараметры.Вставить("ПравилаПоиска",        ПараметрыПоискаДублей.ПравилаПоиска);
		ПрикладныеПараметры.Вставить("КомпоновщикОтбора",    ПараметрыПоискаДублей.КомпоновщикПредварительногоОтбора);
		ПрикладныеПараметры.Вставить("ОграниченияСравнения", Новый Массив);
		ПрикладныеПараметры.Вставить("КоличествоЭлементовДляСравнения", 1500);
		
		МенеджерОбластиПоиска.ПараметрыПоискаДублей(ПрикладныеПараметры, ДополнительныеПараметры);
		
		ПараметрыПоискаДублей.Вставить("ДополнительныеПараметры", ДополнительныеПараметры);
	КонецЕсли;
	
	ГруппыДублей = ОбработкаПоиска.ГруппыДублей(ПараметрыПоискаДублей, ЭталонныйОбъект);
	Результат = ГруппыДублей.ТаблицаДублей;
	
	// Там ровно одна группа, возвращаем нужные элементы
	Для Каждого Строка Из Результат.НайтиСтроки(Новый Структура("Родитель", Неопределено)) Цикл
		Результат.Удалить(Строка);
	КонецЦикла;
	ПустаяСсылка = МенеджерОбластиПоиска.ПустаяСсылка();
	Для Каждого Строка Из Результат.НайтиСтроки(Новый Структура("Ссылка", ПустаяСсылка)) Цикл
		Результат.Удалить(Строка);
	КонецЦикла;
	
	Возврат Результат; 
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для работы с внешним соединением

// Возвращает имя COM-класса для работы с 1С:Предприятием 8 через COM-соединение.
//
Функция ИмяCOMСоединителя() Экспорт
	
	СистемнаяИнфо = Новый СистемнаяИнформация;
	ПодстрокиВерсии = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(
		СистемнаяИнфо.ВерсияПриложения, ".");
	Возврат "v" + ПодстрокиВерсии[0] + ПодстрокиВерсии[1] + ".COMConnector";
	
КонецФункции

// Устанавливает внешнее соединение с информационной базой по переданным параметрам подключения и возвращает указатель на это соединение.
// 
// Параметры:
//  Параметры - Структура - параметры для установки внешнего соединения с информационной базой.
//                          Свойства см. в функции ОбщегоНазначенияКлиентСервер.СтруктураПараметровДляУстановкиВнешнегоСоединения):
//
//    * ВариантРаботыИнформационнойБазы             - Число - Вариант работы информационной базы: 0 - файловый; 1 - клиент-серверный;
//    * КаталогИнформационнойБазы                   - Строка - Каталог информационной базы для файлового режима работы;
//    * ИмяСервера1СПредприятия                     - Строка - Имя сервера1С:Предприятия;
//    * ИмяИнформационнойБазыНаСервере1СПредприятия - Строка - Имя информационной базы на сервере1С:Предприятия;
//    * АутентификацияОперационнойСистемы           - Булево - Признак аутентификации операционной системы при создании внешнего подключения к информационной базе;
//    * ИмяПользователя                             - Строка - Имя пользователя информационной базы;
//    * ПарольПользователя                          - Строка - Пароль пользователя информационной базы.
// 
//  СтрокаСообщенияОбОшибке - Строка - если в процессе установки внешнего соединения возникает ошибка,
//                                     то подробное описание ошибки помещается в этот параметр.
//
// Возвращаемое значение:
//  COMОбъект, Неопределенно -
//    в случае успешной установки внешнего соединения возвращается указатель на COM-объект соединения;
//    в случае ошибки возвращается Неопределенно.
//
Функция УстановитьВнешнееСоединение(Параметры, СтрокаСообщенияОбОшибке = "", ОшибкаПодключенияКомпоненты = Ложь) Экспорт
	Результат = УстановитьВнешнееСоединениеСБазой(Параметры);
	ОшибкаПодключенияКомпоненты = Результат.ОшибкаПодключенияКомпоненты;
	СтрокаСообщенияОбОшибке     = Результат.ПодробноеОписаниеОшибки;
	
	Возврат Результат.Соединение;
КонецФункции

// Устанавливает внешнее соединение с информационной базой по переданным параметрам подключения и возвращает указатель на это соединение
// 
// Параметры:
//  Параметры - Структура - параметры для установки внешнего соединения с информационной базой.
//                          Свойства см. в функции ОбщегоНазначенияКлиентСервер.СтруктураПараметровДляУстановкиВнешнегоСоединения):
//
//	  * ВариантРаботыИнформационнойБазы             - Число  -  Вариант работы информационной базы: 0 - файловый; 1 - клиент-серверный;
//	  * КаталогИнформационнойБазы                   - Строка - Каталог информационной базы для файлового режима работы;
//	  * ИмяСервера1СПредприятия                     - Строка - Имя сервера1С:Предприятия;
//	  * ИмяИнформационнойБазыНаСервере1СПредприятия - Строка - Имя информационной базы на сервере1С:Предприятия;
//	  * АутентификацияОперационнойСистемы           - Булево - Признак аутентификации операционной системы при создании внешнего подключения к информационной базе;
//	  * ИмяПользователя                             - Строка - Имя пользователя информационной базы;
//	  * ПарольПользователя                          - Строка - Пароль пользователя информационной базы.
// 
// Возвращаемое значение:
//  Структура -
//    * Соединение                  - COMОбъект, Неопределено - указатель на COM-объект соединения или Неопределено в случае ошибки;
//    * КраткоеОписаниеОшибки       - Строка - краткое описание ошибки;
//    * ПодробноеОписаниеОшибки     - Строка - подробное описание ошибки;
//    * ОшибкаПодключенияКомпоненты - Булево - флаг ошибки подключения COM.
//
Функция УстановитьВнешнееСоединениеСБазой(Параметры) Экспорт
	
	Результат = Новый Структура("Соединение, КраткоеОписаниеОшибки, ПодробноеОписаниеОшибки, ОшибкаПодключенияКомпоненты",
	Неопределено, "", "", Ложь);
	
	Если ЭтоLinuxСервер() Тогда
		Результат.Соединение = Неопределено;
		Результат.ПодробноеОписаниеОшибки = ВернутьСтр("ru = 'Прямое подключение к информационной базе недоступно на сервере под управлением ОС Linux.'");
		Результат.КраткоеОписаниеОшибки = Результат.ПодробноеОписаниеОшибки;
		Возврат Результат;
	КонецЕсли;
	
	Попытка
		COMConnector = Новый COMObject(ИмяCOMСоединителя()); // "V83.COMConnector"
	Исключение
		Информация = ИнформацияОбОшибке();
		СтрокаСообщенияОбОшибке = ВернутьСтр("ru = 'Не удалось подключится к другой программе: %1'");
		
		Результат.ОшибкаПодключенияКомпоненты = Истина;
		Результат.ПодробноеОписаниеОшибки     = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СтрокаСообщенияОбОшибке, ПодробноеПредставлениеОшибки(Информация));
		Результат.КраткоеОписаниеОшибки       = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СтрокаСообщенияОбОшибке, КраткоеПредставлениеОшибки(Информация));
		
		Возврат Результат;
	КонецПопытки;
	
	Если Параметры.ВариантРаботыИнформационнойБазы = 0 Тогда
		// Файловый режим
		Если ПустаяСтрока(Параметры.КаталогИнформационнойБазы) Тогда
			СтрокаСообщенияОбОшибке = ВернутьСтр("ru = 'Не задано месторасположение каталога информационной базы.'");
			Результат.ПодробноеОписаниеОшибки = СтрокаСообщенияОбОшибке;
			Результат.КраткоеОписаниеОшибки   = СтрокаСообщенияОбОшибке;
			Возврат Результат;
			
		КонецЕсли;
		
		Если Параметры.АутентификацияОперационнойСистемы Тогда
			СтрокаСоединения = "File = ""&КаталогИнформационнойБазы""";
			
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&КаталогИнформационнойБазы", Параметры.КаталогИнформационнойБазы);
			
		Иначе
			СтрокаСоединения = "File = ""&КаталогИнформационнойБазы""; Usr = ""&ИмяПользователя""; Pwd = ""&ПарольПользователя""";
			
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&КаталогИнформационнойБазы", Параметры.КаталогИнформационнойБазы);
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ИмяПользователя",           Параметры.ИмяПользователя);
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ПарольПользователя",        Параметры.ПарольПользователя);
			
		КонецЕсли;
		
	Иначе 
		// Клиент-серверный вариант работы информационной базы
		Если ПустаяСтрока(Параметры.ИмяСервера1СПредприятия) Или ПустаяСтрока(Параметры.ИмяИнформационнойБазыНаСервере1СПредприятия) Тогда
			СтрокаСообщенияОбОшибке = ВернутьСтр("ru = 'Не заданы обязательные параметры подключения: ""Имя сервера""; ""Имя информационной базы на сервере"".'");
			
			Результат.ПодробноеОписаниеОшибки = СтрокаСообщенияОбОшибке;
			Результат.КраткоеОписаниеОшибки   = СтрокаСообщенияОбОшибке;
			Возврат Результат;
			
		КонецЕсли;
		
		Если Параметры.АутентификацияОперационнойСистемы Тогда
			СтрокаСоединения = "Srvr = ""&ИмяСервера1СПредприятия""; Ref = ""&ИмяИнформационнойБазыНаСервере1СПредприятия"";";
			
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ИмяСервера1СПредприятия",                     Параметры.ИмяСервера1СПредприятия);
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ИмяИнформационнойБазыНаСервере1СПредприятия", Параметры.ИмяИнформационнойБазыНаСервере1СПредприятия);
			
		Иначе
			СтрокаСоединения = "Srvr = ""&ИмяСервера1СПредприятия""; Ref = ""&ИмяИнформационнойБазыНаСервере1СПредприятия""; Usr = ""&ИмяПользователя""; Pwd = ""&ПарольПользователя""";
			
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ИмяСервера1СПредприятия",                     Параметры.ИмяСервера1СПредприятия);
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ИмяИнформационнойБазыНаСервере1СПредприятия", Параметры.ИмяИнформационнойБазыНаСервере1СПредприятия);
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ИмяПользователя",                             Параметры.ИмяПользователя);
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ПарольПользователя",                          Параметры.ПарольПользователя);
			
		КонецЕсли;
		
	КонецЕсли;
	
	Попытка
		Результат.Соединение = COMConnector.Connect(СтрокаСоединения);
	Исключение
		Информация = ИнформацияОбОшибке();
		СтрокаСообщенияОбОшибке = ВернутьСтр("ru = 'Не удалось подключиться к другой программе: %1'");
		
		Результат.ОшибкаПодключенияКомпоненты = Истина;
		Результат.ПодробноеОписаниеОшибки     = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СтрокаСообщенияОбОшибке, ПодробноеПредставлениеОшибки(Информация));
		Результат.КраткоеОписаниеОшибки       = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СтрокаСообщенияОбОшибке, КраткоеПредставлениеОшибки(Информация));
		
	КонецПопытки;
	
	Возврат Результат;
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для работы с типами, объектами метаданных и их строковыми представлениями.

// Формирует расширенное представление объекта.
// Расширенное представление объекта складывается из представления объекта, кода и наименования.
// Если для объекта не удалось получить расширенное представление, то возвращается стандартное 
// представление объекта, формируемое платформой.
//
// Пример возвращаемого значения функции:
// "Контрагент 0А-0001234, ООО Телекоммуникационные системы"
//
// Параметры:
//  Объект - СправочникСсылка,
//           ПланСчетовСсылка,
//           ПланОбменаСсылка,
//           ПланВидовХарактеристикСсылка,
//           ПланВидовРасчетаСсылка -  Объект, для которого требуется получить расширенное представление.
//
// Возвращаемое значение:
//  Строка - расширенное представление объекта.
//
Функция РасширенноеПредставлениеОбъекта(Объект) Экспорт
	
	ОбъектМетаданных = Объект.Метаданные();
	
	ИмяБазовогоТипа = ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных);
	
	Если    ИмяБазовогоТипа = ИмяТипаСправочники()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыСчетов()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыОбмена()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыВидовХарактеристик()
		ИЛИ ИмяБазовогоТипа = ИмяТипаПланыВидовРасчета()
		Тогда
		
		Если  ЭтоСтандартныйРеквизит(ОбъектМетаданных.СтандартныеРеквизиты, "Код")
			И ЭтоСтандартныйРеквизит(ОбъектМетаданных.СтандартныеРеквизиты, "Наименование") Тогда
			
			ЗначенияРеквизитов = ЗначенияРеквизитовОбъекта(Объект, "Код, Наименование");
			
			ПредставлениеОбъекта = ?(ПустаяСтрока(ОбъектМетаданных.ПредставлениеОбъекта), 
										?(ПустаяСтрока(ОбъектМетаданных.Синоним), ОбъектМетаданных.Имя, ОбъектМетаданных.Синоним
										),
									ОбъектМетаданных.ПредставлениеОбъекта);
			
			Результат = "[ПредставлениеОбъекта] [Код], [Наименование]";
			Результат = СтрЗаменить(Результат, "[ПредставлениеОбъекта]", ПредставлениеОбъекта);
			Результат = СтрЗаменить(Результат, "[Код]",          ?(ПустаяСтрока(ЗначенияРеквизитов.Код), "<>", ЗначенияРеквизитов.Код));
			Результат = СтрЗаменить(Результат, "[Наименование]", ?(ПустаяСтрока(ЗначенияРеквизитов.Наименование), "<>", ЗначенияРеквизитов.Наименование));
			
		Иначе
			
			Результат = Строка(Объект);
			
		КонецЕсли;
		
	Иначе
		
		Результат = Строка(Объект);
		
	КонецЕсли;
	
	Возврат Результат;
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

////////////////////////////////////////////////////////////////////////////////
// Получение обработчиков серверных событий.

// Возвращает структуру для добавления обязательного события.
//
// Возвращаемое значение:
//  Структура - 
//    * ИмяСобытия - Строка - представление события.
//       Пример: "СтандартныеПодсистемы.ОбновлениеВерсииИБ\ПриДобавленииОбработчиковОбновления".
//
//    * Обязательное - Булево, если Истина, то для данного события обязательно объявление обработчиков.
//
Функция НовоеСобытие() Экспорт
	
	Возврат Новый Структура("Имя, Обязательное", "", Ложь);

КонецФункции

// Возвращает обработчики указанного серверного события.
//
// Параметры:
//  Событие  - Строка, например,
//             "СтандартныеПодсистемы.ОбновлениеВерсииИБ\ПриДобавленииОбработчиковОбновления".
//
// Возвращаемое значение:
//  ФиксированныйМассив - со значениями типа ФиксированнаяСтруктура со свойствами:
//    * Версия - Строка      - версия обработчика, например, "2.1.3.4". Пустая строка, если не указана.
//    * Модуль - ОбщийМодуль - серверный общий модуль.
// 
Функция ОбработчикиСобытия(Событие) Экспорт
	
	Возврат СтандартныеПодсистемыПовтИсп.ОбработчикиСерверногоСобытия(Событие, Ложь);
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Устаревшие процедуры и функции

// Устарела. Следует использовать ПриСозданииНаСервере.
Функция ПриСозданииФормыНаСервере(Форма, СтандартнаяОбработка, Отказ) Экспорт
	
	Возврат Не ПриСозданииНаСервере(Форма, Отказ, СтандартнаяОбработка);
	
КонецФункции

// Устарела. Следует использовать ЗначенияРеквизитовОбъекта.
Функция ПолучитьЗначенияРеквизитов(Ссылка, ИменаРеквизитов) Экспорт

	Возврат ЗначенияРеквизитовОбъекта(Ссылка, ИменаРеквизитов);
	
КонецФункции

// Устарела. Следует использовать ЗначениеРеквизитаОбъекта.
Функция ПолучитьЗначениеРеквизита(Ссылка, ИмяРеквизита) Экспорт
	
	Возврат ЗначениеРеквизитаОбъекта(Ссылка, ИмяРеквизита);
	
КонецФункции 

// Устарела. Следует использовать ЕстьСсылкиНаОбъект.
Функция ОбъектИспользуютсяВБазеДанных(Знач СсылкаИлиМассивСсылок, Знач ИскатьСредиСлужебныхОбъектов = Ложь) Экспорт
	Возврат ЕстьСсылкиНаОбъект(СсылкаИлиМассивСсылок, ИскатьСредиСлужебныхОбъектов);
КонецФункции

// Устарела. Следует использовать ОбщегоНазначенияКлиентСервер.КлючиСтруктурыВСтроку.
Функция КлючиСтруктурыВСтроку(Структура, Разделитель = ",") Экспорт
	
	Возврат ОбщегоНазначенияКлиентСервер.КлючиСтруктурыВСтроку(Структура, Разделитель);
	
КонецФункции

// Устарела. Следует использовать РаботаВБезопасномРежиме.ВыполнитьМетодКонфигурации().
Процедура ВыполнитьБезопасно(ИмяЭкспортнойПроцедуры, Параметры = Неопределено, ОбластьДанных = Неопределено) Экспорт
	
	ВыполненаУстановкаРазделенияСеанса = Ложь;
	Если ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
		Если Не ОбщегоНазначенияПовтИсп.СеансЗапущенБезРазделителей() Тогда
			Если ОбластьДанных = Неопределено Тогда
				ОбластьДанных = ЗначениеРазделителяСеанса();
			Иначе 
				Если ОбластьДанных <> ЗначениеРазделителяСеанса() Тогда
					ВызватьИсключение(ВернутьСтр("ru = 'В данном сеансе недопустимо обращение к данным из другой области данных!'"));
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		Если ОбластьДанных <> Неопределено
			И (НЕ ИспользованиеРазделителяСеанса() ИЛИ ОбластьДанных <> ЗначениеРазделителяСеанса()) Тогда
			УстановитьРазделениеСеанса(Истина, ОбластьДанных);
			ВыполненаУстановкаРазделенияСеанса = Истина;
		КонецЕсли;
	КонецЕсли;
	
	Попытка
		
		РаботаВБезопасномРежиме.ВыполнитьМетодКонфигурации(ИмяЭкспортнойПроцедуры, Параметры);
		
		Если ВыполненаУстановкаРазделенияСеанса Тогда
			УстановитьРазделениеСеанса(Ложь);
		КонецЕсли;
		
	Исключение
		
		Если ВыполненаУстановкаРазделенияСеанса Тогда
			УстановитьРазделениеСеанса(Ложь);
		КонецЕсли;
		
		ВызватьИсключение;
		
	КонецПопытки;
	
КонецПроцедуры

// Устарела. Следует использовать РаботаВБезопасномРежиме.ПроверитьИмяМетодаКонфигурации().
Функция ПроверитьИмяЭкспортнойПроцедуры(Знач ИмяЭкспортнойПроцедуры, ТекстСообщения) Экспорт
	
	Попытка
		РаботаВБезопасномРежиме.ПроверитьИмяМетодаКонфигурации(ИмяЭкспортнойПроцедуры);
		Возврат Истина;
	Исключение
		ТекстСообщения = КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
		Возврат Ложь;
	КонецПопытки;
	
КонецФункции

Функция ИмяКоллекции(ПолноеИмя)
	
	ПозицияТочки = СтрНайти(ПолноеИмя, ".");
	
	Если ПозицияТочки > 0 Тогда
		Возврат Лев(ПолноеИмя, ПозицияТочки - 1);
	КонецЕсли;
	
	Возврат "";
	
КонецФункции

Функция ОписаниеСпискаБлокировки(Знач Блокировка)
	// Только уникальные значения
	Обработанные = Новый Соответствие;
	
	СтрокаОписания = "";
	Для Каждого Элемент Из Блокировка Цикл
		Для Каждого Поле Из Элемент.Поля Цикл
			Значение = Поле.Значение;
			Если Обработанные[Значение] = Неопределено Тогда
				СтрокаОписания = СтрокаОписания + Символы.ПС + Поле.Значение;
				Обработанные[Значение] = Истина;
			КонецЕсли
		КонецЦикла;
	КонецЦикла;
	
	Возврат СокрЛ(СтрокаОписания);
КонецФункции

Процедура ДобавитьРезультатЗамены(Таблица, Знач Ссылка, Знач ОписаниеОшибки)
	Строка = Таблица.Добавить();
	
	Строка.Ссылка = Ссылка;
	
	Строка.ПредставлениеОбъектаОшибки = ОписаниеОшибки.ПредставлениеОбъектаОшибки;
	Строка.ОбъектОшибки               = ОписаниеОшибки.ОбъектОшибки;
	Строка.ТекстОшибки                = ОписаниеОшибки.ТекстОшибки;
	Строка.ТипОшибки                  = ОписаниеОшибки.ТипОшибки;
	
КонецПроцедуры

Процедура УстановитьПараметрыЗаписи(Объект, Знач ПараметрыЗаписи)
	
	ТестРеквизита = Новый Структура("ОбменДанными");
	ЗаполнитьЗначенияСвойств(ТестРеквизита, Объект);
	Если ТипЗнч(ТестРеквизита.ОбменДанными) = Тип("ПараметрыОбменаДанными") Тогда
		Объект.ОбменДанными.Загрузка = ПараметрыЗаписи.НеПроверять;
		Объект.ОбменДанными.Получатели.АвтоЗаполнение = Не ПараметрыЗаписи.НеПроверять;
	КонецЕсли;
	
	Объект.ДополнительныеСвойства.Вставить("ОтключитьМеханизмРегистрацииОбъектов", ПараметрыЗаписи.НеПроверять);
	
КонецПроцедуры
	
Процедура ДобавитьОбъектыБлокировкиКонстанты(Блокировка, Знач СтрокиИспользования)
	
	Для Каждого Строка Из СтрокиИспользования Цикл
		Блокировка.Добавить(Строка.Метаданные.ПолноеИмя());
	КонецЦикла;
	
КонецПроцедуры

Процедура ДобавитьОбъектыБлокировкиОбъекты(Блокировка, Знач СтрокиИспользования)
	
	Для Каждого МестоИспользования Из СтрокиИспользования Цикл
		Данные = МестоИспользования.Данные;
		Мета   = МестоИспользования.Метаданные;
		
		// Сам элемент
		Блокировка.Добавить(Мета.ПолноеИмя()).УстановитьЗначение("Ссылка", Данные);
		
		// Движения 
		ОписаниеДвижений = ОписаниеДвижений(Мета);
		Для Каждого Элемент Из ОписаниеДвижений Цикл
			// Все по регистратору
			Блокировка.Добавить(Элемент.ПространствоБлокировки + ".НаборЗаписей").УстановитьЗначение("Регистратор", Данные);
			
			// Все кандидаты - измерения для сохранения итогов
			Для Каждого КлючЗначение Из Элемент.СписокИзмерений Цикл
				ТипИзмерения  = КлючЗначение.Значение;
				Для Каждого МестоИспользования Из СтрокиИспользования Цикл
					ТекущаяСсылка = МестоИспользования.Ссылка;
					Если ТипИзмерения.СодержитТип(ТипЗнч(ТекущаяСсылка)) Тогда
						Блокировка.Добавить(Элемент.ПространствоБлокировки).УстановитьЗначение(КлючЗначение.Ключ, МестоИспользования.Ссылка);
					КонецЕсли;
				КонецЦикла;
			КонецЦикла;
		КонецЦикла;
		
		// Последовательности
		ОписаниеПоследовательностей = ОписаниеПоследовательностей(Мета);
		Для Каждого Элемент Из ОписаниеПоследовательностей Цикл
			Блокировка.Добавить(Элемент.ПространствоБлокировки).УстановитьЗначение("Регистратор", Данные);
			
			Для Каждого КлючЗначение Из Элемент.СписокИзмерений Цикл
				ТипИзмерения  = КлючЗначение.Значение;
				Для Каждого МестоИспользования Из СтрокиИспользования Цикл
					ТекущаяСсылка = МестоИспользования.Ссылка;
					Если ТипИзмерения.СодержитТип(ТипЗнч(ТекущаяСсылка)) Тогда
						Блокировка.Добавить(Элемент.ПространствоБлокировки).УстановитьЗначение(КлючЗначение.Ключ, ТекущаяСсылка);
					КонецЕсли;
				КонецЦикла;
			КонецЦикла;
		КонецЦикла;
	
	КонецЦикла;

КонецПроцедуры

Процедура ДобавитьОбъектыБлокировкиНаборы(Блокировка, Знач СтрокиИспользования)
	
	Для Каждого МестоИспользования Из СтрокиИспользования Цикл
		Данные = МестоИспользования.Данные;
		Мета   = МестоИспользования.Метаданные; 
		
		ОписаниеНабора = ОписаниеКлючаЗаписи(Мета);
		НаборЗаписей = ОписаниеНабора.НаборЗаписей;
		
		Для Каждого КлючЗначение Из ОписаниеНабора.СписокИзмерений Цикл
			ТипИзмерения = КлючЗначение.Значение;
			Имя          = КлючЗначение.Ключ;
			Значение     = Данные[Имя];
			
			Для Каждого Строка Из СтрокиИспользования Цикл
				ТекущаяСсылка = Строка.Ссылка;
				Если ТипИзмерения.СодержитТип(ТипЗнч(ТекущаяСсылка)) Тогда
					Блокировка.Добавить(ОписаниеНабора.ПространствоБлокировки).УстановитьЗначение(Имя, ТекущаяСсылка);
				КонецЕсли;
			КонецЦикла;
			
			НаборЗаписей.Отбор[Имя].Установить(Значение);
		КонецЦикла;
		
	КонецЦикла;
	
КонецПроцедуры

// Служебная. Запускает фоновые задания при замене ссылок.
Процедура ФоновыйРасчетКоличестваВхождений(Знач НаборСсылок, Знач АдресРезультата) Экспорт
	
	ТаблицаПоиска = МестаИспользования(НаборСсылок);
	
	Фильтр = Новый Структура("ВспомогательныеДанные", Ложь);
	АктуальныеСтроки = ТаблицаПоиска.НайтиСтроки(Фильтр);
	
	Результат = ТаблицаПоиска.Скопировать(АктуальныеСтроки, "Ссылка");
	Результат.Колонки.Добавить("Вхождения", Новый ОписаниеТипов("Число"));
	Результат.ЗаполнитьЗначения(1, "Вхождения");
	
	Результат.Свернуть("Ссылка", "Вхождения");
	Для Каждого Ссылка Из НаборСсылок Цикл
		Если Результат.Найти(Ссылка, "Ссылка") = Неопределено Тогда
			Результат.Добавить().Ссылка = Ссылка;
		КонецЕсли;
	КонецЦикла;
	
	ПоместитьВоВременноеХранилище(Результат, АдресРезультата);
КонецПроцедуры

// См. Обработка.ПоискИУдалениеДублей
Функция ДоступныеИменаМетаРеквизитовОтбора(Знач МетаКоллекция)
	Результат = "";
	ТипХранилища = Тип("ХранилищеЗначения");
	
	Для Каждого МетаРеквизит Из МетаКоллекция Цикл
		ЭтоХранилище = МетаРеквизит.Тип.СодержитТип(ТипХранилища);
		Если Не ЭтоХранилище Тогда
			Результат = Результат + "," + МетаРеквизит.Имя;
		КонецЕсли
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Функции для работы с журналом регистрации

// Процедура пакетной записи сообщений в журнал регистрации
// 
// Параметры: СобытияДляЖурналаРегистрации - массив структур, клиентская глобальная переменная 
// Каждая структура - сообщение для журнала регистрации.
// После записи переменная очищается.
Процедура ЗаписатьСобытияВЖурналРегистрации(СобытияДляЖурналаРегистрации) Экспорт
	
	Если ТипЗнч(СобытияДляЖурналаРегистрации) <> Тип("СписокЗначений") Тогда
		Возврат;
	КонецЕсли;	
	
	Если СобытияДляЖурналаРегистрации.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого СообщениеЖурнала Из СобытияДляЖурналаРегистрации Цикл
		ЗначениеСообщения = СообщениеЖурнала.Значение;
		ИмяСобытия = ЗначениеСообщения.ИмяСобытия;
		УровеньСобытия = УровеньСобытияПоПредставлению(ЗначениеСообщения.ПредставлениеУровня);
		ДатаСобытия = ТекущаяДатаСеанса();
		Если ЗначениеСообщения.Свойство("ДатаСобытия") И ЗначениеЗаполнено(ЗначениеСообщения.ДатаСобытия) Тогда
			ДатаСобытия = ЗначениеСообщения.ДатаСобытия;
		КонецЕсли;
		Комментарий = Строка(ДатаСобытия) + " " + ЗначениеСообщения.Комментарий;
		ЗаписьЖурналаРегистрации(ИмяСобытия, УровеньСобытия,,, Комментарий);
	КонецЦикла;
	СобытияДляЖурналаРегистрации.Очистить();
	
КонецПроцедуры

// Включить запись уровней событий СписокУровней в журнале регистрации.
//
// Параметры: УровниСобытий - СписокЗначений - наименования уровней регистрации событий, 
//                                             которые необходимо включить
//
Процедура ВключитьИспользованиеЖурналаРегистрации(СписокУровней = Неопределено) Экспорт
	
	МассивУровней = Новый Массив();
	Если СписокУровней = Неопределено Тогда
		МассивУровней.Добавить(УровеньЖурналаРегистрации.Информация);
		МассивУровней.Добавить(УровеньЖурналаРегистрации.Ошибка);
		МассивУровней.Добавить(УровеньЖурналаРегистрации.Предупреждение);
		МассивУровней.Добавить(УровеньЖурналаРегистрации.Примечание);
	Иначе
		МассивУровней = УровниСобытияЖурналаРегистрацииПоСтроке(СписокУровней);
	КонецЕсли;
		
	МонопольныйРежимУстановленРанее = МонопольныйРежим();
	УстановитьМонопольныйРежим(Истина);
	
	Попытка
		УстановитьИспользованиеЖурналаРегистрации(МассивУровней);
	Исключение
		Если Не МонопольныйРежимУстановленРанее Тогда
			УстановитьМонопольныйРежим(Ложь);
		КонецЕсли;
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Проверяет, включена ли регистрация событий УровниСобытий в журнале регистрации.
//
// Параметры: 
//   УровниСобытий - СписокЗначений - список строк с уровнями регистрации событий журнала регистрации, 
//                                    для которых необходимо проверить, что они включены.
//                                    Если Неопределено, то проверяются все уровни событий.
//
// Возвращаемое значение: 
//   Булево - Истина, когда заданные режимы включены. Иначе - Ложь.
//
Функция ПроверитьВключениеЖурналаРегистрации(УровниСобытий = Неопределено) Экспорт	
	
	УстановленныеУровниСобытий = ПолучитьИспользованиеЖурналаРегистрации();
	Если УровниСобытий = Неопределено Тогда
		Возврат УстановленныеУровниСобытий.Количество() = 4; // включены все уровни событий?
	КонецЕсли;
	
	ИменаУровнейСобытий = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(УровниСобытий);
	Для Каждого Название Из ИменаУровнейСобытий Цикл
		УровеньСобытия = УровеньСобытияПоПредставлению(Название);
		Если УстановленныеУровниСобытий.Найти(УровеньСобытия) = Неопределено Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

// Процедура инициализации разделенной информационной базы
// 
// Параметры:
// ВключитьРазделение - Булево - признак включения разделения в
// информационной базе
//
Процедура УстановитьПараметрыРазделенияИнформационныйБазы(Знач ВключитьРазделение = Ложь) Экспорт
	
	Если ВключитьРазделение Тогда
		Константы.ИспользоватьРазделениеПоОбластямДанных.Установить(Истина);
	Иначе
		Константы.ИспользоватьРазделениеПоОбластямДанных.Установить(Ложь);
	КонецЕсли;
	
КонецПроцедуры

// Устанавливает значение двух дополнительных констант.
// Имена констант строго регламентированы и должны соответствовать шаблонам:
//  <Имя основной константы>ВМоделиСервиса
//  <Имя основной константы>ВЛокальномРежиме
//
// Параметры:
//  Значение – Булево – значение основной константы.
//  ИмяКонстанты – Строка – имя основной константы.
//
Процедура УстановитьЗначенияДополнительныхКонстант(Знач Значение, Знач ИмяКонстанты) Экспорт
	
	Если Значение = Истина Тогда
		
		РазделениеВключено = ОбщегоНазначенияПовтИсп.РазделениеВключено();
		
		Константы[ИмяКонстанты + "ВМоделиСервиса"].Установить(РазделениеВключено);
		Константы[ИмяКонстанты + "ВЛокальномРежиме"].Установить(Не РазделениеВключено);
		
	Иначе
		
		Константы[ИмяКонстанты + "ВМоделиСервиса"].Установить(Ложь);
		Константы[ИмяКонстанты + "ВЛокальномРежиме"].Установить(Ложь);
		
	КонецЕсли;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ВСПОМОГАТЕЛЬНЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ

Функция УровеньСобытияПоПредставлению(ПредставлениеУровня)
	Если ПредставлениеУровня = "Информация" Тогда
		Возврат УровеньЖурналаРегистрации.Информация;
	ИначеЕсли ПредставлениеУровня = "Ошибка" Тогда
		Возврат УровеньЖурналаРегистрации.Ошибка;
	ИначеЕсли ПредставлениеУровня = "Предупреждение" Тогда
		Возврат УровеньЖурналаРегистрации.Предупреждение; 
	ИначеЕсли ПредставлениеУровня = "Примечание" Тогда
		Возврат УровеньЖурналаРегистрации.Примечание;
	КонецЕсли;	
КонецФункции

Функция УровниСобытияЖурналаРегистрацииПоСтроке(СписокУровней)
	МассивНазванийУровней = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(СписокУровней);
	МассивУровней = Новый Массив;
	Для Каждого Название Из МассивНазванийУровней Цикл
		МассивУровней.Добавить(УровеньСобытияПоПредставлению(Название));
	КонецЦикла;
	Возврат МассивУровней;
КонецФункции

Функция ПлатформаПоддерживаетТаймаутыСети() Экспорт
	
	СистемнаяИнформация = Новый СистемнаяИнформация;
	Возврат ОбщегоНазначенияКлиентСервер.СравнитьВерсии(СистемнаяИнформация.ВерсияПриложения, "8.2.16.0") >= 0;
	
КонецФункции
////////////////////////////////////////////////////////////////////////////////
// Общие процедуры и функции для работы с прикладными типами и коллекциями значений

// Объединяет две таблицы значений по условию "И".
// Возвращает таблицу значений, полученную в результате объединения двух таблиц по условию "И".
//
// Параметры:
//  Таблица1         - ТаблицаЗначений - первая таблица значений для объединения
//  Таблица2         - ТаблицаЗначений - вторая таблица значений для объединения
//  ПоляТаблицы      - Строка - поля таблицы, перечисленные через запятую, по которым будут выполнятся объединение
//  ИмяПоляИтератора - Строка - имя служебной колонки таблицы значений.
//                              Это имя должно быть уникально во множестве имен колонок первой и второй таблиц.
//                              Переменная ПоляТаблицы не должна содержать этого имени. 
//                              Значение по умолчанию "ИтераторПоляТаблицы"
// 
// Возвращаемое значение:
//  ТаблицаЗначений -  таблица значений, полученная в результате объединения двух таблиц по условию "И"
//
Функция ОбъединитьТаблицыПоУсловиюИ(Таблица1, Таблица2, Знач ПоляТаблицы, ИмяПоляИтератора = "ИтераторПоляТаблицы") Экспорт
	
	Таблица1.Свернуть(ПоляТаблицы);
	Таблица2.Свернуть(ПоляТаблицы);
	
	ДобавитьИтераторТаблице(Таблица1, +1, ИмяПоляИтератора);
	ДобавитьИтераторТаблице(Таблица2, -1, ИмяПоляИтератора);
	
	ТаблицаРезультат = Таблица1.Скопировать();
	
	ОбщегоНазначенияКлиентСервер.ДополнитьТаблицу(Таблица2, ТаблицаРезультат);
	
	ТаблицаРезультат.Свернуть(ПоляТаблицы, ИмяПоляИтератора);
	
	ТаблицаРезультат = ТаблицаРезультат.Скопировать(Новый Структура(ИмяПоляИтератора, 0));
	
	ТаблицаРезультат.Колонки.Удалить(ИмяПоляИтератора);
	
	Возврат ТаблицаРезультат;
	
КонецФункции

// Добавляет колонку в таблицу значений. Заполняет колонку переданным значением
//
// Параметры:
//  Таблица           - ТаблицаЗначений - таблица значений для добавления колонки
//  ЗначениеИтератора - Произвольный - значение, которым будет заполнено новое поле таблицы
//  ИмяПоляИтератора  - Строка - имя добавляемого поля
// 
Процедура ДобавитьИтераторТаблице(Таблица, ЗначениеИтератора, ИмяПоляИтератора) Экспорт
	
	Таблица.Колонки.Добавить(ИмяПоляИтератора);
	
	Таблица.ЗаполнитьЗначения(ЗначениеИтератора, ИмяПоляИтератора);
	
КонецПроцедуры

// Выполняет сравнение версий двух однотипных объектов.
//
//  Параметры:
// Данные1 (обязательный). Тип: 
//  СправочникОбъект,
//  ДокументОбъект,
//  ПланВидовХарактеристикОбъект,
//  ПланВидовРасчетаОбъект,
//  ПланСчетовОбъект,
//  ПланОбменаОбъект,
//  БизнесПроцессОбъект,
//  ЗадачаОбъект.
// Первая версия данных для сравнения.
//
// Данные2 (обязательный). Тип: см. тип параметра Данные1
// Вторая версия данных для сравнения.
//
// СписокСвойств (необязательный). Тип: Строка.
// Список свойств объекта и табличных частей, разделенных запятыми. 
// Если параметр задан, то сравнение версий данных будет выполняться согласно 
// заданным свойствам, при этом параметр ИсключаяСвойства будет проигнорирован.
//
// ИсключаяСвойства (необязательный). Тип: Строка.
// Список свойств объекта и табличных частей, разделенных запятыми.
// Если параметр задан, то сравнение версий данных будет выполняться 
// для всех свойств и табличных частей, исключая заданные свойства.
//
// Возвращаемое значение:
// Тип: Булево.
// Возвращает Истина, если версии данных различаются; Ложь, если версии совпадают.
//
Функция ДанныеРазличаются(Данные1, Данные2, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт
	
	Если ТипЗнч(Данные1) <> ТипЗнч(Данные2) Тогда
		Возврат Истина;
	КонецЕсли;
	
	ОбъектМетаданных = Данные1.Метаданные();
	
	Если ЭтоСправочник(ОбъектМетаданных) Тогда
		
		Если Данные1.ЭтоГруппа Тогда
			Объект1 = Справочники[ОбъектМетаданных.Имя].СоздатьГруппу();
		Иначе
			Объект1 = Справочники[ОбъектМетаданных.Имя].СоздатьЭлемент();
		КонецЕсли;
		
		Если Данные2.ЭтоГруппа Тогда
			Объект2 = Справочники[ОбъектМетаданных.Имя].СоздатьГруппу();
		Иначе
			Объект2 = Справочники[ОбъектМетаданных.Имя].СоздатьЭлемент();
		КонецЕсли;
		
	ИначеЕсли ЭтоДокумент(ОбъектМетаданных) Тогда
		
		Объект1 = Документы[ОбъектМетаданных.Имя].СоздатьДокумент();
		Объект2 = Документы[ОбъектМетаданных.Имя].СоздатьДокумент();
		
	ИначеЕсли ЭтоПланВидовХарактеристик(ОбъектМетаданных) Тогда
		
		Если Данные1.ЭтоГруппа Тогда
			Объект1 = ПланыВидовХарактеристик[ОбъектМетаданных.Имя].СоздатьГруппу();
		Иначе
			Объект1 = ПланыВидовХарактеристик[ОбъектМетаданных.Имя].СоздатьЭлемент();
		КонецЕсли;
		
		Если Данные2.ЭтоГруппа Тогда
			Объект2 = ПланыВидовХарактеристик[ОбъектМетаданных.Имя].СоздатьГруппу();
		Иначе
			Объект2 = ПланыВидовХарактеристик[ОбъектМетаданных.Имя].СоздатьЭлемент();
		КонецЕсли;
		
	ИначеЕсли ЭтоПланВидовРасчета(ОбъектМетаданных) Тогда
		
		Объект1 = ПланыВидовРасчета[ОбъектМетаданных.Имя].СоздатьВидРасчета();
		Объект2 = ПланыВидовРасчета[ОбъектМетаданных.Имя].СоздатьВидРасчета();
		
	ИначеЕсли ЭтоПланСчетов(ОбъектМетаданных) Тогда
		
		Объект1 = ПланыСчетов[ОбъектМетаданных.Имя].СоздатьСчет();
		Объект2 = ПланыСчетов[ОбъектМетаданных.Имя].СоздатьСчет();
		
	ИначеЕсли ЭтоПланОбмена(ОбъектМетаданных) Тогда
		
		Объект1 = ПланыОбмена[ОбъектМетаданных.Имя].СоздатьУзел();
		Объект2 = ПланыОбмена[ОбъектМетаданных.Имя].СоздатьУзел();
		
	ИначеЕсли ЭтоБизнесПроцесс(ОбъектМетаданных) Тогда
		
		Объект1 = БизнесПроцессы[ОбъектМетаданных.Имя].СоздатьБизнесПроцесс();
		Объект2 = БизнесПроцессы[ОбъектМетаданных.Имя].СоздатьБизнесПроцесс();
		
	ИначеЕсли ЭтоЗадача(ОбъектМетаданных) Тогда
		
		Объект1 = Задачи[ОбъектМетаданных.Имя].СоздатьЗадачу();
		Объект2 = Задачи[ОбъектМетаданных.Имя].СоздатьЗадачу();
		
	Иначе
		
		ВызватьИсключение ВернутьСтр("ru = 'Задано недопустимое значение параметра [1] метода ОбщегоНазначения.ЗначенияСвойствИзменены.'");
		
	КонецЕсли;
	
	ЗаполнитьЗначенияСвойств(Объект1, Данные1, СписокСвойств, ИсключаяСвойства);
	ЗаполнитьЗначенияСвойств(Объект2, Данные2, СписокСвойств, ИсключаяСвойства);
	
	ТабличныеЧасти = ТабличныеЧастиОбъекта(ОбъектМетаданных);
	
	Если СписокСвойств <> Неопределено Тогда
		
		Для Каждого ТабличнаяЧасть Из ТабличныеЧасти Цикл
			
			Если СтрНайти(СписокСвойств, ТабличнаяЧасть) = 0 Тогда
				Продолжить;
			КонецЕсли;
			
			Объект1[ТабличнаяЧасть].Загрузить(Данные1[ТабличнаяЧасть].Выгрузить());
			Объект2[ТабличнаяЧасть].Загрузить(Данные2[ТабличнаяЧасть].Выгрузить());
			
		КонецЦикла;
		
	ИначеЕсли ИсключаяСвойства <> Неопределено Тогда
		
		Для Каждого ТабличнаяЧасть Из ТабличныеЧасти Цикл
			
			Если СтрНайти(ИсключаяСвойства, ТабличнаяЧасть) <> 0 Тогда
				Продолжить;
			КонецЕсли;
			
			Объект1[ТабличнаяЧасть].Загрузить(Данные1[ТабличнаяЧасть].Выгрузить());
			Объект2[ТабличнаяЧасть].Загрузить(Данные2[ТабличнаяЧасть].Выгрузить());
			
		КонецЦикла;
		
	Иначе
		
		Для Каждого ТабличнаяЧасть Из ТабличныеЧасти Цикл
			
			Объект1[ТабличнаяЧасть].Загрузить(Данные1[ТабличнаяЧасть].Выгрузить());
			Объект2[ТабличнаяЧасть].Загрузить(Данные2[ТабличнаяЧасть].Выгрузить());
			
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат ДанныеИнформационнойБазыСтрокой(Объект1) <> ДанныеИнформационнойБазыСтрокой(Объект2);
	
КонецФункции

Функция ДанныеИнформационнойБазыСтрокой(Данные)
	
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.УстановитьСтроку();
	
	ЗаписатьXML(ЗаписьXML, Данные, НазначениеТипаXML.Явное);
	
	Возврат ЗаписьXML.Закрыть();
	
КонецФункции

Функция ТабличныеЧастиОбъекта(ОбъектМетаданных)
	
	Результат = Новый Массив;
	
	Для Каждого ТабличнаяЧасть Из ОбъектМетаданных.ТабличныеЧасти Цикл
		
		Результат.Добавить(ТабличнаяЧасть.Имя);
		
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Общие процедуры и функции 

// Функция возвращает ссылку на текущего пользователя базы данных,
// установленного по учетной записи пользователя конфигурации.
//
// Возвращаемое значение:
//  СправочникСсылка.Пользователи
//
Функция ТекущийПользователь() Экспорт
	
	Возврат Пользователи.ТекущийПользователь();
	
КонецФункции 

// Создает новый экземпляр объекта Структура, заполняет объект данными указанной структуры.
//
// Параметры:
//  СтруктураИсточник – Структура – структура, копию которой необходимо получить
// 
//  Возвращаемое значение:
//  Тип: Структура.
//
Функция СкопироватьСтруктуру(СтруктураИсточник) Экспорт
	
	СтруктураРезультат = Новый Структура;
	
	Для Каждого Элемент ИЗ СтруктураИсточник Цикл
		
		СтруктураРезультат.Вставить(Элемент.Ключ, Элемент.Значение);
		
	КонецЦикла;
	
	Возврат СтруктураРезультат;
	
КонецФункции

Функция ПолучитьКлючиСтруктурыСтрокой(Структура, Разделитель = ",") Экспорт
	
	Результат = "";
	
	Для Каждого Элемент Из Структура Цикл
		
		СимволРазделителя = ?(ПустаяСтрока(Результат), "", Разделитель);
		
		Результат = Результат + СимволРазделителя + Элемент.Ключ;
		
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

// Функция СохранитьФайлНаСервере перемещает двоичные данные из временного
// хранилища в файл на сервере (данные во временном хранилище удаляются).
//
// Параметры:
//  АдресВоВременномХранилище - адрес, указывающий на значение во временном хранилище.
//  ИмяФайла     - Строка, необязательный параметр,
//                 полное имя файла на сервере для сохранения двоичных данных.
//
// Возвращаемое значение:
//  Строка       - полное имя файла на сервере, в который сохранены двоичные данные.
//
Функция СохранитьФайлНаСервере(Знач АдресВоВременномХранилище, Знач ИмяФайла = Неопределено) Экспорт
	
	Если ИмяФайла = Неопределено Тогда
		ИмяФайла = ПолучитьИмяВременногоФайла();
	КонецЕсли;
	
	ДвоичныеДанные = ПолучитьИзВременногоХранилища(АдресВоВременномХранилище);
	ДвоичныеДанные.Записать(ИмяФайла);
	
	УдалитьИзВременногоХранилища(АдресВоВременномХранилище);
	
	Возврат ИмяФайла;
	
КонецФункции // СохранитьФайлНаСервере()

// Вызывается в серверном контексте и удаляет временные файлы на сервере 1С:Предприятие.
//
Процедура УдалитьФайлыНаСервере1СПредприятие(Путь) Экспорт
	
	ОбщегоНазначенияКлиентСервер.УдалитьКаталогСФайлами(Путь);
	
КонецПроцедуры

// Проверяет, включена ли регистрация событий в журнале регистрации
Функция ПроверитьВключениеЖурнала(СписокПроверок = Неопределено) Экспорт	
	МассивРежимов = ПолучитьИспользованиеЖурналаРегистрации();
	Если СписокПроверок = Неопределено Тогда
		Возврат МассивРежимов.Количество() = 4 ;
	Иначе
		МассивНазванийРежимов =  СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(СписокПроверок);
		Для Каждого Название Из МассивНазванийРежимов Цикл
			ТекущийПроверяемыйРежим = ПолучитьУровеньСобытияПоПредставлению(Название);
			Если МассивРежимов.Найти(ТекущийПроверяемыйРежим) = Неопределено Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Возврат Истина;
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для работы с типами и их строковыми представлениями.

Функция ПолучитьУровеньСобытияПоПредставлению(ПредставлениеУровня)
	Если ПредставлениеУровня = "Информация" Тогда
		Возврат УровеньЖурналаРегистрации.Информация;
	ИначеЕсли ПредставлениеУровня = "Ошибка" Тогда
		Возврат УровеньЖурналаРегистрации.Ошибка;
	ИначеЕсли ПредставлениеУровня = "Предупреждение" Тогда
		Возврат УровеньЖурналаРегистрации.Предупреждение; 
	ИначеЕсли ПредставлениеУровня = "Примечание" Тогда
		Возврат УровеньЖурналаРегистрации.Примечание;
	КонецЕсли;	
КонецФункции

// Возвращает строковое представление типа. 
// Для ссылочных типов возвращает в формате "СправочникСсылка.ИмяОбъекта" или "ДокументСсылка.ИмяОбъекта"
// Для остальных типов приводит тип к строке, например "Число".
//
Функция ПолучитьСтроковоеПредставлениеТипа(Тип) Экспорт
	
	Представление = "";
	
	Если ЭтоСсылка(Тип) Тогда
	
		ПолноеИмя = Метаданные.НайтиПоТипу(Тип).ПолноеИмя();
		ИмяОбъекта = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПолноеИмя, ".")[1];
		
		Если Справочники.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "СправочникСсылка";
		
		ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ДокументСсылка";
		
		ИначеЕсли БизнесПроцессы.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "БизнесПроцессСсылка";
		
		ИначеЕсли ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ПланВидовХарактеристикСсылка";
		
		ИначеЕсли ПланыСчетов.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ПланСчетовСсылка";
		
		ИначеЕсли ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ПланВидовРасчетаСсылка";
		
		ИначеЕсли Задачи.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ЗадачаСсылка";
		
		ИначеЕсли ПланыОбмена.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ПланОбменаСсылка";
		
		ИначеЕсли Перечисления.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ПеречислениеСсылка";
		
		КонецЕсли;
		
		Результат = ?(Представление = "", Представление, Представление + "." + ИмяОбъекта);
		
	Иначе
		
		Результат = Строка(Тип);
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Возвращает головную организацию для заданной организации
// Если для организации реквизит ГоловнаяОрганизация не заполнен 
// это значит, что сама организация является голвной
//
// Параметры
//  Организация – СправочникСсылка.Организации
//                 <продолжение описания параметра>
//
// Возвращаемое значение:
//   СправочникСсылка.Организации
//
Функция ГоловнаяОрганизация(Организация) Экспорт

	Если Организация.Пустая() ИЛИ Организация.ГоловнаяОрганизация.Пустая() Тогда
		Возврат Организация;

	Иначе
		Возврат Организация.ГоловнаяОрганизация;

	КонецЕсли;

КонецФункции // ГоловнаяОрганизация()

// Функция проверяет наличие в строке только цифр
//
// Параметры
//  СтрокаПроверки - Строка для проверки только цифр
//
// Возвращаемое значение:
//   Булево
//
Функция ТолькоЦифрыВСтроке(Знач СтрокаПроверки, УчитыватьЛидирующиеНули = Истина, УчитыватьПробелы = Истина) Экспорт
	
	Если ТипЗнч(СтрокаПроверки) <> Тип("Строка") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если ЗначениеНеЗаполнено(СтрокаПроверки) Тогда
		Возврат Истина;
	КонецЕсли; 
	
	Если НЕ УчитыватьПробелы Тогда
		СтрокаПроверки = СтрЗаменить(СтрокаПроверки, " ", "");
	КонецЕсли;
	
	Если НЕ УчитыватьЛидирующиеНули Тогда
		НомерПервойЦифры = 0;
		Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
			НомерПервойЦифры = НомерПервойЦифры + 1;
			КодСимвола = КодСимвола(Сред(СтрокаПроверки, а, 1));
			Если КодСимвола <> 48 Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
		СтрокаПроверки = Сред(СтрокаПроверки, НомерПервойЦифры);
	КонецЕсли;
	
	Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
		КодСимвола = КодСимвола(Сред(СтрокаПроверки, а, 1));
		Если НЕ (КодСимвола >= 48 И КодСимвола <= 57) Тогда
			Возврат Ложь;
		КонецЕсли; 
	КонецЦикла; 

	Возврат Истина;
	
КонецФункции

Функция ПолучитьРабочуюДату() Экспорт
	
	#Если Клиент Тогда
		Дата = РабочаяДата;
	#Иначе
		Дата = ТекущаяДата();
	#КонецЕсли
	
	Возврат Дата;
	
КонецФункции // ПолучитьРабочуюДату()


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ВАЛЮТАМИ

// Эта функция пересчитывает сумму из валюты ВалютаНач по курсу ПоКурсуНач 
// в валюту ВалютаКон по курсу ПоКурсуКон
//
// Параметры:      
//	Сумма          - сумма, которую следует пересчитать;
//	ВалютаНач      - ссылка на элемент справочника Валют;
//                   определяет валюты из которой надо пересчитвать;
//	ВалютаКон      - ссылка на элемент справочника Валют;
//                   определяет валюты в которую надо пересчитвать;
// 	ПоКурсуНач     - курс из которого надо пересчитать;
// 	ПоКурсуКон     - курс в который надо пересчитать;
// 	ПоКратностьНач - кратность из которого надо пересчитать (по умолчанию = 1);
// 	ПоКратностьКон - кратность в который надо пересчитать  (по умолчанию = 1);
//
// Возвращаемое значение: 
//  Сумма, пересчитанная в другую валюту
//
Функция ПересчитатьИзВалютыВВалюту(Сумма, ВалютаНач, ВалютаКон, ПоКурсуНач, ПоКурсуКон, 
	                               ПоКратностьНач = 1, ПоКратностьКон = 1 ) Экспорт

	Если (ВалютаНач = ВалютаКон) Тогда

		// Считаем, что пересчет не нужен.
		Возврат Сумма;

	КонецЕсли;

	Если (ПоКурсуНач     = ПоКурсуКон) 
	   и (ПоКратностьНач = ПоКратностьКон) Тогда

		// ну, тут и считать нечего...
		Возврат Сумма;

	КонецЕсли;

	Если ПоКурсуНач     = 0 
	 или ПоКурсуКон     = 0 
	 или ПоКратностьНач = 0 
	 или ПоКратностьКон = 0 Тогда
		СообщитьОбОшибке("Процедура ""ПересчитатьИзВалютыВВалюту()"": при пересчете обнаружен нулевой курс.");
		Возврат 0;

	КонецЕсли;

	Возврат Окр((Сумма * ПоКурсуНач * ПоКратностьКон) / (ПоКурсуКон * ПоКратностьНач), 2);

КонецФункции //ПересчитатьИзВалютыВВалюту()

// Возвращает курс валюты на дату
//
// Параметры:
//  Валюта     - Валюта (элемент справочника "Валюты")
//  ДатаКурса  - Дата, на которую следует получить курс
//
// Возвращаемое значение: 
//  Структура, содержащая:
//   Курс      - курс валюты
//   Кратность - кратность валюты
//
Функция ПолучитьКурсВалюты(Валюта, ДатаКурса) Экспорт

	Возврат РегистрыСведений.КурсыВалют.ПолучитьПоследнее(ДатаКурса, Новый Структура("Валюта", Валюта));

КонецФункции // ПолучитьКурсВалюты()

// Определяет курс документа, который равен либо курсу документа (если в документе он существует),
// либо курсу взаиморасчетов, либо 1.
//
// Параметры: 
//  ДокументОбъект                 - объект документа, курс которого надо получить
//  ВалютаРегламентированногоУчета - валюта регламентированного учета
//
// Возвращаемое значение:
//  Число - курс документа.
//
Функция КурсДокумента(ДокументОбъект, ВалютаРегламентированногоУчета) Экспорт

	МетаданныеДокумента = ДокументОбъект.Метаданные();
	
	Если ЕстьРеквизитДокумента("ВалютаДокумента", МетаданныеДокумента) Тогда
		// Если валюта документа совпадает с валютой регл. учета, то курс 1.
		Если ДокументОбъект.ВалютаДокумента <> ВалютаРегламентированногоУчета Тогда
			
			МетаданныеДокумента = ДокументОбъект.Метаданные();
			
			// Если есть реквизит КурсДокумента - его и вернем
			Если ЕстьРеквизитДокумента("КурсДокумента", МетаданныеДокумента) Тогда
				Возврат ДокументОбъект.КурсДокумента;
			КонецЕсли;
			
			// Если нет КурсДокумента и валюта документа не совпадает с валютой регл. учета, 
			// то такой документ может быть выписан только в валюте взаиморасчетов,
			// если есть реквизит КурсВзаиморасчетов - его и вернем.
			Если ЕстьРеквизитДокумента("КурсВзаиморасчетов", МетаданныеДокумента) Тогда
				Возврат ДокументОбъект.КурсВзаиморасчетов;
			КонецЕсли;
			
			// Если нет КурсВзаиморасчетов и валюта документа не совпадает с валютой регл. учета, 
			// то КурсВзаиморасчетов долежн быть в табличной части документа или может вообще отсутсвовать.
			// Тогда возьмем курс из справочника на дату документа.
			Возврат ПолучитьКурсВалюты(ДокументОбъект.ВалютаДокумента,ДокументОбъект.Дата).Курс;
			
		КонецЕсли;
	КонецЕсли;

	Возврат 1;

КонецФункции // КурсДокумента()

// Определяет кратность документа, которая равен либо кратности документа (если в документе она существует),
// либо кратности взаиморасчетов, либо 1.
//
// Параметры: 
//  ДокументОбъект - объект документа, курс которого надо получить
//  ВалютаРегламентированногоУчета - валюта регламентированного учета
//
// Возвращаемое значение:
//  Число - кратность валюты в документе.
//
Функция КратностьДокумента(ДокументОбъект, ВалютаРегламентированногоУчета) Экспорт

	МетаданныеДокумента = ДокументОбъект.Метаданные();
	
	Если ЕстьРеквизитДокумента("ВалютаДокумента", МетаданныеДокумента) Тогда
		// Если валюта документа совпадает с валютой регл. учета, то кратность 1.
		Если ДокументОбъект.ВалютаДокумента <> ВалютаРегламентированногоУчета Тогда
			
			// Если есть реквизит КратностьДокумента - его и вернем
			Если ЕстьРеквизитДокумента("КратностьДокумента", МетаданныеДокумента) Тогда
				Возврат ДокументОбъект.КратностьДокумента;
			КонецЕсли;
			
			// Если нет КратностьДокумента и валюта документа не совпадает с валютой регл. учета, 
			// то такой документ может быть выписан только в валюте взаиморасчетов,
			// если есть реквизит КратностьВзаиморасчетов - его и вернем.
			Если ЕстьРеквизитДокумента("КратностьВзаиморасчетов", МетаданныеДокумента) Тогда
				Возврат ДокументОбъект.КратностьВзаиморасчетов;
			КонецЕсли;
			
			// Если нет КратностьВзаиморасчетов и валюта документа не совпадает с валютой регл. учета, 
			// то КратностьВзаиморасчетов должна быть в табличной части документа или может вообще отсутсвовать.
			//Тогда возьмем Кратность из справочника на дату документа.
			Возврат ПолучитьКурсВалюты(ДокументОбъект.ВалютаДокумента,ДокументОбъект.Дата).Кратность;
			
		КонецЕсли;
    КонецЕсли;
	
	Возврат 1;

КонецФункции // КратностьДокумента()

// Проверяет наличие установленного курс аи кратности валюты на 1 января 1980 года.
// В случае отсутствия устанавливает курс и кратность равными единице.
//
// Параметры:
//  Валюта - ссылка на элемент справочника Валют
//
Процедура ПроверитьКорректностьКурсаНа01_01_1980(Валюта) Экспорт

	ДатаКурса = Дата(1980, 1, 1);
	СтруктураКурса = ПолучитьКурсВалюты(Валюта, ДатаКурса);

	Если (СтруктураКурса.Курс = 0) Или (СтруктураКурса.Кратность = 0) Тогда

		// установим курс и кратность = 1 на 01.01.1980, чтобы не было ошибок при создании документов

		РегистрКурсыВалют = РегистрыСведений.КурсыВалют.СоздатьМенеджерЗаписи();

		РегистрКурсыВалют.Период    = ДатаКурса;
		РегистрКурсыВалют.Валюта    = Валюта;
		РегистрКурсыВалют.Курс      = 1;
		РегистрКурсыВалют.Кратность = 1;
		РегистрКурсыВалют.Записать();

	КонецЕсли;

КонецПроцедуры // ПроверитьКорректностьКурсаНа01_01_1980()

// Определяет коэффициент распределения
// расходов по видам деятельности (ЕНВД / не ЕНВД).
//
// Параметры
//  Организация - СправочникСсылка.Организации
//  Дата  – Дата – одна из дат того месяца,
//			в котором необходимо рассчитать коэффициент.
//
// Возвращаемое значение:
//   Число – коэффициент распределения расходов по видам деятельности.
//
Функция КоэффициентРаспределенияРасходовПоВидамДеятельности(Организация, Знач Дата, Знач НачДата = Неопределено, ВидУчета = "БУ", ПоВсемСчетам = Истина) Экспорт
	
	Если ВидУчета = "НУ" Тогда
		ПериодГод          = ?(ПолучитьПараметрыУчетнойПолитики(Дата, Ложь, Организация, "Нал").МетодРаспределенияКосвенныхРасходовПоВидамДеятельности = Перечисления.МетодыРаспределенияКосвенныхРасходовПоВидамДеятельности.НарастающимИтогомСНачалаГода, Истина, Ложь);
		УчитыватьВсеДоходы = ?(ПолучитьПараметрыУчетнойПолитики(Дата, Ложь, Организация, "Нал").БазаРаспределенияКосвенныхРасходовПоВидамДеятельности = Перечисления.БазыРаспределенияКосвенныхРасходовПоВидамДеятельности.ДоходыОтРеализацииИВнереализационные, Истина, Ложь);
		Если НачДата = Неопределено Тогда
			НачДатаТекущегоМесяца = НачалоМесяца(Дата);
		Иначе
			НачДатаТекущегоМесяца = НачалоМесяца(НачДата);
		КонецЕсли;
		Если ПериодГод Тогда
			НачДата = НачалоГода(Дата);
		Иначе
			НачДата = НачалоМесяца(Дата);
		КонецЕсли;
		
	Иначе
		ПериодГод =  Ложь;
		УчитыватьВсеДоходы = Ложь;
		Если НачДата = Неопределено Тогда
			НачДата = НачалоМесяца(Дата);
		КонецЕсли;
	КонецЕсли;
	
	КонДата = КонецМесяца(Дата);      // Доходы от реализации
	
	ТекстЗапроса = "ВЫБРАТЬ
	|	СУММА(ВЫБОР
	|			КОГДА ХозрасчетныйОбороты.Счет В (&СчетВыручкаЕНВД)
	|				ТОГДА -ХозрасчетныйОбороты.СуммаОборот
	|			ИНАЧЕ 0
	|		КОНЕЦ) КАК ВыручкаЕНВД,
	|	СУММА(ВЫБОР
	|			КОГДА (НЕ ХозрасчетныйОбороты.Счет В (&СчетВыручкаЕНВД))
	|				ТОГДА -ХозрасчетныйОбороты.СуммаОборот
	|			ИНАЧЕ 0
	|		КОНЕЦ) КАК ВыручкаНеЕНВД,
	|	СУММА(0) КАК РасходыЕНВДПрошлыхПериодов,
	|	СУММА(0) КАК РасходыСНачалаГода,
	|	СУММА(0) КАК РасходыМесяца,
	|	ХозрасчетныйОбороты.Счет КАК Счет
	|ИЗ
	|	РегистрБухгалтерии.Хозрасчетный.Обороты(&НачДата, &КонДата, Период, Счет В ИЕРАРХИИ (&МассивСчетов), , Организация = &Организация, , ) КАК ХозрасчетныйОбороты
	|
	|СГРУППИРОВАТЬ ПО
	|	ХозрасчетныйОбороты.Счет";
	
	Если УчитыватьВсеДоходы Тогда   // Внереализационные доходы
		ТекстЗапроса = ТекстЗапроса + "
		|
		|ОБЪЕДИНИТЬ ВСЕ
		|
		|ВЫБРАТЬ
		|	СУММА(ВЫБОР
		|			КОГДА ХозрасчетныйОбороты.Субконто1.ОтнесениеРасходовКДеятельностиЕНВД = &ВнереализационныеДоходыЕНВД
		|				ТОГДА -ХозрасчетныйОбороты.СуммаОборот
		|			ИНАЧЕ 0
		|		КОНЕЦ),
		|	СУММА(ВЫБОР
		|			КОГДА НЕ ХозрасчетныйОбороты.Субконто1.ОтнесениеРасходовКДеятельностиЕНВД = &ВнереализационныеДоходыЕНВД
		|				ТОГДА -ХозрасчетныйОбороты.СуммаОборот
		|			ИНАЧЕ 0
		|		КОНЕЦ),
		|	СУММА(0),
		|	СУММА(0),
		|	СУММА(0),
		|	ХозрасчетныйОбороты.Счет
		|ИЗ
		|	РегистрБухгалтерии.Налоговый.Обороты(&НачДата, &КонДата, Период, Счет В ИЕРАРХИИ (&ВнереализационныеДоходы), , Организация = &Организация, , ) КАК ХозрасчетныйОбороты
		|
		|СГРУППИРОВАТЬ ПО
		|	ХозрасчетныйОбороты.Счет";
	КонецЕсли;
	
	Если ПериодГод Тогда      // распределение расходов предыдущих периодов
		ТекстЗапроса = ТекстЗапроса + "
		|
		|ОБЪЕДИНИТЬ ВСЕ
		|
		|ВЫБРАТЬ
		|	СУММА(0),
		|	СУММА(0),
		|	СУММА(НалоговыйОбороты.СуммаОборотКт),
		|	СУММА(0),
		|	СУММА(0),
		|	НалоговыйОбороты.Счет
		|ИЗ
		|	РегистрБухгалтерии.Налоговый.Обороты(&НачДата, &КонДатаМинусМесяц, Период, Счет В ИЕРАРХИИ (&СчетаУчетаРасходов), &ВидСубконто, Организация = &Организация И Субконто1.ОтнесениеРасходовКДеятельностиЕНВД = &РаспределяемыеРасходы, КорСчет = &ЕНВД, ) КАК НалоговыйОбороты
		|
		|СГРУППИРОВАТЬ ПО
		|	НалоговыйОбороты.Счет
		|
		|ОБЪЕДИНИТЬ ВСЕ
		|
		|ВЫБРАТЬ
		|	СУММА(0),
		|	СУММА(0),
		|	СУММА(НалоговыйОбороты.СуммаОборотКт),
		|	СУММА(0),
		|	СУММА(0),
		|	НалоговыйОбороты.Счет
		|ИЗ
		|	РегистрБухгалтерии.Налоговый.Обороты(&НачДата, &КонДатаМинусМесяц, Период, Счет В ИЕРАРХИИ (&Счет91), &ВидСубконто91, Организация = &Организация И Субконто1.ОтнесениеРасходовКДеятельностиЕНВД = &РаспределяемыеРасходы, КорСчет = &ЕНВД, ) КАК НалоговыйОбороты
		|
		|СГРУППИРОВАТЬ ПО
		|	НалоговыйОбороты.Счет
		|
		|ОБЪЕДИНИТЬ ВСЕ                 // расходы с начала года
		|
		|ВЫБРАТЬ
		|	СУММА(0),
		|	СУММА(0),
		|	СУММА(0),					   
		|	СУММА(НалоговыйОбороты.СуммаОборотДт), 
		|	СУММА(0),					   
		|	НалоговыйОбороты.Счет
		|ИЗ
		|	РегистрБухгалтерии.Налоговый.Обороты(&НачДата, &КонДата, Период, Счет В ИЕРАРХИИ (&СчетаУчетаРасходов), &ВидСубконто, Организация = &Организация И Субконто1.ОтнесениеРасходовКДеятельностиЕНВД = &РаспределяемыеРасходы, , ) КАК НалоговыйОбороты
		|
		|СГРУППИРОВАТЬ ПО
		|	НалоговыйОбороты.Счет
		|
		|ОБЪЕДИНИТЬ ВСЕ                
		|
		|ВЫБРАТЬ
		|	СУММА(0),
		|	СУММА(0),
		|	СУММА(0),					   
		|	СУММА(НалоговыйОбороты.СуммаОборотДт), 
		|	СУММА(0),					   
		|	НалоговыйОбороты.Счет
		|ИЗ
		|	РегистрБухгалтерии.Налоговый.Обороты(&НачДата, &КонДата, Период, Счет В ИЕРАРХИИ (&Счет91), &ВидСубконто91, Организация = &Организация И Субконто1.ОтнесениеРасходовКДеятельностиЕНВД = &РаспределяемыеРасходы, , ) КАК НалоговыйОбороты
		|
		|СГРУППИРОВАТЬ ПО
		|	НалоговыйОбороты.Счет
		|
		|ОБЪЕДИНИТЬ ВСЕ        // расходы текущего месяца
		|
		|ВЫБРАТЬ
		|	СУММА(0),
		|	СУММА(0),
		|	СУММА(0),
		|	СУММА(0),					   
		|	СУММА(НалоговыйОбороты.СуммаОборотДт), 
		|	НалоговыйОбороты.Счет
		|ИЗ
		|	РегистрБухгалтерии.Налоговый.Обороты(&НачДатаТекущегоМесяца, &КонДата, Период, Счет В ИЕРАРХИИ (&СчетаУчетаРасходов), &ВидСубконто, Организация = &Организация И Субконто1.ОтнесениеРасходовКДеятельностиЕНВД = &РаспределяемыеРасходы, , ) КАК НалоговыйОбороты
		|
		|СГРУППИРОВАТЬ ПО
		|	НалоговыйОбороты.Счет
		|
		|ОБЪЕДИНИТЬ ВСЕ      		
		|ВЫБРАТЬ
		|	СУММА(0),
		|	СУММА(0),
		|	СУММА(0),
		|	СУММА(0),					   
		|	СУММА(НалоговыйОбороты.СуммаОборотДт), 
		|	НалоговыйОбороты.Счет
		|ИЗ
		|	РегистрБухгалтерии.Налоговый.Обороты(&НачДатаТекущегоМесяца, &КонДата, Период, Счет В ИЕРАРХИИ (&Счет91), &ВидСубконто91, Организация = &Организация И Субконто1.ОтнесениеРасходовКДеятельностиЕНВД = &РаспределяемыеРасходы, , ) КАК НалоговыйОбороты
		|
		|СГРУППИРОВАТЬ ПО
		|	НалоговыйОбороты.Счет";
	КонецЕсли;
	
	//Массив счетов, по которым рассчитывается доход организации
	МассивСчетов = Новый Массив;
	МассивСчетов.Добавить(ПланыСчетов.Хозрасчетный.Выручка);
	МассивСчетов.Добавить(ПланыСчетов.Хозрасчетный.Продажи_НДС);
	МассивСчетов.Добавить(ПланыСчетов.Хозрасчетный.Продажи_Акцизы);
	МассивСчетов.Добавить(ПланыСчетов.Хозрасчетный.Продажи_ЭкспортныеПошлины);
	
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("НачДата",              НачДата);
	Запрос.УстановитьПараметр("КонДата",              КонДата);
	Запрос.УстановитьПараметр("КонДатаМинусМесяц",    КонецМесяца(НачалоМесяца(Дата) - 1));
	Запрос.УстановитьПараметр("НачДатаТекущегоМесяца",НачДатаТекущегоМесяца);
	Запрос.УстановитьПараметр("Организация",          Организация);
	Запрос.УстановитьПараметр("СчетВыручкаЕНВД",      МассивСчетовВыручкиЕНВД());
	Запрос.УстановитьПараметр("МассивСчетов",         МассивСчетов);
	Запрос.УстановитьПараметр("ВнереализационныеДоходы",ПланыСчетов.Налоговый.ПрочиеДоходы);
	Запрос.УстановитьПараметр("ВнереализационныеДоходыЕНВД", Перечисления.ОтнесениеРасходовКДеятельностиЕНВД.РасходыОтносятсяКЕНВД);
	Запрос.УстановитьПараметр("ЕНВД",                 ПланыСчетов.Налоговый.РасходыПоДеятельностиЕНВД);
	Запрос.УстановитьПараметр("СчетаУчетаРасходов",   НалоговыйУчет.ПолучитьМассивСчетовУчетаКосвенныхРасходов());
	Запрос.УстановитьПараметр("РаспределяемыеРасходы",Перечисления.ОтнесениеРасходовКДеятельностиЕНВД.РасходыРаспределяются);
	Запрос.УстановитьПараметр("ВидСубконто",          ПланыВидовХарактеристик.ВидыСубконтоХозрасчетные.СтатьиЗатрат);
	Запрос.УстановитьПараметр("ВидСубконто91",        ПланыВидовХарактеристик.ВидыСубконтоХозрасчетные.ПрочиеДоходыИРасходы);
	Запрос.УстановитьПараметр("Счет91",               ПланыСчетов.Налоговый.ПрочиеКосвенныеРасходы);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	// Если результат запроса пустой, то считаем, что все
	// расходы относятся к деятельности не облагаемой ЕНВД.
	Если РезультатЗапроса.Пустой() Тогда
		Коэффициент = 0;
		
	Иначе
		
		ТаблицаРезультат = РезультатЗапроса.Выгрузить();
		ВыручкаЕНВД      = Макс(ТаблицаРезультат.Итог("ВыручкаЕНВД"),   0);
		ВыручкаНеЕНВД    = Макс(ТаблицаРезультат.Итог("ВыручкаНеЕНВД"), 0);
		
		Если ВыручкаНеЕНВД + ВыручкаЕНВД = 0 Тогда // нет дохода ни по одному из видов деятельности
			Коэффициент = 0;
			Возврат Коэффициент;
		КонецЕсли;
		
		
		Если Не ПериодГод Тогда
			
			Если ВыручкаНеЕНВД = 0 Тогда  // нет дохода виду деятельности не подпадающему под обложение ЕНВД
				Коэффициент = 1;
				
			Иначе
				Коэффициент = ВыручкаЕНВД / (ВыручкаНеЕНВД + ВыручкаЕНВД);
			КонецЕсли;
			
		Иначе
			Если ПоВсемСчетам Тогда
				
				РасходыЕНВДПрошлыхПериодов = ТаблицаРезультат.Итог("РасходыЕНВДПрошлыхПериодов");
				РасходыСНачалаГода         = ТаблицаРезультат.Итог("РасходыСНачалаГода");
				РасходыМесяца              = ТаблицаРезультат.Итог("РасходыМесяца");
				
				РасходыЕНВДСНачалаГода = РасходыСНачалаГода * ВыручкаЕНВД / (ВыручкаНеЕНВД + ВыручкаЕНВД);
				РасходыЕНВД = РасходыЕНВДСНачалаГода - РасходыЕНВДПрошлыхПериодов;
				Коэффициент = ?(РасходыМесяца = 0, 0, РасходыЕНВД / РасходыМесяца); 
				
			Иначе
				ТаблицаРезультат.Свернуть("Счет", "РасходыЕНВДПрошлыхПериодов,РасходыСНачалаГода,РасходыМесяца");
				ТаблицаКоэффиентов = Новый ТаблицаЗначений ;
				ТаблицаКоэффиентов.Колонки.Добавить("Счет");
				ТаблицаКоэффиентов.Колонки.Добавить("Коэффициент");
				ТаблицаКоэффиентов.Колонки.Добавить("СуммаКорректировки");
				
				Для Каждого СтрокаТаблицы ИЗ ТаблицаРезультат Цикл
					СтрокаТаблицаКоэффиентов = ТаблицаКоэффиентов.Добавить();	
					РасходыЕНВДСНачалаГода = СтрокаТаблицы.РасходыСНачалаГода * ВыручкаЕНВД / (ВыручкаНеЕНВД + ВыручкаЕНВД);
					РасходыЕНВД = РасходыЕНВДСНачалаГода - СтрокаТаблицы.РасходыЕНВДПрошлыхПериодов;
					СтрокаТаблицаКоэффиентов.Счет = СтрокаТаблицы.Счет;
					Если СтрокаТаблицы.РасходыМесяца = 0 Тогда
						СтрокаТаблицаКоэффиентов.Коэффициент = 0;
						СтрокаТаблицаКоэффиентов.СуммаКорректировки = РасходыЕНВД;
					Иначе
						СтрокаТаблицаКоэффиентов.Коэффициент = РасходыЕНВД / СтрокаТаблицы.РасходыМесяца; 
						СтрокаТаблицаКоэффиентов.СуммаКорректировки = 0;
					КонецЕсли;
				КонецЦикла;
				Возврат ТаблицаКоэффиентов;	
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	
	Возврат Коэффициент;
	
КонецФункции // КоэффициентРаспределенияРасходовПоВидамДеятельности()


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ЗАПИСИ НАБОРА КОНСТАНТ

// Записывает набор констант, сравнивая его с эталонным набором
// Записываются только те константы, которые были изменены относительно эталонного набора
//
// Параметры: 
//  НаборКонстант  - Набор констант
//  ЭталонныйНабор - Эталонный набор констант
//  Модифицированность - Устанавливается в истину, если операция выполнена успешно
//
// Возвращаемое значение:
//  Истина - операция выполнена, ложь - иначе.
//
Функция ЗаписатьНаборКонстант(НаборКонстант, ЭталонныйНабор, Модифицированность = Истина) Экспорт
	
	ЗаписываемыеКонстанты = "";
	Для каждого Константа Из Метаданные.Константы Цикл
		
		ИмяКонстанты = Константа.Имя;
		
		ЗначениеНабора    = ЗначениеВСтрокуВнутр(НаборКонстант[ИмяКонстанты]);
		ЭталонноеЗначение = ЗначениеВСтрокуВнутр(ЭталонныйНабор[ИмяКонстанты]);
		
		Если Не ЗначениеНабора = ЭталонноеЗначение Тогда
			
			ТекущееЗначение   = ЗначениеВСтрокуВнутр(Константы[ИмяКонстанты].Получить());
			
			Если Не ЗначениеНабора = ТекущееЗначение Тогда
				ЗаписываемыеКонстанты = ЗаписываемыеКонстанты + ?(ПустаяСтрока(ЗаписываемыеКонстанты), "", ", ") + ИмяКонстанты;
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Если Не ПустаяСтрока(ЗаписываемыеКонстанты) Тогда
		
		ЗаписываемыйНабор = Константы.СоздатьНабор(ЗаписываемыеКонстанты);
		ЗаполнитьЗначенияСвойств(ЗаписываемыйНабор, НаборКонстант, ЗаписываемыеКонстанты);
		
		Попытка
			ЗаписываемыйНабор.Записать();
		Исключение
			СообщитьОбОшибке(ОписаниеОшибки());
			Возврат Ложь;
		КонецПопытки;
		
		НаборКонстант.Прочитать();
		ЗаполнитьЗначенияСвойств(ЭталонныйНабор, НаборКонстант);
		
	КонецЕсли; 
	
	Модифицированность = Ложь;
	Возврат Истина;
	
КонецФункции


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ПРОВЕРКИ НАЛИЧИЯ И ЗАПОЛНЕНИЯ РЕВИЗИТОВ

// Определяет заполнено ли переданное значение
//
// Параметры: 
//  Значение - значение, заполенение которого надо проверить
//
// Возвращаемое значение:
//  Истина - значение не заполнено, ложь - иначе.
//
Функция ЗначениеНеЗаполнено(Значение) Экспорт

	Результат   = Ложь;
	ТипЗначения = ТипЗнч(Значение);

	// Сначала примитивные типы
	Если Значение = Неопределено Тогда
		Результат = Истина;

	ИначеЕсли Значение = NULL Тогда
		Результат = Истина;

	ИначеЕсли ТипЗначения = Тип("Строка") Тогда
		Если СокрЛП(Значение) = "" Тогда
			Результат = Истина;
		КонецЕсли;

	ИначеЕсли ТипЗначения = Тип("Число") Тогда
		Если Значение = 0 Тогда
			Результат = Истина;
		КонецЕсли;

	ИначеЕсли ТипЗначения = Тип("Дата") Тогда
		Если Значение = Дата('00010101') Тогда
			Результат = Истина;
		КонецЕсли;

	ИначеЕсли ТипЗначения = Тип("Булево") Тогда
		Результат = Ложь; // Булево будем считать не пустым

		//Отдельное определение, так как конструкторов данного типа не существует	
	ИначеЕсли ТипЗначения = Тип("РежимПроведенияДокумента") Тогда

		Если Значение = РежимПроведенияДокумента.Неоперативный или Значение = РежимПроведенияДокумента.Оперативный тогда
			Результат = Ложь;
		КонецЕсли;

		// Для остальных будем считать значение пустым, если оно равно
		// дефолтному значению своего типа

	Иначе

		Если Значение = Новый(ТипЗначения) Тогда
			Результат = Истина;
		КонецЕсли;

	КонецЕсли;

	Возврат Результат;

КонецФункции // ЗначениеНеЗаполнено()

// Позволяет определить есть ли среди реквизитов шапки документа
// реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита - строковое имя искомого реквизита, 
//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьРеквизитДокумента(ИмяРеквизита, МетаданныеДокумента) Экспорт

	Возврат НЕ (МетаданныеДокумента.Реквизиты.Найти(ИмяРеквизита) = Неопределено);

КонецФункции // ЕстьРеквизитДокумента()

// Позволяет определить есть ли табличная часть документа с переданным именем.
//
// Параметры: 
//  ИмяТабЧасти - строковое имя искомой табличной части,
//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьТабЧастьДокумента(ИмяТабЧасти, МетаданныеДокумента) Экспорт

	Если МетаданныеДокумента.ТабличныеЧасти.Найти(ИмяТабЧасти) = Неопределено Тогда
		Возврат Ложь;
	Иначе
		Возврат Истина;
	КонецЕсли; 

КонецФункции // ЕстьТабЧастьДокумента()

// Позволяет определить есть ли среди реквизитов табличной части документа
// реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита - строковое имя искомого реквизита, 
//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
//  ИмяТабЧасти  - строковое имя табличной части документа, среди реквизитов которого производится поиск
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьРеквизитТабЧастиДокумента(ИмяРеквизита, МетаданныеДокумента, ИмяТабЧасти) Экспорт

	ТабЧасть = МетаданныеДокумента.ТабличныеЧасти.Найти(ИмяТабЧасти);

	Если ТабЧасть = Неопределено Тогда // Нет такой таб. части в документе
		Возврат Ложь;

	Иначе
		Возврат НЕ (ТабЧасть.Реквизиты.Найти(ИмяРеквизита) = Неопределено);

	КонецЕсли;

КонецФункции // ЕстьРеквизитТабЧастиДокумента()

// Функция проверяет наличие в строке только цифр
//
// Параметры
//  СтрокаПроверки - Строка для проверки только цифр
//
// Возвращаемое значение:
//   Булево
//
Функция ЕстьНеЦифры(Знач СтрокаПроверки) Экспорт

	СписокКодовЧисел = Новый СписокЗначений;
	Для а = 48 По 57 Цикл
		СписокКодовЧисел.Добавить(а);
	КонецЦикла; 
	
	СтрокаПроверки = СокрЛП(СтрокаПроверки);
	
	Если ТипЗнч(СтрокаПроверки) <> Тип("Строка") Тогда
		
		Возврат Истина;
		
	Иначе
		
		Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
			Если СписокКодовЧисел.НайтиПоЗначению(КодСимвола(Сред(СтрокаПроверки, а, 1))) = Неопределено Тогда
				Возврат Истина;
			КонецЕсли; 
		КонецЦикла; 
		
	КонецЕсли; 

	Возврат Ложь;
	
КонецФункции

// Процедура устанавливает новое значение для переданного реквизита.
// Если новое значение совпадает со старым, то флаг модифицированности не взводится.
//
// Параметры
//  Реквизит  – Произвольный – Реквизит, для которого надо установить новое значение
//  Значение  – Произвольный – Новое значение для реквизита
//
Процедура УстановитьЗначение(Реквизит, Значение) Экспорт

	Если Реквизит <> Значение Тогда
		Реквизит = Значение;
	КонецЕсли;

КонецПроцедуры // УстановитьЗначение(Реквизит, Значение)

// Процедура устанавливает номер документа.
//
// Параметры:
//  ДокументОбъект  - ДокументОбъект. Экземпляр документа, которому 
//                    необходимо присвоить новый номер
//
Процедура УстановитьНомерДокумента(ДокументОбъект) Экспорт

	// Если  нет реквизита "Организация" или для нее не задан префикс, то 
	// используем пустой префикс,
	// иначе используем префикс организации.
	МетаданныеДокумента = ДокументОбъект.Метаданные();

	Если Не ЕстьРеквизитДокумента("Организация", МетаданныеДокумента)
	 Или ЗначениеНеЗаполнено(ДокументОбъект.Организация.Префикс) Тогда

		ДокументОбъект.УстановитьНовыйНомер("00");

	Иначе

		ДокументОбъект.УстановитьНовыйНомер(ДокументОбъект.Организация.Префикс);
        		
	КонецЕсли;
	
КонецПроцедуры // УстановитьНомерДокумента()

// { RGS ASeryakov, 12.01.2019 14:42:45 S-I-0004945
// Процедура устанавливает номер справочника.
// ипользуется в случае, если механизм платформы некорректно устанавливает новый неуникальный код 
// при записи нового объекта или использовании метода объекта УстановитьНовыйКод (SetNewCode)
//
// Параметры:
// СправочникОбъект  - СправочникОбъект. Экземпляр справочника, которому необходимо присвоить новый номер
//
Процедура УстановитьНомерСправочника(СправочникОбъект) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	ИмяТаблицы.Код КАК Код
		|ИЗ
		|	Справочник.ИмяТаблицы КАК ИмяТаблицы
		|
		|УПОРЯДОЧИТЬ ПО
		|	ИмяТаблицы.Код УБЫВ";
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "ИмяТаблицы", СправочникОбъект.Метаданные().Имя);
	РезультатЗапроса = Запрос.Выполнить();
	Выборка = РезультатЗапроса.Выбрать();
	Выборка.Следующий();
	
	СправочникОбъект.Код = ?(ТипЗнч(Выборка.Код) = Тип("Число"), Выборка.Код + 1, СтрЗаменить(Строка(Число(Выборка.Код)+1), Символы.НПП, ""));
	
	УстановитьПривилегированныйРежим(Ложь);
	
КонецПроцедуры // } RGS ASeryakov 12.01.2019 14:43:00 S-I-0004945


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МЕХАНИЗМОМ ОТПРАВКИ СООБЩЕНИЙ В ОТДЕЛ ТЕХНИЧЕСКОЙ ПОДДЕРЖКИ ПОЛЬЗОВАТЕЛЕЙ

// Функнция проверяет заполнения обязательных параметров для отправки сообщения
//  в отдел технической поддержки.
//
// Параметры
//  ТаблицаДанных - Таблица значений
//
// Возвращаемое значение:
//   Булево - результат корректости проверки
//
Функция ПроверитьСтруктуруЗаполненияПараметровДляОтправкиСообщенияВОтделТехническойПоддержки(ТаблицаДанных, ПубликоватьСообщения = Истина) Экспорт

	ЗначениеПроверки = Истина;
	СтрокаЗаголовкаОшибки = "Не заполнены настройки для отправки сообщения.";
	
	СписокИменОбязательныхРеквизитов = Новый СписокЗначений;
	СписокИменОбязательныхРеквизитов.Добавить("ПараметрыОтправкиЭлектронногоСообщения_АдресЭлектроннойПочтыОтделаТехническойПоддержки");
	СписокИменОбязательныхРеквизитов.Добавить("ПараметрыОтправкиЭлектронногоСообщения_АдресЭлектроннойПочтыОтправителя");
	СписокИменОбязательныхРеквизитов.Добавить("ПараметрыОтправкиЭлектронногоСообщения_АдресCервераSMTP");
	СписокИменОбязательныхРеквизитов.Добавить("ПараметрыОтправкиЭлектронногоСообщения_ПортSMTP");
	СписокИменОбязательныхРеквизитов.Добавить("ОсновныеДанные_РегистрационныйНомерПрограммы");
	СписокИменОбязательныхРеквизитов.Добавить("Владелец_Организация");
	
	Для каждого СтрокаРаздела Из ТаблицаДанных Цикл
		Для каждого ЭлементЗначения Из СтрокаРаздела.ДанныеРаздела Цикл
			Если СписокИменОбязательныхРеквизитов.НайтиПоЗначению(ЭлементЗначения.Ключ) <> Неопределено И ЗначениеНеЗаполнено(ЭлементЗначения.Значение[1]) Тогда
				Если ПубликоватьСообщения Тогда
					СообщитьОбОшибке("Не указан """ + Лев(ЭлементЗначения.Значение[0], (СтрДлина(ЭлементЗначения.Значение[0]) - 1)) + """.",, СтрокаЗаголовкаОшибки);
				КонецЕсли; 
				ЗначениеПроверки = Ложь;
			КонецЕсли; 
		КонецЦикла; 
	КонецЦикла;
	
	Возврат ЗначениеПроверки;

КонецФункции // ПроверитьСтруктуруЗаполненияПараметровДляОтправкиСообщенияВОтделТехническойПоддержки()

// Функция формирует текст сообщения на линию техподдержки
//
// Параметры
//  НЕТ
//
// Возвращаемое значение:
//   Текст сообщения
//
Функция ПолучитьТекстСообщенияВОтделТехническойПоддержки() Экспорт

	ТекстВозврата = "";
	
	ТекстВозврата = ТекстВозврата + Символы.ПС;
	ТекстВозврата = ТекстВозврата + Символы.ПС;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "============ Сведения об использовании ПП 1С:Предприятие 8.0 ============";
	
	ТаблицаДанных = Константы.ПараметрыСообщенияПриОбращенииВОтделТехническойПоддержки.Получить().Получить();
	
	// Сформируем обязательный информационный раздел
	
	СистемИнфо = Новый СистемнаяИнформация;
	
	ТекстВозврата = ТекстВозврата + Символы.ПС;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "1. ДАННЫЕ ТЕКУЩЕГО КОМПЬЮТЕРА И КОНФИГУРАЦИИ";
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Версия 1С:Предприятия 8.0: " + СистемИнфо.ВерсияПриложения;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Конфигурация: "              + Метаданные.Синоним;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Версия конфигурации: "       + Метаданные.Версия;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Поставщик: "                 + Метаданные.Поставщик;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Операционная система: "      + СистемИнфо.ВерсияОС;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Оперативная память (МБ): "   + СистемИнфо.ОперативнаяПамять;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Процессор: "                 + СистемИнфо.Процессор;

	НомерСтрокиРаздела = 1;
	
	Если ТипЗнч(ТаблицаДанных) = Тип("ТаблицаЗначений") Тогда
		
		Для каждого СтрокаТаблицыРаздела Из ТаблицаДанных Цикл
			
			СтрокаРаздела = "";
			
			Если СтрокаТаблицыРаздела.ИмяРаздела = "ПараметрыОтправкиЭлектронногоСообщения" Тогда
				Продолжить;
			КонецЕсли;
			
			Для каждого ЭлементЗначения Из СтрокаТаблицыРаздела.ДанныеРаздела Цикл
				Если ЗначениеНеЗаполнено(ЭлементЗначения.Значение[1]) Тогда
					Продолжить;
				КонецЕсли; 
				СтрокаРаздела = СтрокаРаздела + Символы.ПС + ЭлементЗначения.Значение[0] + " " + ?(ТипЗнч(ЭлементЗначения.Значение[1]) = Тип("Булево"), ?(ЭлементЗначения.Значение[1], "Да", "Нет"), ЭлементЗначения.Значение[1]);
			КонецЦикла; 
			
			Если ЗначениеНеЗаполнено(СтрокаРаздела) Тогда
				Продолжить;
			КонецЕсли;
			
			НомерСтрокиРаздела = НомерСтрокиРаздела + 1;
			
			СтрокаРаздела = Строка(НомерСтрокиРаздела) + ". " + ВРег(СтрокаТаблицыРаздела.ПредставлениеРаздела) + СтрокаРаздела;
			
			ТекстВозврата = ТекстВозврата + Символы.ПС;
			ТекстВозврата = ТекстВозврата + Символы.ПС + СтрокаРаздела;
		
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат ТекстВозврата;

КонецФункции // ПолучитьТекстСообщенияВОтделТехническойПоддержки()


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ТИПАМИ

// Служебная функция, предназначенная для получения описания типов строки, заданной длины.
// 
// Параметры:
//  ДлинаСтроки - число, длина строки.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" для строки указанной длины.
//
Функция ПолучитьОписаниеТиповСтроки(ДлинаСтроки) Экспорт

	Массив = Новый Массив; 
	Массив.Добавить(Тип("Строка"));

	КвалификаторСтроки = Новый КвалификаторыСтроки(ДлинаСтроки, ДопустимаяДлина.Переменная);

	Возврат Новый ОписаниеТипов(Массив, , КвалификаторСтроки);

КонецФункции // ПолучитьОписаниеТиповСтроки()

// Служебная функция, предназначенная для получения описания типов числа, заданной разрядности.
// 
// Параметры:
//  Разрядность 			- число, разряд числа.
//  РазрядностьДробнойЧасти - число, разряд дробной части.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" для числа указанной разрядности.
//
Функция ПолучитьОписаниеТиповЧисла(Разрядность,РазрядностьДробнойЧасти=0) Экспорт

	Массив = Новый Массив;

	Массив.Добавить(Тип("Число"));
	КвалификаторЧисла = Новый КвалификаторыЧисла(Разрядность,РазрядностьДробнойЧасти);

	Возврат Новый ОписаниеТипов(Массив, КвалификаторЧисла);

КонецФункции // ПолучитьОписаниеТиповЧисла() 

// Служебная функция, предназначенная для получения описания типов даты
// 
// Параметры:
//  ЧастиДаты - системное перечисление ЧастиДаты.
// 
Функция ПолучитьОписаниеТиповДаты(ЧастиДаты) Экспорт

	Массив = Новый Массив;
	Массив.Добавить(Тип("Дата"));

	КвалификаторДаты = Новый КвалификаторыДаты(ЧастиДаты);

	Возврат Новый ОписаниеТипов(Массив, , , КвалификаторДаты);

КонецФункции // ПолучитьОписаниеТиповДаты() 


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ПЕРЕЧИСЛЕНИЯМИ

// Функция формирует список элементов перечисления
//
// Параметры
//  ИмяПеречисления - имя перечисления, как оно задано в конфигураторе
//
// Возвращаемое значение:
//   СписокЗначений - список элементов перечисления
//
Функция ПолучитьСписокЭлементовПеречисления(ИмяПеречисления) Экспорт

	СписокЭлементовПеречисления = Новый СписокЗначений;
	
	Попытка
		КоллекцияЭлементовПеречисления = Перечисления[ИмяПеречисления];
	Исключение
		Возврат СписокЭлементовПеречисления;
	КонецПопытки;
	
	Для каждого ЭлементПеречисления Из КоллекцияЭлементовПеречисления Цикл
		СписокЭлементовПеречисления.Добавить(ЭлементПеречисления, Строка(ЭлементПеречисления));
	КонецЦикла;
	
	Возврат СписокЭлементовПеречисления;

КонецФункции // ПолучитьСписокЭлементовПеречисления()


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МЕТАДАННЫМИ

// Функция возвращает имя табличной части, к которой принадлежит переданная строка
//
// Параметры
//  СтрокаТабличнойЧасти - ссылка на строку табличной части
//
// Возвращаемое значение:
//   Строка - имя табличной части, как оно задано в конфигураторе
//
Функция ПолучитьИмяТабличнойЧастиПоСсылкеНаСтроку(СтрокаТабличнойЧасти) Экспорт

	Возврат Метаданные.НайтиПоТипу(ТипЗнч(СтрокаТабличнойЧасти)).Имя;

КонецФункции // ПолучитьИмяТабличнойЧастиПоСсылкеНаСтроку()

// Функция возвращает метаданные документа, которому принадлежит переданная строка
//
// Параметры
//  СтрокаТабличнойЧасти - ссылка на строку табличной части
//
// Возвращаемое значение:
//   Метаданные - метаданные документа, как оно задано в конфигураторе
//
Функция ПолучитьМетаданныеДокументаПоСсылкеНаСтроку(СтрокаТабличнойЧасти) Экспорт

	Возврат Метаданные.НайтиПоТипу(ТипЗнч(СтрокаТабличнойЧасти)).Родитель();

КонецФункции // ПолучитьМетаданныеДокументаПоСсылкеНаСтроку()


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ДВИЖЕНИЯМИ ДОКУМЕНТОВ

// Формирует структуру, содержащую значения реквизитов шапки документа.
//
// Параметры: 
//  ДокументОбъект - объект документа для формирования структуры шапки, 
//
// Возвращаемое значение:
//  Сформированная структура.
//
Функция СформироватьСтруктуруШапкиДокумента(ДокументОбъект) Экспорт

	ВалютаРегламентированногоУчета = Константы.ВалютаРегламентированногоУчета.Получить();

	// Первоначальные данные о документе.
	СтруктураШапкиДокумента = Новый Структура;
	СтруктураШапкиДокумента.Вставить("Ссылка", ДокументОбъект.Ссылка);
	СтруктураШапкиДокумента.Вставить("Дата",   ДокументОбъект.Дата);
	Если СтруктураШапкиДокумента.Свойство("ДатаПроведения") Тогда
		СтруктураШапкиДокумента.Вставить("ДатаПроведения",   ДокументОбъект.ДатаПроведения);
	КонецЕсли;
	Если СтруктураШапкиДокумента.Свойство("НалоговыйПериод") Тогда
		СтруктураШапкиДокумента.Вставить("НалоговыйПериод",  ДокументОбъект.НалоговыйПериод);
	КонецЕсли;
	СтруктураШапкиДокумента.Вставить("Номер",  ДокументОбъект.Номер);

	МетаданныеДокумента = ДокументОбъект.Метаданные();
	СтруктураШапкиДокумента.Вставить("ВидДокумента",  МетаданныеДокумента.Имя);
	СтруктураШапкиДокумента.Вставить("ПредставлениеВидаДокумента",  МетаданныеДокумента.Представление());
    
	Для каждого Реквизит из МетаданныеДокумента.Реквизиты Цикл
		СтруктураШапкиДокумента.Вставить(Реквизит.Имя, ДокументОбъект[Реквизит.Имя]);
	КонецЦикла;

	// Отображение данных о валютах.
	СтруктураШапкиДокумента.Вставить("ВалютаРегламентированногоУчета", ВалютаРегламентированногоУчета);	

	Если СтруктураШапкиДокумента.Свойство("ВалютаДокумента") Тогда
		СтруктураШапкиДокумента.Вставить("КурсДокумента",      КурсДокумента(ДокументОбъект, ВалютаРегламентированногоУчета));
		СтруктураШапкиДокумента.Вставить("КратностьДокумента", КратностьДокумента(ДокументОбъект, ВалютаРегламентированногоУчета));

	КонецЕсли;
	
	// Установка флага применения положений ПБУ 18/02.
	Если СтруктураШапкиДокумента.Свойство("Организация") Тогда
		
		Если ПрименениеПБУ18(СтруктураШапкиДокумента.Организация, СтруктураШапкиДокумента.Дата) Тогда
			СтруктураШапкиДокумента.Вставить("ПрименениеПБУ18", Истина);
		Иначе
			СтруктураШапкиДокумента.Вставить("ПрименениеПБУ18", Ложь);
		КонецЕсли;
		
	КонецЕсли;
		
	// Отображение обязательных данных о договоре.
	Если СтруктураШапкиДокумента.Свойство("ДоговорКонтрагента") Тогда

		Если ТипЗнч(СтруктураШапкиДокумента.ДоговорКонтрагента) = Тип("СправочникСсылка.ДоговорыКонтрагентов") тогда

			СтруктураШапкиДокумента.Вставить("ВедениеВзаиморасчетов",    СтруктураШапкиДокумента.ДоговорКонтрагента.ВедениеВзаиморасчетов);
			СтруктураШапкиДокумента.Вставить("ВалютаВзаиморасчетов",     СтруктураШапкиДокумента.ДоговорКонтрагента.ВалютаВзаиморасчетов);
			СтруктураШапкиДокумента.Вставить("РасчетыВУсловныхЕдиницах", СтруктураШапкиДокумента.ДоговорКонтрагента.РасчетыВУсловныхЕдиницах);

		КонецЕсли;

	КонецЕсли;

	Возврат СтруктураШапкиДокумента;

КонецФункции // СформироватьСтруктуруШапкиДокумента()

// Формирует структуру дерева значений, содержащего имена полей, которые
// нужно заполнить в запросе по шапке документа.
//
// Параметры: 
//  Нет.
//
// Возвращаемое значение:
//  Дерево значений.
//
Функция СформироватьДеревоПолейЗапросаПоШапке()  Экспорт

	ДеревоПолейЗапросаПоШапке = Новый ДеревоЗначений;
	ОписаниеТиповСтрока       = ПолучитьОписаниеТиповСтроки(100);

	ДеревоПолейЗапросаПоШапке.Колонки.Добавить("Объект"   , ОписаниеТиповСтрока);
	ДеревоПолейЗапросаПоШапке.Колонки.Добавить("Поле"     , ОписаниеТиповСтрока);
	ДеревоПолейЗапросаПоШапке.Колонки.Добавить("Псевдоним", ОписаниеТиповСтрока);

	Возврат ДеревоПолейЗапросаПоШапке;

КонецФункции // СформироватьДеревоПолейЗапросаПоШапке()

// Вставляет строку в дерево полей запроса по шапке, если ее там еще нет,
// если есть, то ничего не делает.
//
// Параметры:
//  ДеревоПолейЗапросаПоШапке - дерево значений, содержащего имена полей, 
//                              которые нужно заполнить в запросе по шапке документа, 
//  ИмяОбъекта                - строка, имя объекта (справочник, регистр и т.д.), 
//  ИмяПоля                   - строка, имя поля объекта,
//  ИмяПсевдонима             - строка, имя псевдонима в запросе поля объекта (необязательный).
//
Процедура ДобавитьСтрокуВДеревоПолейЗапросаПоШапке(ДеревоПолейЗапросаПоШапке, ИмяОбъекта, ИмяПоля, ИмяПсевдонима = Неопределено) Экспорт

	// Поищем нужную строку.
	// Вначале ищем объект.
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти(ИмяОбъекта, "Объект");

	Если СтрокаОбъекта = Неопределено Тогда // нужно добавить.

		СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Добавить();

		СтрокаОбъекта.Объект    = ИмяОбъекта;
		СтрокаОбъекта.Поле      = ИмяПоля;
		СтрокаОбъекта.Псевдоним = ИмяПсевдонима;

	КонецЕсли;

	// Ищем поле.
	//СтрокаПоля = СтрокаОбъекта.Строки.СтрНайти(ИмяПоля,"Поле");   //Flp
	СтрокаПоля = СтрокаОбъекта.Строки.Найти(ИмяПоля,"Поле");

	Если СтрокаПоля = Неопределено Тогда // нужно добавить

		СтрокаПоля = СтрокаОбъекта.Строки.Добавить();

		СтрокаПоля.Поле      = ИмяПоля;
		СтрокаПоля.Псевдоним = ИмяПсевдонима;

	КонецЕсли;

	// Ищем псевдоним.
	СтрокаПоля = СтрокаОбъекта.Строки.Найти( ИмяПсевдонима, "Псевдоним");

	Если СтрокаПоля = Неопределено Тогда // нужно добавить

		СтрокаПоля = СтрокаОбъекта.Строки.Добавить();

		СтрокаПоля.Поле      = ИмяПоля;
		СтрокаПоля.Псевдоним = ИмяПсевдонима;

	КонецЕсли;

КонецПроцедуры // ДобавитьСтрокуВДеревоПолейЗапросаПоШапке()

// Выполняет движение по регистру.
//
// Параметры:
//  НаборДвижений   - набор движений регистра. 
//
Процедура ВыполнитьДвижениеПоРегистру(НаборДвижений, ВидДвижения = Неопределено) Экспорт

	ТаблицаДвижений = НаборДвижений.мТаблицаДвижений;
	Если ТаблицаДвижений.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
    Если ТаблицаДвижений.Колонки.Найти("Период") = Неопределено Тогда
		ТаблицаДвижений.Колонки.Добавить("Период", ПолучитьОписаниеТиповДаты(ЧастиДаты.ДатаВремя))
	КонецЕсли;
	
	МетаРег = НаборДвижений.Метаданные();
	ИзмеренияСостТипа = Новый Структура;

	Для Каждого МетаИзм Из МетаРег.Измерения Цикл
		Если МетаИзм.Тип.Типы().Количество() > 1 Тогда
			ИзмеренияСостТипа.Вставить(МетаИзм.Имя);
		КонецЕсли;
	КонецЦикла;

	Для Каждого МетаИзм Из МетаРег.Реквизиты Цикл
		Если МетаИзм.Тип.Типы().Количество() > 1 Тогда
			ИзмеренияСостТипа.Вставить(МетаИзм.Имя);
		КонецЕсли;
	КонецЦикла;

	Для Каждого МетаРес Из МетаРег.Ресурсы Цикл
		Если МетаРес.Тип.Типы().Количество() > 1 Тогда
			ИзмеренияСостТипа.Вставить(МетаРес.Имя);
		КонецЕсли;
	КонецЦикла;

	// Откопируем остальные колонки (структура таблиц совпадает).
	ПерваяКолонка = Истина;
	МассивСтрок   = Новый Массив(ТаблицаДвижений.Количество());

	Для каждого Колонка Из ТаблицаДвижений.Колонки Цикл

		ИмяКолонки = Колонка.Имя;
		
		Если ИмяКолонки <> "Период"
		   И ИмяКолонки <> "Активность"
		   И ИмяКолонки <> "НомерСтроки"
		   И ИмяКолонки <> ""
		   И ?(ИмяКолонки = "ВидДвижения", ВидДвижения = Неопределено, Истина)
		   И ИмяКолонки <> "МоментВремени" Тогда

			ФлагКолонкиСостТипа = (ИзмеренияСостТипа.Свойство(ИмяКолонки));

			Индекс = 0;

			Для каждого СтрокаТаблицы Из ТаблицаДвижений Цикл

				Если ПерваяКолонка Тогда

					Если ВидДвижения = ВидДвиженияНакопления.Приход Тогда
						СтрокаДвижения = НаборДвижений.ДобавитьПриход();
					ИначеЕсли ВидДвижения = ВидДвиженияНакопления.Расход Тогда
						СтрокаДвижения = НаборДвижений.ДобавитьРасход();
					Иначе
						СтрокаДвижения = НаборДвижений.Добавить(); // Для оборотных регистров
					КонецЕсли;

					МассивСтрок[Индекс] = СтрокаДвижения;
					Если СтрокаТаблицы.Период = '00010101' Тогда
						СтрокаДвижения.Период = НаборДвижений.мПериод;
					Иначе
						СтрокаДвижения.Период = СтрокаТаблицы.Период;
					КонецЕсли; 

				Иначе

					СтрокаДвижения = МассивСтрок[Индекс];

				КонецЕсли;

				Индекс = Индекс + 1;

				ЗначКолонки = СтрокаТаблицы[ИмяКолонки];
				Если ФлагКолонкиСостТипа Тогда
					Если ЗначКолонки = Неопределено ИЛИ ЗначКолонки.Пустая() Тогда
						СтрокаДвижения[ИмяКолонки] = Неопределено;
					Иначе
						СтрокаДвижения[ИмяКолонки] = ЗначКолонки;
					КонецЕсли;
				Иначе
					СтрокаДвижения[ИмяКолонки] = ЗначКолонки;
				КонецЕсли;

			КонецЦикла;

			ПерваяКолонка = Ложь;

		КонецЕсли;

	КонецЦикла;

КонецПроцедуры // ВыполнитьДвижениеПоРегистру()

// Процедура удаления существующих движений документа при перепроведении (отмене проведения)
//
Процедура УдалитьДвиженияРегистратора(ДокументОбъект, Отказ, СтруктураВидовУчета = Неопределено, ВыборочноОчищатьРегистры = Ложь, РежимПроведенияДокумента=неопределено) Экспорт
	//ДАННАЯ ПРОЦЕДУРА БЫЛА ВЗЯТА ИЗ УПП И ДОРАБОТАНА
	
	МассивОбрабатываемыхСтрокТаблицыДвижений = Новый Массив();
	
	// получение списка регистров, по которым существуют движения
	ТаблицаДвижений = ПолныеПрава.ОпределитьНаличиеДвиженийПоРегистратору(ДокументОбъект.Ссылка);
	
	ТаблицаДвижений.Колонки.Добавить("ИмяРегистра", Новый ОписаниеТипов("Строка",, Новый КвалификаторыСтроки(200)));
    ТаблицаДвижений.Колонки.Добавить("ТипРегистра", Новый ОписаниеТипов("Строка",, Новый КвалификаторыСтроки(100)));
	ТаблицаДвижений.Колонки.Добавить("УдалитьДвиженияСКонтролемПравДоступа", Новый ОписаниеТипов("Булево"));
	ТаблицаДвижений.Колонки.Добавить("ОчищатьКоллекцию", Новый ОписаниеТипов("Булево"));
	
	// Используется для оптимизации перезаписи движений платформой, для этого необходимо не удалять движения
	ТаблицаДвижений.Колонки.Добавить("УдалятьДвижения", Новый ОписаниеТипов("Булево"));
	
	Если ВыборочноОчищатьРегистры
		И ТаблицаДвижений.Количество() > 0 Тогда
		
		РегистрыДляОптимизацииПерезаписиДвижений = ПолучитьРегистрыДляОптимизацииПерезаписиДвижений(РежимПроведенияДокумента);
	КонецЕсли;
	
	// Получим список регистров, движения которых необходимо удалять с контролем прав доступа
	РегистрыДляУдаленияСКонтролемПравДоступа = ПолучитьРегистрыДляУдаленияСКонтролемПравДоступа();
	
	// Переменные логики отложенного проведения
	ДокументИспользуетсяВОтложенномПроведении = Ложь;
	ВыполняетсяДопроведение                   = Ложь;
	ПроведениеПоВсемВидамУчета                = Ложь;
	
	// Используется при проведении документа ПринятиеКУчетуОС
	//ПроверитьПринадлежностьРегистраКВидамУчета = (СтруктураВидовУчета <> Неопределено И ТипЗНЧ(СтруктураВидовУчета) = Тип("Структура"));
	
	//Если ПроверитьПринадлежностьРегистраКВидамУчета Тогда
	//	
	//	РегистрыПоВидамУчета = ПолучитьРегистрыПоВидамУчета();
	//	
	//Иначе
	//	
	//	СтруктураПараметровПроведения = ОтложенноеПроведениеДокументов.ПолучитьПараметрыПроведенияДокумента(ДокументОбъект);
	//	ДокументИспользуетсяВОтложенномПроведении = СтруктураПараметровПроведения.ДокументИспользуетсяВОтложенномПроведении;
	//	
	//	Если ДокументИспользуетсяВОтложенномПроведении Тогда
	//		ВыполняетсяДопроведение = СтруктураПараметровПроведения.ВыполняетсяДопроведение;
	//		ПроведениеПоВсемВидамУчета = СтруктураПараметровПроведения.ПроведениеПоВсемВидамУчета;
	//		РегистрыОтложенногоПроведения = ОтложенноеПроведениеДокументов.ПолучитьРегистрыОтложенногоПроведения();
	//	КонецЕсли;
	//	
	//КонецЕсли; 
	
	//СтруктураПараметровПроведения = ОтложенноеПроведениеДокументов.ПолучитьПараметрыПроведенияДокумента(ДокументОбъект);
	//ДокументИспользуетсяВОтложенномПроведении = СтруктураПараметровПроведения.ДокументИспользуетсяВОтложенномПроведении;
	//
	//Если ДокументИспользуетсяВОтложенномПроведении Тогда
	//	ВыполняетсяДопроведение = СтруктураПараметровПроведения.ВыполняетсяДопроведение;
	//	ПроведениеПоВсемВидамУчета = СтруктураПараметровПроведения.ПроведениеПоВсемВидамУчета;
	//	РегистрыОтложенногоПроведения = ОтложенноеПроведениеДокументов.ПолучитьРегистрыОтложенногоПроведения();
	//КонецЕсли;
	
	// Сформируем список, содержащий строки таблицы ТаблицаДвижений,
	// который будет использовать для удаления движений
	Для Каждого СтрокаДвижения ИЗ ТаблицаДвижений Цикл
		
		// Имя регистра передается как значение, 
		// полученное с помощью функции ПолноеИмя() метаданных регистра
		ПозицияТочки = СтрНайти(СтрокаДвижения.Имя, ".");
		ТипРегистра = Лев(СтрокаДвижения.Имя, ПозицияТочки - 1);
		ИмяРегистра = СокрП(Сред(СтрокаДвижения.Имя, ПозицияТочки + 1));
		
		// необходимо очищать только те регистры, которые относятся к видам учета по которым перепроводиться документ
		//Если ПроверитьПринадлежностьРегистраКВидамУчета Тогда
		//	
		//	Если НЕ ОпределитьПринадлежностьРегистраКВидамУчета(ИмяРегистра, СтруктураВидовУчета, РегистрыПоВидамУчета) Тогда
		//		Продолжить;
		//	КонецЕсли;
		//	
		//КонецЕсли;	
		
		СтрокаДвижения.УдалятьДвижения = Истина;
		
		СтрокаДвижения.ИмяРегистра = ИмяРегистра;
		СтрокаДвижения.ТипРегистра = ТипРегистра;
		
		Если ВыборочноОчищатьРегистры Тогда
			ПараметрыРегистра = Неопределено;
			Если РегистрыДляОптимизацииПерезаписиДвижений.Свойство(ИмяРегистра, ПараметрыРегистра) Тогда
				СтрокаДвижения.УдалятьДвижения = Ложь;
				СтрокаДвижения.ОчищатьКоллекцию = ПараметрыРегистра.ОчищатьКоллекцию;
			КонецЕсли; 
		КонецЕсли;
		
		//Если ДокументИспользуетсяВОтложенномПроведении Тогда
		//	Если ВыполняетсяДопроведение Тогда
		//		//	Если выполняется допроведение, то удаляются только движения по регистрам, 
		//		//	которые формируются при отложенном проведении
		//		Если РегистрыОтложенногоПроведения.Найти(СокрЛП(СтрокаДвижения.Имя)) = Неопределено Тогда
		//			Продолжить;
		//		КонецЕсли;
		//	Иначе
		//		// Документ проводится в режиме отложенного проведения
		//		
		//		// Если для документа выключен режим проведения "по всем видам учета", 
		//		// то всегда удаляются движения по регистрам, которые формируются при допроведении
		//		Если НЕ СтрокаДвижения.УдалятьДвижения
		//			И НЕ ПроведениеПоВсемВидамУчета 
		//			И РегистрыОтложенногоПроведения.Найти(ИмяРегистра) <> Неопределено Тогда
		//			
		//			СтрокаДвижения.УдалятьДвижения = Истина;
		//		КонецЕсли;
		//	КонецЕсли; 
		//КонецЕсли; 
		
		Если РегистрыДляУдаленияСКонтролемПравДоступа.Свойство(ИмяРегистра) Тогда
			// Проверка права "Изменение" до удаления движений
			
			СтрокаДвижения.УдалитьДвиженияСКонтролемПравДоступа = Истина;
			
			Если ТипРегистра = "РегистрНакопления" Тогда
				МетаданныеНабора = Метаданные.РегистрыНакопления[ИмяРегистра];
				
			ИначеЕсли ТипРегистра = "РегистрБухгалтерии" Тогда
				МетаданныеНабора = Метаданные.РегистрыБухгалтерии[ИмяРегистра];
				
			ИначеЕсли ТипРегистра = "РегистрСведений" Тогда
				МетаданныеНабора = Метаданные.РегистрыСведений[ИмяРегистра];
				
			ИначеЕсли ТипРегистра = "РегистрРасчета" Тогда
				МетаданныеНабора = Метаданные.РегистрыРасчета[ИмяРегистра];
				
			КонецЕсли;
			
			Если НЕ ПравоДоступа("Изменение", МетаданныеНабора) Тогда
				Отказ = Истина;
				ВызватьИсключение "Нарушение прав доступа. " + СокрП(СтрокаДвижения.Имя);
			КонецЕсли;
			
		КонецЕсли;
		
		МассивОбрабатываемыхСтрокТаблицыДвижений.Добавить(СтрокаДвижения);		
		
	КонецЦикла;	

	// Выполним удаление движений и очистку коллекции движений
	Для Каждого СтрокаДвижения ИЗ МассивОбрабатываемыхСтрокТаблицыДвижений Цикл
		
		Если СтрокаДвижения.УдалятьДвижения Тогда
			
			Если СтрокаДвижения.УдалитьДвиженияСКонтролемПравДоступа Тогда
				НаборЗаписей = ДокументОбъект.Движения[СтрокаДвижения.ИмяРегистра];
				НаборЗаписей.Очистить(); // Коллекция может быть не пустой
				
				Попытка
					НаборЗаписей.Записать();
				Исключение
					// возможно "сработал" RLS или механизм даты запрета изменения
					СообщитьОбОшибке(ОписаниеОшибки(), Отказ, СокрП(СтрокаДвижения.Имя));
					ВызватьИсключение "Операция не выполнена";
				КонецПопытки;
			Иначе
				ПолныеПрава.ЗаписатьНаборЗаписейНаСервере(СтрокаДвижения.ИмяРегистра, ДокументОбъект.Ссылка,, СтрокаДвижения.ТипРегистра);
			КонецЕсли;
			
		Иначе
			
			Если СтрокаДвижения.ОчищатьКоллекцию Тогда
				ДокументОбъект.Движения[СтрокаДвижения.ИмяРегистра].Очистить();	
			КонецЕсли;

		КонецЕсли;
		
	КонецЦикла;
	
	ОчисткаКоллекцииДвиженийДокумента(ДокументОбъект);
	
	// Удаление записей регистрации из всех последовательностей
	//УдалитьРегистрациюДокументаВПоследовательностях(ДокументОбъект, Истина);
	
КонецПроцедуры

// Функция возвращает структуру, содержащую 
// 1. имена регистров, движения которых не надо удалять - они не используются 
// 		в процедурах контроля остатков (товаров, задолженностей)
// 		при формировании движений (например, партии, авансы)
// 2. Параметры регистра, содержащие:
// 		- признак необходимости очистки коллекции движений документа
//
Функция ПолучитьРегистрыДляОптимизацииПерезаписиДвижений(ТекущийРежимПроведенияДокумента)
	
	СтруктураРегистров = Новый Структура;
	
	ДобавитьРегистрВСтруктуруРегистров(СтруктураРегистров, "ПроводкиDSSОбщие", Ложь);
	ДобавитьРегистрВСтруктуруРегистров(СтруктураРегистров, "ПроводкиDSS_FA", Ложь);
	
	Возврат СтруктураРегистров;
	
КонецФункции // ПолучитьРегистрыДляОптимизацииПерезаписиДвижений

// Процедура вызывается из ПолучитьРегистрыДляОптимизацииПерезаписиДвижений
//
Процедура ДобавитьРегистрВСтруктуруРегистров(СтруктураРегистров, ИмяРегистра, ОчищатьКоллекцию = Истина)

	ПараметрыРегистра = Новый Структура("ОчищатьКоллекцию", ОчищатьКоллекцию);
	СтруктураРегистров.Вставить(ИмяРегистра, ПараметрыРегистра);
	
КонецПроцедуры // ДобавитьРегистрВСтруктуруРегистров

// Процедура очищает коллекцию движений документа
//
Процедура ОчисткаКоллекцииДвиженийДокумента(ДокументОбъект)
		
	Для Каждого Движение ИЗ ДокументОбъект.Движения Цикл
		// Очистим не пустые коллекции движений
		Если Движение.Количество() > 0 Тогда
			Движение.Очистить();
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Функция возвращает структуру, содержащую имена регистров 
// движения, которых необходимо удалять с контролем правам доступа (не привилегированно)
//
Функция ПолучитьРегистрыДляУдаленияСКонтролемПравДоступа()
	
	РегистрыКУдалениюНеПривилегированно = Новый Структура;
	
	РегистрыКУдалениюНеПривилегированно.Вставить("ПроводкиDSSОбщие");
	
	Возврат	РегистрыКУдалениюНеПривилегированно

КонецФункции // ПолучитьРегистрыДляУдаленияСКонтролемПравДоступа

Процедура ОчиститьТаблицуОтСтрокСПустымиРеквизитами(Таблица, СтрокаИменПустыхРеквизитов) Экспорт
	
	МассивИменПроверяемыхРеквизитов = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(СтрокаИменПустыхРеквизитов);
	ИндексСтроки = 0;
	Пока ИндексСтроки < Таблица.Количество() Цикл
		
		Строка = Таблица[ИндексСтроки];			
		СтрокаПустая = Истина;
		Для Каждого ИмяРеквизита Из МассивИменПроверяемыхРеквизитов Цикл
			
			Если ЗначениеЗаполнено(Строка[ИмяРеквизита]) Тогда
				СтрокаПустая = Ложь;
				Прервать;
			КонецЕсли;
			
		КонецЦикла;
		
		Если СтрокаПустая Тогда
			Таблица.Удалить(ИндексСтроки);
		Иначе
			ИндексСтроки = ИндексСтроки + 1;
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// { RGS LFedotova 25.10.2016 12:43:06 - вопрос SLI-0006888
Процедура ПроверитьДвиженияПозжеДатыДокумента(ЭтотОбъект, Отказ) Экспорт

	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	СтоимостьАмортизацияОСОбороты.ОсновноеСредство КАК ОсновноеСредство,
		|	СтоимостьАмортизацияОСОбороты.Регистратор,
		|	СтоимостьАмортизацияОСОбороты.Период КАК Период
		|ИЗ
		|	РегистрНакопления.СтоимостьАмортизацияОС.Обороты(&ДатаДок, , Регистратор, ОсновноеСредство В (&СписокОС)) КАК СтоимостьАмортизацияОСОбороты
		|ГДЕ
		|	НЕ СтоимостьАмортизацияОСОбороты.Регистратор ССЫЛКА Документ.НачислениеАмортизации
		|
		|УПОРЯДОЧИТЬ ПО
		|	Период
		|ИТОГИ ПО
		|	ОсновноеСредство";
	
	Запрос.УстановитьПараметр("ДатаДок", ЭтотОбъект.Дата+1);
	Запрос.УстановитьПараметр("СписокОС", ЭтотОбъект.ОС.ВыгрузитьКолонку("ОсновноеСредство"));
	
	РезультатЗапроса = Запрос.Выполнить();
	
	ВыборкаОсновноеСредство = РезультатЗапроса.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
	
	Пока ВыборкаОсновноеСредство.Следующий() Цикл
			
		ВыборкаДетальныеЗаписи = ВыборкаОсновноеСредство.Выбрать();
	
		Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
			Сообщить("По основному средству " + ВыборкаДетальныеЗаписи.ОсновноеСредство + " существуют более поздние движения.");
			Отказ = Истина;
			Прервать;
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры
// } RGS LFedotova 25.10.2016 12:43:23 - вопрос SLI-0006888

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ПОСЛЕДОВАТЕЛЬНОСТЯМИ

// Сдвиг ГП назад при необходимости.
//
Процедура СдвигПоследовательностиНазад(ИмяПоследовательности, Дата, Ссылка, Измерения = Неопределено) Экспорт

	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ТекущаяПоследовательностьГраницы.МоментВремени
	|ИЗ
	|	Последовательность."+ИмяПоследовательности+".Границы КАК ТекущаяПоследовательностьГраницы
	| ";
	
	Если Не( Измерения = Неопределено ) Тогда
		Запрос.Текст = Запрос.Текст+"
		|ГДЕ";
		
		Для каждого Измерение из Измерения Цикл
			Запрос.Текст = Запрос.Текст+"
			|	ТекущаяПоследовательностьГраницы."+Измерение.Ключ +"  = &"+Измерение.Ключ;
			Запрос.УстановитьПараметр(Измерение.Ключ,Измерение.Значение);
		КонецЦикла;	
	КонецЕсли;
		
	Запрос.Текст = Запрос.Текст+"
	|ДЛЯ ИЗМЕНЕНИЯ";
		
	Выборка = Запрос.Выполнить().Выбрать();
		
	МоментВремениДокумента = Новый МоментВремени(Дата, Ссылка);
		
	Если Выборка.Следующий() Тогда
		// Граница переносится назад, если документ проводится задним числом
		Если МоментВремениДокумента.Сравнить(Выборка.МоментВремени) = -1 Тогда
			Последовательности[ИмяПоследовательности].УстановитьГраницу(МоментВремениДокумента, Измерения);
		КонецЕсли;
	КонецЕсли;

КонецПроцедуры


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ ДОКУМЕНТАМИ

// Процедура предназначена для преобразования номера документа.
//
// Параметры:
//  Документ - (ДокументСсылка), документ, чей номер надо получить для печати.
//
// Возвращаемое значение.
//  Строка - номер документа для печати
//
Функция ПолучитьНомерНаПечать(Документ) Экспорт

	Если Документ = Неопределено Тогда 
		Возврат 0;
	КонецЕсли;

	Номер   = СокрЛП(Документ.Номер);
	Префикс = "";

	Если ТипЗнч(Документ) = Тип("ВыборкаИзРезультатаЗапроса") Тогда

		Если НЕ ЗначениеНеЗаполнено(Документ.Организация) Тогда
			Префикс = СокрЛП(Документ.Организация.Префикс);
		КонецЕсли;

	ИначеЕсли ТипЗнч(Документ) = Тип("Структура") Тогда

		Если ТипЗнч(Документ.Организация) = Тип("СправочникСсылка.Организации") 
			ИЛИ ТипЗнч(Документ.Организация) = Тип("СправочникОбъект.Организации") Тогда
			Префикс = СокрЛП(Документ.Организация.Префикс);
		Иначе
			Префикс = "";
		КонецЕсли;

	Иначе

		МетаданныеДокумента = Документ.Метаданные();

		Если ЕстьРеквизитДокумента("Организация", МетаданныеДокумента) Тогда

			Если НЕ ЗначениеНеЗаполнено(Документ.Организация) Тогда
				Префикс = СокрЛП(Документ.Организация.Префикс);
			КонецЕсли;

		КонецЕсли;

	КонецЕсли;
	
	ПрефиксУзла = "";
	ДобавитьПрефиксУзла(ПрефиксУзла);
	
	СписокПрефиксов = Новый СписокЗначений();
	Если ПрефиксУзла <> "" Тогда
		СписокПрефиксов.Добавить(ПрефиксУзла);
	КонецЕсли;	
	Если Префикс <> "" Тогда
		//Изменил Трефиленков Дмитрий, РГ-Софт
		//СписокПрефиксов.Добавить(Префикс);
		//конец изменения
	КонецЕсли;
	
	Если СписокПрефиксов.Количество() = 0 Тогда
		СписокПрефиксов.Добавить("");
	КонецЕсли;

	Для Каждого ЭлементСписка ИЗ СписокПрефиксов Цикл
		
		ТекущийПрефикс = ЭлементСписка.Значение;
		
		// удаление префикса из номера документа
		Если СтрНайти(Номер, ТекущийПрефикс)=1 Тогда 
			Номер = Сред(Номер, СтрДлина(ТекущийПрефикс)+1);
		КонецЕсли;
		
		// так же, может остаться "минус" впереди
		Если Лев(Номер, 1) = "-" Тогда
			Номер = Сред(Номер, 2);
		КонецЕсли;
		
		// удаление ведущих нулей
		Пока Лев(Номер, 1)="0" Цикл
			Номер = Сред(Номер, 2);
		КонецЦикла;
	КонецЦикла;

	Возврат Номер;

КонецФункции // ПолучитьНомерНаПечать()

Функция ПолучитьНомерНаПечатьБезПрефикса(Документ) Экспорт

	Если Документ = Неопределено Тогда 
		Возврат 0;
	КонецЕсли;

	Номер   = СокрЛП(Документ.Номер);
	Префикс = "";

	Если ТипЗнч(Документ) = Тип("ВыборкаИзРезультатаЗапроса") Тогда

		Если НЕ ЗначениеНеЗаполнено(Документ.Организация) Тогда
			Префикс = СокрЛП(Документ.Организация.Префикс);
		КонецЕсли;

	ИначеЕсли ТипЗнч(Документ) = Тип("Структура") Тогда

		Префикс = СокрЛП(Документ.Организация.Префикс);

	Иначе

		МетаданныеДокумента = Документ.Метаданные();

		Если ЕстьРеквизитДокумента("Организация", МетаданныеДокумента) Тогда

			Если НЕ ЗначениеНеЗаполнено(Документ.Организация) Тогда
				Префикс = СокрЛП(Документ.Организация.Префикс);
			КонецЕсли;

		КонецЕсли;

	КонецЕсли;
	
	ПрефиксУзла = "";
	ДобавитьПрефиксУзла(ПрефиксУзла);
	
	СписокПрефиксов = Новый СписокЗначений();
	Если ПрефиксУзла <> "" Тогда
		СписокПрефиксов.Добавить(ПрефиксУзла);
	КонецЕсли;	
	Если Префикс <> "" Тогда
		СписокПрефиксов.Добавить(Префикс);
	КонецЕсли;
	
	Если СписокПрефиксов.Количество() = 0 Тогда
		СписокПрефиксов.Добавить("");
	КонецЕсли;

	Для Каждого ЭлементСписка ИЗ СписокПрефиксов Цикл
		
		ТекущийПрефикс = ЭлементСписка.Значение;
		
		// удаление префикса из номера документа
		Если СтрНайти(Номер, ТекущийПрефикс)=1 Тогда 
			Номер = Сред(Номер, СтрДлина(ТекущийПрефикс)+1);
		КонецЕсли;
		
		// так же, может остаться "минус" впереди
		Если Лев(Номер, 1) = "-" Тогда
			Номер = Сред(Номер, 2);
		КонецЕсли;
		
		// удаление ведущих нулей
		Пока Лев(Номер, 1)="0" Цикл
			Номер = Сред(Номер, 2);
		КонецЦикла;
	КонецЦикла;

	Возврат Номер;

КонецФункции // ПолучитьНомерНаПечать()

// Функция производит поиск документа заданного вида, имеющего значение реквизита "ДокументОснование", равное
// переданной ссылке.
//
// Параметры:
//  ДокументСсылка  - ссылка на документ, для которого надо найти подчиненный документ,
//  ВидСчетаФактуры - строка, вид документа, по умолчанию "СчетФактураВыданный"
//
// Возвращаемое значение:
//  Если нашли, то возвращаем ссылку, не нашли - Неопределено
//
Функция НайтиПодчиненныйДокумент(ДокументСсылка, ВидДокумента = "СчетФактураВыданный", РазрешитьВыборСФНаАванс = Истина, РазрешитьВыборТолькоСФНаАванс = Ложь, СтавкаНДСсАванса = Неопределено, ФлагТолькоПроведенные = Ложь) Экспорт

	НайденныйДокумент = Неопределено;

	Если ЗначениеЗаполнено(ДокументСсылка) Тогда

		Запрос = Новый Запрос;

		// Установим параметры запроса
		Запрос.УстановитьПараметр("ДокументСсылка", ДокументСсылка);

		Запрос.Текст = 
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ
		|	Ссылка
		|ИЗ
		|	Документ." + ВидДокумента + " 
		|ГДЕ
		|	ДокументОснование = &ДокументСсылка";
		Если ФлагТолькоПроведенные Тогда
			Запрос.Текст = Запрос.Текст + "
				|	И Проведен И НЕ ПометкаУдаления
				|";
		КонецЕсли;
		Если ВидДокумента = "СчетФактураВыданный" И Не РазрешитьВыборСФНаАванс Тогда
			Запрос.Текст = Запрос.Текст + " И Не НаАванс";
		ИначеЕсли ВидДокумента = "СчетФактураВыданный" И РазрешитьВыборСФНаАванс и РазрешитьВыборТолькоСФНаАванс Тогда
			Запрос.Текст = Запрос.Текст + " И НаАванс";
			Если не ЗначениеНеЗаполнено(СтавкаНДСсАванса) Тогда
				//-> RG-Soft VIvanov - когда процедура вызывается из книги покупок или книги продаж, то СтавкаНДСсАванса = Неопределено в любом случае. В остальных случаях СтавкаНДСсАванса = Неопределено по умолчанию
				//Запрос.Текст = Запрос.Текст + " И СтавкаНДС = &СтавкаНДСсАванса";
				//Запрос.УстановитьПараметр("СтавкаНДСсАванса", СтавкаНДСсАванса);
				//<-
			КонецЕсли; 
		КонецЕсли;
		
		ВыборкаИзЗапроса = Запрос.Выполнить().Выбрать();

		Если ВыборкаИзЗапроса.Следующий() Тогда
			НайденныйДокумент = ВыборкаИзЗапроса.Ссылка;
		КонецЕсли;

	КонецЕсли;

	Возврат НайденныйДокумент;

КонецФункции // НайтиПодчиненныйДокумент()

// Функция выполняет проверку необходимости проведения документа по разделам учета
Функция ПроводитьДокументПоРазделуУчета(Организация, РазделУчета, Дата) Экспорт
	
	Если ТипЗнч(РазделУчета) <> Тип("ПеречислениеСсылка.РазделыУчета") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ИмяПеречисления = "";
	Для Каждого ЗначениеПеречисления Из РазделУчета.Метаданные().ЗначенияПеречисления Цикл
		Если Перечисления.РазделыУчета[ЗначениеПеречисления.Имя] = РазделУчета Тогда
			ИмяПеречисления = ЗначениеПеречисления.Имя;
		КонецЕсли;
	КонецЦикла;
	
	Если ЗначениеНеЗаполнено(ИмяПеречисления) Тогда
		Возврат Ложь;
	КонецЕсли;

	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	               |	1 КАК ЗаписьРегистра
	               |ИЗ
	               |	(ВЫБРАТЬ ПЕРВЫЕ 1
	               |		КОНЕЦПЕРИОДА(ДатаАктуальностиУчета."+ИмяПеречисления+", ДЕНЬ) КАК ДатаАктуальности,
	               |		ВЫБОР
	               |			КОГДА ДатаАктуальностиУчета.Организация = &Организация
	               |				ТОГДА 1
	               |			ИНАЧЕ 2
	               |		КОНЕЦ КАК Порядок
	               |	ИЗ
	               |		РегистрСведений.ДатаАктуальностиУчета КАК ДатаАктуальностиУчета
	               |	ГДЕ
	               |		(ДатаАктуальностиУчета.Организация = &Организация
	               |				ИЛИ ДатаАктуальностиУчета.Организация = &ПустаяОрганизация)
	               |		И ДатаАктуальностиУчета."+ИмяПеречисления+" <> ДАТАВРЕМЯ(1, 1, 1)
	               |	
	               |	УПОРЯДОЧИТЬ ПО
	               |		Порядок) КАК МаксимальнаяДата
	               |ГДЕ
	               |	МаксимальнаяДата.ДатаАктуальности <= &ДатаДокумента";
	 	 
	Запрос.УстановитьПараметр("Организация", Организация);            
	Запрос.УстановитьПараметр("ПустаяОрганизация", Справочники.Организации.ПустаяСсылка());
	Запрос.УстановитьПараметр("ДатаДокумента", Дата);
	Возврат Запрос.Выполнить().Пустой() И ?(РазделУчета = Перечисления.РазделыУчета.НДС, УчетНДС.ПроводитьПоРазделуУчетаНДС(Дата), Истина);
	
КонецФункции


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ СО СТАВКАМИ НАЛОГОВ И ВЗНОСОВ

// Рассчитываем сумму документа со всеми налогами
//
// Параметры: 
//  ДокументОбъект    - объект документа, сумму которого надо рассчитать
//  ИмяТабличнойЧасти - строка, имя табличной части, сумму которой надо рассчитать.
//                      Если она не заполнена, считаем по всем табличным частям, в которых есть "Сумма"
//  НеУчитыватьТару   - булево, если Истина и ИмяТабличнойЧасти неопределено, то в расчете сумм тару не учитываем
//
// Возвращаемое значение:
//  Сумма документа со всеми налогами.
//
Функция ПолучитьСуммуДокументаСНДС(ДокументОбъект, ИмяТабличнойЧасти = Неопределено, НеУчитыватьТару = Истина) Экспорт

	МетаданныеДокумента = ДокументОбъект.Метаданные();

	СуммаДокумента = 0;
	Если ИмяТабличнойЧасти <> Неопределено Тогда
		СуммаДокумента = СуммаДокумента + ДокументОбъект[ИмяТабличнойЧасти].Итог("Сумма");
		Если ЕстьРеквизитДокумента("УчитыватьНДС", МетаданныеДокумента)
		   И ЕстьРеквизитДокумента("СуммаВключаетНДС", МетаданныеДокумента)
		   И ЕстьРеквизитТабЧастиДокумента("СуммаНДС", МетаданныеДокумента, ИмяТабличнойЧасти)
		   И ДокументОбъект.УчитыватьНДС
		   И Не ДокументОбъект.СуммаВключаетНДС Тогда
			СуммаДокумента = СуммаДокумента + ДокументОбъект[ИмяТабличнойЧасти].Итог("СуммаНДС");
		КонецЕсли; 
	Иначе
		Для каждого ТЧОбъекта Из ДокументОбъект.Метаданные().ТабличныеЧасти Цикл
			Если НеУчитыватьТару и ТЧОбъекта.Имя = "ВозвратнаяТара" Тогда
				Продолжить;
			КонецЕсли;
			Если ТЧОбъекта.Имя = "ВыданныеАвансы" Тогда
				Продолжить;
			КонецЕсли;
			Если ТЧОбъекта.Имя = "ДенежныеСредства" Тогда
				Продолжить;
			КонецЕсли;
			//Добавил Трефиленков Дмитрий, РГ-Софт
			Если ТЧОбъекта.Имя = "Предоплата" Тогда
				Продолжить;
			КонецЕсли;
			//конец добавления
			Если ЕстьРеквизитТабЧастиДокумента("Сумма", МетаданныеДокумента, ТЧОбъекта.Имя) Тогда
				СуммаДокумента = СуммаДокумента + ДокументОбъект[ТЧОбъекта.Имя].Итог("Сумма");
				Если ЕстьРеквизитДокумента("УчитыватьНДС", МетаданныеДокумента)
					И ЕстьРеквизитДокумента("СуммаВключаетНДС", МетаданныеДокумента)
					И ЕстьРеквизитТабЧастиДокумента("СуммаНДС", МетаданныеДокумента, ТЧОбъекта.Имя)
					И ДокументОбъект.УчитыватьНДС
					И Не ДокументОбъект.СуммаВключаетНДС Тогда
					СуммаДокумента = СуммаДокумента + ДокументОбъект[ТЧОбъекта.Имя].Итог("СуммаНДС");
				КонецЕсли; 
			КонецЕсли;
		КонецЦикла;
		Если ЕстьРеквизитДокумента("Сумма", МетаданныеДокумента) Тогда
			СуммаДокумента = СуммаДокумента + ДокументОбъект.Сумма;
			Если ЕстьРеквизитДокумента("УчитыватьНДС", МетаданныеДокумента)
				И ЕстьРеквизитДокумента("СуммаВключаетНДС", МетаданныеДокумента)
				И ЕстьРеквизитДокумента("СуммаНДС", МетаданныеДокумента)
				И ДокументОбъект.УчитыватьНДС
				И Не ДокументОбъект.СуммаВключаетНДС Тогда
				СуммаДокумента = СуммаДокумента + ДокументОбъект.СуммаНДС;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;

	Возврат СуммаДокумента;

КонецФункции // ПолучитьСуммуДокументаСНДС()

// Рассчитывает сумму НДС исходя из суммы и флагов налогообложения
//
// Параметры: 
//  Сумма            - число, сумма от которой надо рассчитывать налоги, 
//  УчитыватьНДС     - булево, признак учета НДС в сумме, 
//  СуммаВключаетНДС - булево, признак включения НДС в сумму ("внутри" или "сверху"),
//  СтавкаНДС        - число , процентная ставка НДС,
//
// Возвращаемое значение:
//  Число, полученная сумма НДС
//
Функция РассчитатьСуммуНДС(Сумма, УчитыватьНДС, СуммаВключаетНДС, СтавкаНДС) Экспорт

	Если (УчитыватьНДС) И (СуммаВключаетНДС) Тогда
		СуммаБезНДС = 100 * Сумма / (100 + СтавкаНДС);
		СуммаНДС = Сумма - СуммаБезНДС;
	Иначе
		СуммаБезНДС = Сумма;
	КонецЕсли;

	Если УчитыватьНДС Тогда 
		Если НЕ СуммаВключаетНДС Тогда
			СуммаНДС = СуммаБезНДС * СтавкаНДС / 100;
		КонецЕсли;
	Иначе
		СуммаНДС = 0;
	КонецЕсли;

	Возврат СуммаНДС;

КонецФункции // РассчитатьСуммуНДС()


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ СО СЧЕТАМИ И СУБКОНТО

// Функция возвращает остаток по счету бухгалтерского учета
// Возвращаемое значение - таблица значений в развороте по аналитике с учетом фильтра
Функция ПолучитьОстатокПоСчету(Организация, Период, Счет, Валюта = Неопределено, Субконто1 = Неопределено, Субконто2 = Неопределено, Субконто3 = Неопределено, ЗнакФильтрПоОстаткам = 0) Экспорт

	ВидПланаСчетов = Счет.Метаданные().Имя;

	Субконто    = Новый Массив(3);
	Субконто[0] = Субконто1;
	Субконто[1] = Субконто2;
	Субконто[2] = Субконто3;

	ФильтрПоСубконто = "";

	Для Каждого ТекВидСубконто Из Счет.ВидыСубконто Цикл
		Если НЕ ТекВидСубконто.ТолькоОбороты И НЕ Субконто[ТекВидСубконто.НомерСтроки-1] = Неопределено Тогда
			ФильтрПоСубконто = ФильтрПоСубконто + " И Субконто" + ТекВидСубконто.НомерСтроки + " = &Субконто" + ТекВидСубконто.НомерСтроки;
		КонецЕсли;
	КонецЦикла;
	
	ВыбиратьВалюту			= (не Счет.Метаданные().ПризнакиУчета.Найти("Валютный")= Неопределено);
	ВыбиратьВалютнуюСумму	= (не Метаданные.РегистрыБухгалтерии[ВидПланаСчетов].Ресурсы.Найти("ВалютнаяСумма")= Неопределено);
	ОтборПоОрганизации		= (не Метаданные.РегистрыБухгалтерии[ВидПланаСчетов].Измерения.Найти("Организация")= Неопределено);

	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Период"      , Период);
	Запрос.УстановитьПараметр("Счет"        , Счет);
	Запрос.УстановитьПараметр("Организация" , Организация);
	Запрос.УстановитьПараметр("Субконто1"   , Субконто[0]);
	Запрос.УстановитьПараметр("Субконто2"   , Субконто[1]);
	Запрос.УстановитьПараметр("Субконто3"   , Субконто[2]);
	Запрос.УстановитьПараметр("Валюта"      , Валюта);
	ВидыСубконто = Счет.ВидыСубконто.ВыгрузитьКолонку("ВидСубконто");
	Запрос.УстановитьПараметр("ВидыСубконто", ВидыСубконто);
	ЗнакОстатков = ?(ТипЗнч(ЗнакФильтрПоОстаткам) = Тип("Число"), ЗнакФильтрПоОстаткам, 0);
	Запрос.УстановитьПараметр("Множитель", ?(ЗнакОстатков < 0, -1, 1));
	
	КоличествоСубконто = ВидыСубконто.Количество();
	
	Запрос.Текст = "
	|ВЫБРАТЬ
	|	Счет,"
	+ ?(КоличествоСубконто > 0, " 
	|	Субконто1,", "НЕОПРЕДЕЛЕНО КАК Субконто1,")
	+ ?(КоличествоСубконто > 1, " 
	|	Субконто2,", "НЕОПРЕДЕЛЕНО КАК Субконто2,")
	+ ?(КоличествоСубконто > 2, " 
	|	Субконто3,", "НЕОПРЕДЕЛЕНО КАК Субконто3,")
	+ "
	|	ЕСТЬNULL(СуммаОстаток, 0) * &Множитель КАК СуммаОстаток"
	+ ?(ВыбиратьВалюту, ", 
	|	ЕСТЬNULL(Валюта, НЕОПРЕДЕЛЕНО) КАК Валюта", "")
	+ ?(ВыбиратьВалютнуюСумму, ", 
	|	ЕСТЬNULL(ВалютнаяСуммаОстаток, 0)  * &Множитель КАК ВалютнаяСуммаОстаток", ",
	|	ЕСТЬNULL(СуммаОстаток, 0)  * &Множитель КАК ВалютнаяСуммаОстаток")
	+ "
	|ИЗ
	|	РегистрБухгалтерии." + ВидПланаСчетов + ".Остатки(&Период, Счет = &Счет, &ВидыСубконто, #Фильтр#) КАК Остатки"
	+ ?(ЗнакОстатков <> 0, "
	|
	|ГДЕ
	|	"
	+ ?(ЗначениеНеЗаполнено(Валюта), 
	"ЕСТЬNULL(Остатки.СуммаОстаток, 0) * &Множитель > 0", "ЕСТЬNULL(Остатки.ВалютнаяСуммаОстаток, 0) * &Множитель > 0"), "")
	+ "
	|
	|ДЛЯ ИЗМЕНЕНИЯ
	|
	|УПОРЯДОЧИТЬ ПО
	|	Счет,
	|	Субконто1,
	|	Субконто2,
	|	Субконто3"
	+ ?(ВыбиратьВалюту,",
	|	Валюта","");
		
	Фильтр = "";
	Если ОтборПоОрганизации Тогда
		Фильтр = Фильтр + " И Организация = &Организация";
	КонецЕсли;
	ЕСли НЕ (ЗначениеНеЗаполнено(Валюта) ИЛИ НЕ Счет.Валютный) Тогда
		Фильтр = Фильтр + " И Валюта = &Валюта";
	КонецЕсли;
	Фильтр = Фильтр + ФильтрПоСубконто;
	Если Не ПустаяСтрока(Фильтр) Тогда // Убираем первое "И"
		Фильтр = Сред(Фильтр, 3);
	КонецЕсли;
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "#Фильтр#", Фильтр);	
	
	Остатки = Запрос.Выполнить().Выгрузить();

	Возврат Остатки;

КонецФункции // ПолучитьОстатокПоСчету()

// Процедура устанавливает субконто на счете. Если такое субконто на счете
// отсутствует, то ничего не делается.
//
// Параметры:
//		Счет - Счет, к которому относится субконто
//      Субконто - набор субконто
//		Номер или имя установливаемого субконто
//      Значение субконто - значение устанавливаемого субконто
//
Процедура УстановитьСубконто(Счет, Субконто, ИмяСубконто, ЗначениеСубконто, Сообщать = Ложь, Заголовок = "", ВидыСубконтоСчета = Неопределено) Экспорт

	Если Счет = Неопределено ИЛИ Счет.Пустая() Тогда
		Возврат;
	КонецЕсли;

	Если ВидыСубконтоСчета = Неопределено Тогда
	     ВидыСубконтоСчета = Счет.ВидыСубконто;
	КонецЕсли; 
	
	Если ТипЗнч(ИмяСубконто) = Тип("Число") Тогда

		Если ИмяСубконто > ВидыСубконтоСчета.Количество() Тогда
			Возврат;
		КонецЕсли;

		ВидСубк = ВидыСубконтоСчета[ИмяСубконто - 1].ВидСубконто;

	Иначе

		ВидСубк = ПланыВидовХарактеристик.ВидыСубконтоХозрасчетные[ИмяСубконто];

		Если ВидыСубконтоСчета.Найти(ВидСубк) = Неопределено Тогда
			Если Сообщать тогда
				СообщитьОбОшибке("Вид субконто <" + ВидСубк + "> для счета """+Счет.Код +" ("+Счет.Наименование+")"" не определен.",, Заголовок );
			КонецЕсли;
			Возврат;
		КонецЕсли;

	КонецЕсли;

	Если ВидСубк.ТипЗначения.СодержитТип(ТипЗнч(ЗначениеСубконто)) Тогда
		Субконто.Вставить(ВидСубк, ЗначениеСубконто);

	ИначеЕсли Сообщать тогда
		СообщитьОбОшибке("Неверное значение """ + ЗначениеСубконто + """ для вида субконто <" + ВидСубк + ">",, Заголовок);

	КонецЕсли;

КонецПроцедуры // УстановитьСубконто()

Функция ОпределитьВидСубконтоПоСчету(Счет, КэшВидовСубконтоПоСчетам) Экспорт
	Если Счет = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли; 
	
	Если КэшВидовСубконтоПоСчетам = Неопределено Тогда
		КэшВидовСубконтоПоСчетам = Новый Соответствие;
	КонецЕсли; 
	
	ВидыСубконтоПоСчету = КэшВидовСубконтоПоСчетам[Счет];
	Если ВидыСубконтоПоСчету = Неопределено Тогда
		ВидыСубконтоПоСчету = Счет.ВидыСубконто;
		КэшВидовСубконтоПоСчетам.Вставить(Счет, ВидыСубконтоПоСчету);
	КонецЕсли; 
	
	Возврат ВидыСубконтоПоСчету;
	
КонецФункции

// Процедура устанавливает субконто на счете по виду субконто. Если такое субконто на счете
// отсутствует, то ничего не делается.
//
// Параметры:
//		Счет - Счет, к которому относится субконто
//      Субконто - набор субконто
//		Номер или имя установливаемого субконто
//      Значение субконто - значение устанавливаемого субконто
//
Процедура УстановитьСубконтоПоВидуСубконто(Счет, Субконто, ВидСубконто, ЗначениеСубконто, Сообщать = Ложь, Заголовок = "") Экспорт

	Если Счет = Неопределено ИЛИ Счет.Пустая() Тогда
		Возврат;
	КонецЕсли;

	Если Счет.ВидыСубконто.Найти(ВидСубконто) = Неопределено Тогда
		Возврат;
	КонецЕсли;

	Если ВидСубконто.ТипЗначения.СодержитТип(ТипЗнч(ЗначениеСубконто)) Тогда
		Субконто.Вставить(ВидСубконто, ЗначениеСубконто);

	ИначеЕсли Сообщать тогда
		СообщитьОбОшибке("Неверное значение """ + ЗначениеСубконто + """ для вида субконто <" + ВидСубконто + ">",, Заголовок);

	КонецЕсли;

КонецПроцедуры // УстановитьСубконто()


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МАССИВАМИ

// функция ищет элемент в массиве. Если находит - возвращает его индекс, иначе -1
Функция ВернутьИндексВМассиве(МассивДанные, Элемент) Экспорт 
	
	Если МассивДанные = Неопределено Тогда
		Возврат -1;
	КонецЕсли;
	
	Для ИндексЭлемента = 0 По МассивДанные.ВГраница() Цикл
		
		Если  (МассивДанные[ИндексЭлемента] = Элемент) Тогда
			Возврат ИндексЭлемента;
		КонецЕсли;	
		
	КонецЦикла;
	
	// не нашли элемент
	Возврат -1;
	
КонецФункции


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ОШИБКАМИ

// Функция убирает из текста сообщения слущебную информацию
//
// Параметры
//  ТекстСообщения, Строка, исходный текст сообщения//
// Возвращаемое значение:
//   Строка
//
Функция СформироватьТекстСообщения(Знач ТекстСообщения) Экспорт

	НачалоСлужебногоСообщения    = СтрНайти(ТекстСообщения, "{");
	ОкончаниеСлужебногоСообщения = СтрНайти(ТекстСообщения, "}:");
	
	Если ОкончаниеСлужебногоСообщения > 0 
		И НачалоСлужебногоСообщения > 0 
		И НачалоСлужебногоСообщения < ОкончаниеСлужебногоСообщения Тогда
		
		ТекстСообщения = Лев(ТекстСообщения, (НачалоСлужебногоСообщения - 1)) +
		                 Сред(ТекстСообщения, (ОкончаниеСлужебногоСообщения + 2));
						 
	КонецЕсли;
	
	Возврат СокрЛП(ТекстСообщения);

КонецФункции // ()

// Выводит сообщение об ошибке и выставляет параметр Отказ в "Истина". 
// В случае работы на клиенте или на сервере выводит в окно сообщений,
// в случае внешнего соединения вызывает исключение.
//
// Параметры:
//  ТекстСообщения - строка, текст сообщения.
//  Отказ          - булево, признак отказа (необязательный).
//
Процедура СообщитьОбОшибке(Знач ТекстСообщения, Отказ = Неопределено, Заголовок = "", Знач Статус = Неопределено) Экспорт

	Если Статус = Неопределено Тогда
		
		// Изменил РГ-Софт - Иванов Антон - 2009-08-07
		// Если отказ не передается, статус сообщения должен быть более мягким
		Статус = ?(Отказ = Неопределено, СтатусСообщения.Внимание, СтатусСообщения.Важное);
				
	КонецЕсли;
	
	ТекстСообщения = СформироватьТекстСообщения(ТекстСообщения);
	Отказ = Истина;
	
	#Если ВнешнееСоединение или Сервер Тогда
		
		Если ЗначениеЗаполнено(Заголовок) Тогда
			ТекстСообщения = Заголовок + Символы.ПС + ТекстСообщения;
			Заголовок = "";
		КонецЕсли;
		
		// Закомментировал РГ-Софт - Иванов Антон
		// Непонятно зачем вызывать исключение
		//ВызватьИсключение (ТекстСообщения);
		
	#Иначе
		
		Если ЗначениеЗаполнено(Заголовок) Тогда
			Сообщить(Заголовок);
			Заголовок = "";
		КонецЕсли;
		
	#КонецЕсли
	
	Сообщить(ТекстСообщения, Статус); //изменила Наталья Петроченко 01.10.2012
				
КонецПроцедуры // СообщитьОбОшибке()

Функция ВопросПерезаполнитьКУДиР() Экспорт
	
	Ответ = Ложь;
	
	#Если Клиент Тогда
		ТекстВопроса = 
		"Отражение платежа в Книге учета доходов и расходов настроено вручную.
		|Перезаполнить показатели Книги учета доходов и расходов?";
		
		Ответ = (Вопрос(ТекстВопроса, РежимДиалогаВопрос.ДаНет, , КодВозвратаДиалога.Да) = КодВозвратаДиалога.Да);
	#КонецЕсли
	
	Возврат Ответ;
	
КонецФункции

// Формирует сообщение при ошибках проведения документов.
//
// Параметры: 
//  ТекстСообщения - Исходный текст, выводимого сообщения,
//  Отказ          - Флаг отказа в проведении докумета,
//  Заголовок      - Заголовок начала серии сообщений об ошибках проведения (не обязательный)
//
Процедура ОшибкаПриПроведении(ТекстСообщения, Отказ, Заголовок="", Статус = неопределено) Экспорт

	//СообщитьОбОшибке(ТекстСообщения, Отказ, Заголовок, Статус);
	РГСофтКлиентСервер.СообщитьОбОшибке(ТекстСообщения, Отказ);

КонецПроцедуры // ОшибкаПриПроведении()

// Формирует строку представления документа для сообщений при проведении.
//
// Параметры
//  Документ - ссылка на проводимый документ.
//
// Возвращаемое значение
//  Строка с представлением документа.
//
Функция ПредставлениеДокументаПриПроведении(Документ) Экспорт

	МетаданныеДокумента = Документ.Метаданные();

	ВидОперацииСтр = "";

	Если ЕстьРеквизитДокумента("ВидОперации", МетаданныеДокумента) Тогда
		ВидОперацииСтр = " (" + Документ.ВидОперации + ")";
	КонецЕсли;

	Возврат "Проведение документа: " + СокрЛП(Документ) + ВидОперацииСтр;

КонецФункции // ПредставлениеДокументаПриПроведении()

// Проверяет принадлежность документа к видам учета
//
// Параметры: 
//  СтруктураШапкиДокумента - структура, содержащая реквизиты шапки документа
//  Отказ                   - флаг отказа в проведении.
//  Заголовок               - строка, заголовок сообщения об ошибке проведения.
//
Процедура ПроверитьПринадлежностьКВидамУчета(СтруктураШапкиДокумента, Отказ, Заголовок) Экспорт

	Перем Бух, Нал;

	Бух     = Истина;
	Если не СтруктураШапкиДокумента.Свойство("ОтражатьВБухгалтерскомУчете",    Бух) тогда
		Бух = Истина;
	КонецЕсли;
	ЕстьНал = СтруктураШапкиДокумента.Свойство("ОтражатьВНалоговомУчете",    Нал);

	Если Бух <> Истина И Нал <> Истина Тогда
		ОшибкаПриПроведении("Документ должен принадлежать хотя бы одному из видов учета: ""Бухгалтерский"" и (или)  ""Налоговый"".", Отказ, Заголовок);
	КонецЕсли;

КонецПроцедуры

// Проверяет правильность заполнения шапки документа.
// Если какой-то из реквизтов шапки, влияющий на проведение не заполнен или
// заполнен не корректно, то выставляется флаг отказа в проведении.
// Проверяется также правильность заполнения реквизитов ссылочных полей документа.
// Проверка выполняется по объекту и по выборке из результата запроса по шапке.
//
// Параметры: 
//  ДокументОбъект             - объект проводимого документа, 
//  СтруктураОбязательныхПолей - структура, содержащая имена полей, которые собственно и надо проверить.
//  Отказ                      - флаг отказа в проведении.
//  Заголовок                  - строка, заголовок сообщения об ошибке проведения.
//
// Изменил РГ-Софт - Иванов Антон - 2009-08-28
// Для работы механизма регистрации ошибок
Процедура ПроверитьЗаполнениеШапкиДокумента(ДокументОбъект, СтруктураОбязательныхПолей, Отказ, Заголовок, РегистрироватьОшибки = Ложь, Сообщать = Истина) Экспорт

	ТипыПланыСчетов     = ПланыСчетов.ТипВсеСсылки();
	МетаданныеРеквизиты = ДокументОбъект.Метаданные().Реквизиты;

	Для каждого КлючЗначение Из СтруктураОбязательныхПолей Цикл

		Значение = ДокументОбъект[КлючЗначение.Ключ];
		ПредставлениеРеквизита = МетаданныеРеквизиты[КлючЗначение.Ключ].Представление();

		Если ЗначениеНеЗаполнено(Значение) Тогда 

			Если ЗначениеНеЗаполнено(КлючЗначение.Значение) Тогда //
				СтрокаСообщения = "Не заполнено значение реквизита """ + СокрЛП(ПредставлениеРеквизита) + """!";
			Иначе
				СтрокаСообщения = КлючЗначение.Значение;
			КонецЕсли;

			// Изменил РГ-Софт - Иванов Антон - 2009-08-28
			// Для работы механизма регистрации ошибок
			Если Сообщать Тогда
				ОшибкаПриПроведении(СтрокаСообщения, Отказ, Заголовок);
			КонецЕсли;
			
			Если РегистрироватьОшибки Тогда
				УчетОшибокЗаполнения.ЗарегистрироватьОшибкуВШапкеТипаНеЗаполнен(ДокументОбъект, КлючЗначение.Ключ, "", Отказ, Ложь);
			КонецЕсли;
			//<- Конец изменения

		ИначеЕсли ТипыПланыСчетов.СодержитТип(ТипЗнч(Значение)) тогда

			Если Значение.ЗапретитьИспользоватьВПроводках Тогда
				СтрокаСообщения = "Реквизит """ + СокрЛП(ПредставлениеРеквизита) + """ : счет " + СокрЛП(Значение)+" """ + Значение.Наименование + """ нельзя использовать в проводках.";
				ОшибкаПриПроведении(СтрокаСообщения, Отказ, Заголовок);

			КонецЕсли;

		КонецЕсли;

	КонецЦикла;

	Если СтруктураОбязательныхПолей.Свойство("Организация") и СтруктураОбязательныхПолей.Свойство("ДоговорКонтрагента") тогда

		// Если в документе есть организация и договор - провести проверку на соответствие
		//Организация в документе должна совпадать с организацией, указанной в договоре взаиморасчетов.
		Организация = ДокументОбъект.Организация;
		ДоговорКонтрагента = ДокументОбъект.ДоговорКонтрагента;
		Если ТипЗнч(ДоговорКонтрагента) = Тип("СправочникСсылка.ДоговорыКонтрагентов") тогда
			БухгалтерскийУчет.ПроверитьСоответствиеОрганизацииДоговоруВзаиморасчетов(Организация, ДоговорКонтрагента, ДоговорКонтрагента.Организация, Отказ, Заголовок);
		КонецЕсли;

	КонецЕсли;

КонецПроцедуры // ПроверитьЗаполнениеШапкиДокумента()

// Проверяет правильность заполнения строк табличной части документа.
// Если какой-то из реквизтов, влияющий на проведение не заполнен или
// заполнен не корректно, то выставляется флаг отказа в проведении.
//
// Параметры:
//  ДокументОбъект             - объект проводимого документа, 
//  ИмяТабличнойЧасти          - табличная часть документа,
//  СтруктураОбязательныхПолей - структура, содержащая имена полей, которые собственно и надо проверить.
//  Отказ                      - флаг отказа в проведении.
//  Заголовок                  - строка, заголовок сообщения об ошибке проведения.
//
// Изменил РГ-Софт - Иванов Антон - 2009-08-28
// Для работы механизма регистрации ошибок
Процедура ПроверитьЗаполнениеТабличнойЧасти(ДокументОбъект, ИмяТабличнойЧасти, СтруктураОбязательныхПолей, 
                                            Отказ, Заголовок, Статус = неопределено, РегистрироватьОшибки = Ложь, Сообщать = Истина) Экспорт

	ПредставлениеТабличнойЧасти = ДокументОбъект.Метаданные().ТабличныеЧасти[ИмяТабличнойЧасти].Представление();

	ТабличнаяЧасть      = ДокументОбъект[ИмяТабличнойЧасти];
	МетаданныеРеквизиты = ДокументОбъект.Метаданные().ТабличныеЧасти[ИмяТабличнойЧасти].Реквизиты;
	Если (НЕ МетаданныеРеквизиты.Найти("СчетДоходовБУ") = Неопределено)
		И (НЕ МетаданныеРеквизиты.Найти("СчетРасходовБУ") = Неопределено) Тогда
		ПроверятьВидДеятельности = Истина;
	Иначе
		ПроверятьВидДеятельности = Ложь;
	КонецЕсли;
	
	КэшСчетов = Новый Соответствие;
	
	// Цикл по строкам табличной части.
	Для каждого СтрокаТаблицы Из ТабличнаяЧасть Цикл

		СтрокаНачалаСообщенияОбОшибке = "В строке номер """+ СокрЛП(СтрокаТаблицы.НомерСтроки) +
		                               """ табличной части """ + ПредставлениеТабличнойЧасти + """: ";
			
		// Цикл по проверяемым полям
		Для каждого КлючЗначение Из СтруктураОбязательныхПолей Цикл

			Значение = СтрокаТаблицы[КлючЗначение.Ключ];
			Если ЗначениеНеЗаполнено(Значение) Тогда 

				Если ЗначениеНеЗаполнено(КлючЗначение.Значение) Тогда //
					ПредставлениеРеквизита = МетаданныеРеквизиты[КлючЗначение.Ключ].Представление();
					СтрокаСообщения = "Не заполнено значение реквизита """ + СокрЛП(ПредставлениеРеквизита) + """!";

				Иначе
					СтрокаСообщения = КлючЗначение.Значение;

				КонецЕсли;

				// Изменил РГ-Софт - Иванов Антон - 2009-08-28
				// Для работы механизма регистрации ошибок
				Если Сообщать Тогда
					ОшибкаПриПроведении(СтрокаНачалаСообщенияОбОшибке + СтрокаСообщения, Отказ, Заголовок, Статус);
				КонецЕсли;
				
				Если РегистрироватьОшибки Тогда
					УчетОшибокЗаполнения.ЗарегистрироватьОшибкуВТЧТипаНеЗаполнен(ДокументОбъект, ИмяТабличнойЧасти, СтрокаТаблицы.НомерСтроки, КлючЗначение.Ключ, "", Отказ, Ложь);
				КонецЕсли;
				//<- Конец изменения
				
			КонецЕсли;

		КонецЦикла;
		
		Если ПроверятьВидДеятельности Тогда
			Если ЗначениеНеЗаполнено(СтрокаТаблицы["СчетДоходовБУ"]) ИЛИ ЗначениеНеЗаполнено(СтрокаТаблицы["СчетРасходовБУ"]) Тогда
				//Один из счетов не заполнен, соответствие не проверяется
			Иначе			
				СчетДоходовБУВСтроке = СтрокаТаблицы["СчетДоходовБУ"];
				СчетДоходовБУЕНВД = КэшСчетов[СчетДоходовБУВСтроке];
				Если СчетДоходовБУЕНВД = Неопределено Тогда
					СчетДоходовБУЕНВД = ОтноситсяКДеятельностиЕНВД(СчетДоходовБУВСтроке);
					КэшСчетов[СчетДоходовБУВСтроке] = СчетДоходовБУЕНВД;					
				КонецЕсли;
				
				СчетРасходовБУВСтроке = СтрокаТаблицы["СчетРасходовБУ"];
				СчетРасходовБУЕНВД = КэшСчетов[СчетРасходовБУВСтроке];
				Если СчетРасходовБУЕНВД = Неопределено Тогда
					СчетРасходовБУЕНВД = ОтноситсяКДеятельностиЕНВД(СчетРасходовБУВСтроке);
					КэшСчетов[СчетРасходовБУВСтроке] = СчетРасходовБУЕНВД;
				КонецЕсли;
				
				Если НЕ СчетДоходовБУЕНВД = СчетРасходовБУЕНВД Тогда
					СтрокаСообщения = "Счета доходов и расходов для бухгалтерского учета относятся к разным видам деятельности!"; 
					ОшибкаПриПроведении(СтрокаНачалаСообщенияОбОшибке + СтрокаСообщения, Отказ, Заголовок);
				КонецЕсли;
			КонецЕсли;
		Конецесли;

	КонецЦикла;

КонецПроцедуры // ПроверитьЗаполнениеТабличнойЧасти()

//РГ-Софт Иванов Антон
//Проверка правильности заполнения даты
//Возврат: истина - если правильно или не заполенена, ложь - если неправильно
Функция ДатаЗаполненаПравильно(Дата, ВыводитьСообщение = Ложь, НазваниеПоля="Дата", Отказ = Неопределено, Заголовок = "") Экспорт
	
	Если ЗначениеНеЗаполнено(Дата) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если Дата < '19000101' Тогда
		
		Если ВыводитьСообщение Тогда
			
			ТекстОшибки = "Неправильно заполнено поле " + НазваниеПоля + ". Дата должна быть после 1900го года.";
			СообщитьОбОшибке(ТекстОшибки, Отказ, Заголовок);
			
		Иначе
			
			Отказ = Истина;
			
		КонецЕсли;
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

// Добавил РГ-Софт - Иванов Антон - 2009-07-02
Функция ЗначениеСуммаНДСЗаполнено(СтавкаНДС, СуммаНДС) Экспорт
	
	ПеречислениеСтавкиНДС = Перечисления.СтавкиНДС;
	Если ЗначениеЗаполнено(СтавкаНДС)
		И СтавкаНДС <> ПеречислениеСтавкиНДС.БезНДС
		И СтавкаНДС <> ПеречислениеСтавкиНДС.НДС0
		И НЕ ЗначениеЗаполнено(СуммаНДС) Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

Процедура СообщитьОбОшибкахВТаблицеОбъектовВерхнегоУровня(Таблица, Отказ) Экспорт
	
	Для каждого Стр из Таблица Цикл
		
		Если Стр.Статус Тогда
			ТекстСообщения = "Объект не может быть изменен: на него ссылается проведенный """ + Стр.ПредставлениеСсылки + """!";
			РГСофтКлиентСервер.СообщитьОбОшибке(ТекстСообщения, Отказ);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Процедура проверяет проведенность объектов, указанных в таблице значений. Если объект проведен,
// то пользователю сообщается об ошибке и Отказу присваивается значение Истина.
//
// Параметры:
//	ТаблицаЗначений	-	Таблица значений с колонками "Объект" (Ссылка), "ПредставлениеОбъекта" (Строка)
//						и "Статус" (Булево), содержащая ссылки на объекты, ссылающиеся на 
//						обрабатываемый объект.
//	Ссылка			-	Ссылка на обрабатываемый объект.
//	Отказ			-	Булево, признак отказа.
//	Заголовок		-	Строка, заголовок для сообщений об ошибках.
//
Процедура ПроверитьПроведенностьОбъектовВерхнегоУровня(ТипОбъектаПроверки, ИмяЗависимогоОбъекта, ИмяРеквизита, ЗначениеФильтра, Отказ) Экспорт
	
	Таблица = РГСофт.ПодготовитьТаблицуПроведенностиОбъектов(ТипОбъектаПроверки, ИмяЗависимогоОбъекта, ИмяРеквизита, ЗначениеФильтра);
	СообщитьОбОшибкахВТаблицеОбъектовВерхнегоУровня(Таблица, Отказ);	
			
КонецПроцедуры

// Функция проверяет проведенность объектов, указанных в таблице значений. Если объект проведен,
// то пользователю сообщается об этом и Отказу присваивается значение Истина.
//
// Параметры:
//	ТаблицаЗначений	-	Таблица значений с колонками "Объект" (Ссылка), "ПредставлениеОбъекта" (Строка)
//						и "Статус" (Булево), содержащая ссылки на объекты, ссылающиеся на 
//						обрабатываемый объект.
//	Ссылка			-	Ссылка на обрабатываемый объект.
//
Функция ПроверитьПроведенностьОбъектовВерхнегоУровняДляОткрытияФормы(ТипОбъектаПроверки, ИмяЗависимогоОбъекта, ИмяРеквизита, ЗначениеФильтра) Экспорт
	
	ТаблицаЗначений = РГСофт.ПодготовитьТаблицуПроведенностиОбъектов(ТипОбъектаПроверки, ИмяЗависимогоОбъекта, ИмяРеквизита, ЗначениеФильтра);
	
	Отказ = Ложь;
	ТекстСообщения = "";
	ТаблицаЗначений.Сортировать("Статус Убыв, Объект");
	
	Для каждого Стр из ТаблицаЗначений Цикл
		
		Если Стр.Статус Тогда
			Отказ = Истина;
			ТекстСообщения = ТекстСообщения + Символы.ПС + """" + Стр.ПредставлениеСсылки + """";
		Иначе
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	Если Отказ Тогда
		ТекстСообщения = "Объект закрыт для изменения: на него ссылаются проведенные" + ТекстСообщения;
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения);
	КонецЕсли;
	
	Возврат Отказ;
	
КонецФункции

// Процедура проверяет проведенность объектов, указанных в таблице значений. Если объект не проведен,
// делается попытка его проведения. В случае неудачного проведения пользователю сообщается об ошибке
// и Отказу присваивается значение Истина.
//
// Параметры:
//	ТаблицаЗначений	-	Таблица значений с колонками "Объект" (Ссылка), "ПредставлениеОбъекта" (Строка)
//						и "Статус" (Булево), содержащая ссылки на объекты, ссылающиеся на 
//						обрабатываемый объект.
//	Ссылка			-	Ссылка на обрабатываемый объект.
//	Отказ			-	Булево, признак отказа.
//	Заголовок		-	Строка, заголовок для сообщений об ошибках.
//
Процедура ПроверитьПроведенностьОбъектовНижнегоУровня(ТипОбъектаПроверки, ИмяЗависимогоОбъекта, ИмяРеквизита, ЗначениеФильтра, Отказ, Заголовок="") Экспорт
	
	ТаблицаЗначений = РГСофт.ПодготовитьТаблицуПроведенностиОбъектов(ТипОбъектаПроверки, ИмяЗависимогоОбъекта, ИмяРеквизита, ЗначениеФильтра);
		
	Для каждого Стр из ТаблицаЗначений Цикл
		
		Если Не Стр.Статус Тогда
			
			Объект = Стр.Объект.ПолучитьОбъект();
			
			Если Лев(Строка(ТипЗнч(Объект)), 8) = "Документ" Тогда
				
				Попытка
					Объект.Записать(РежимЗаписиДокумента.Проведение);
				Исключение
					ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
						"""" + Стр.ПредставлениеСсылки + """ должен быть проведен!",
						Объект, , , Отказ);
				КонецПопытки;
				
			Иначе
				
				Попытка
					Объект.Проверен = Истина;
					Объект.Записать();
				Исключение
					ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
						"""" + Стр.ПредставлениеСсылки + """ должен быть проверен!",
						Объект, , , Отказ);
				КонецПопытки;
				
			КонецЕсли;
			
			Если Отказ Тогда
				Возврат;
			КонецЕсли;
			
		КонецЕсли; // Если Не Стр.Статус
		
	КонецЦикла;
		
КонецПроцедуры // ПроверитьПроведенностьОбъектовНижнегоУровня()


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ТАБЛИЦАМИ

// Проверяет наличие требуемых данных в источнике и Формирует таблицу значений
//
// Параметры
//  Источник  – ТаблицаЗначений или ТабличнаяЧасть или КоллекцияСтрокДереваЗначений с исходными данными
//
//  Реквизиты – структура – Структура реквизитов. 
//							Ключ 		- Наименование колонки в источнике
//							Значение    - Наименование колонки в получаемой ТЗ
//							Если значение опущено - приравнивается ключу.
//	ПолучитьНомерСтрокиДокумента - булево
//	                        Используется только при выгрузке из табличной части документа.
//							В формируемой таблице создает новую колонку "НомерСтрокиДокумента"
//								и заполняет её реальными номерами строк
//
//  КоллекцияКолонокДереваЗначений - только для коллекции строк дерева значений.
// Возвращаемое значение:
//  Таблица значений или Неопределено (если не хватает реквизитов)
//
Функция СформироватьТаблицуЗначений(Источник,Реквизиты=Неопределено,ПолучитьНомерСтрокиДокумента = ложь,ФормироватьОтстутствующиеКолонки=Ложь,КоллекцияКолонокДереваЗначений=Неопределено) экспорт

	ЭтоТаблицаЗначений      = (ТипЗнч(Источник) = Тип("ТаблицаЗначений"));
	ЭтоСтрокиДереваЗначений = (ТипЗнч(Источник) = Тип("КоллекцияСтрокДереваЗначений"));

	Если ЭтоСтрокиДереваЗначений и КоллекцияКолонокДереваЗначений = Неопределено тогда
		Возврат Неопределено;
	Конецесли;

	Если ЗначениеНеЗаполнено(Реквизиты) тогда

		Если ЭтоТаблицаЗначений тогда

			НоваяТЗ = Источник.Скопировать();

			Возврат НоваяТЗ;

		ИначеЕсли ЭтоСтрокиДереваЗначений тогда

			Реквизиты = Новый Структура();

			Для каждого Колонка из КоллекцияКолонокДереваЗначений цикл
				Реквизиты.Вставить(Колонка.Имя);
			КонецЦикла;

		Иначе

			НоваяТЗ = Источник.Выгрузить();
			Возврат НоваяТЗ;

		КонецЕслИ;

	Конецесли;

	Если НЕ ЭтоТаблицаЗначений И НЕ ЭтоСтрокиДереваЗначений тогда
		РеквизитыТабличнойЧасти = Метаданные.НайтиПоТипу(ТипЗнч(Источник)).Реквизиты;
	Конецесли;

	НоваяТЗ = Новый ТаблицаЗначений();

	Если не ЭтоТаблицаЗначений и ПолучитьНомерСтрокиДокумента тогда
		НоваяТЗ.Колонки.Добавить("НомерСтрокиДокумента",ПолучитьОписаниеТиповЧисла(5,0));
	КонецЕсли;

	Пока НоваяТЗ.Количество()<Источник.Количество() Цикл

		Строка = НоваяТЗ.Добавить();

		Если не ЭтоТаблицаЗначений и ПолучитьНомерСтрокиДокумента тогда
			Строка.НомерСтрокиДокумента = НоваяТЗ.Количество();
		КонецЕсли;

	КонецЦикла;

	Для каждого ТекРеквизит из Реквизиты Цикл

		ИскомыйРеквизит = ТекРеквизит.Ключ;
		НовыйРеквизит   = ?(ТекРеквизит.Значение = Неопределено,ТекРеквизит.Ключ,ТекРеквизит.Значение);

		Если ЭтоТаблицаЗначений тогда
			ИсточникКолонка = Источник.Колонки.Найти(ИскомыйРеквизит);

		ИначеЕсли ЭтоСтрокиДереваЗначений тогда
			ИсточникКолонка = КоллекцияКолонокДереваЗначений.Найти(ИскомыйРеквизит);

		Иначе
			ИсточникКолонка = РеквизитыТабличнойЧасти.Найти(ИскомыйРеквизит);

		Конецесли;

		Если ИсточникКолонка= неопределено тогда

			//недостаточно реквизитов
			Если ФормироватьОтстутствующиеКолонки тогда
				НоваяТЗ.Колонки.Добавить(НовыйРеквизит);
			Иначе
				Возврат Неопределено;
			КонецЕсли;

		Иначе
			НоваяТЗ.Колонки.Добавить(НовыйРеквизит);
			НоваяТЗ.ЗагрузитьКолонку(Источник.ВыгрузитьКолонку(ИскомыйРеквизит),НовыйРеквизит);

		Конецесли;

	КонецЦикла;

	Возврат НоваяТЗ;

КонецФункции // СформироватьТаблицуЗначений()

Процедура ДополнитьКолонкиТаблицыЗначений(ТаблицаБазовая,ТаблицаДополнений) Экспорт

	Для каждого Колонка из ТаблицаДополнений.Колонки Цикл

		Если Не(ТаблицаБазовая.Колонки.Найти(Колонка.Имя) = Неопределено) тогда
			//Колонка уже есть
			Продолжить;
		КонецЕсли;

		ТаблицаБазовая.Колонки.Добавить(Колонка.Имя,Колонка.ТипЗначения,Колонка.Заголовок,Колонка.Ширина);

	КонецЦикла;

КонецПроцедуры

// Добавляет в таблицу значений строки из другой таблицы значений и 
// в них значения колонок с совпадающими наименованиями.
//
// Параметры:
//  ТаблицаИсточник - таблица значений, откуда берутся значения.
//  ТаблицаПриемник - таблица значений, куда добавляются строки.
//
Процедура ЗагрузитьВТаблицуЗначений(ТаблицаИсточник, ТаблицаПриемник) Экспорт

	Для каждого СтрокаТаблицыИсточника Из ТаблицаИсточник Цикл

		СтрокаТаблицыПриемника = ТаблицаПриемник.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаТаблицыПриемника, СтрокаТаблицыИсточника);

	КонецЦикла;

КонецПроцедуры // ЗагрузитьВТаблицуЗначений()

//Процедура для распределения записей из одной таблицы значений по базису (таблица значений или  набору записей)
//Источник 		: ТаблицаЗначений
//Базис 		: ТаблицаЗначений или НаборЗаписей
//Распределение : ключ - поля базиса, значение - поля источника
//Фильтр 		: ключ - поля базиса, значение - поля источника (если не укзан - по совпадающим колонкам)
//Игнорировать  : ключ - поля базиса, значение - поля источника
//Дополнить		: ключ - имя нового поля базиса, значение - значение для заполнения
Функция СформироватьКорректирующиеЗаписи(Источник,Базис,Распределение,Фильтр=неопределено,Игнорировать=Неопределено,Дополнить=Неопределено) Экспорт

	Если ТипЗнч(Базис) = Тип("ТаблицаЗначений") тогда
		Временный_Базис = Базис.Скопировать();

	Иначе
		Временный_Базис = Базис.Выгрузить();

	Конецесли;

	КолонкиИсточника = Новый Структура();

	Для Каждого Колонка Из источник.Колонки Цикл
		КолонкиИсточника.Вставить(Колонка.Имя);
	КонецЦикла;

	КолонкиБазиса = Новый Структура();

	Для Каждого Колонка Из Временный_Базис.Колонки Цикл

		Если Не(ЗначениеНеЗаполнено(Колонка.Имя)) тогда
			КолонкиБазиса.Вставить(Колонка.Имя);
		КонецЕсли;

	КонецЦикла;

	Если НЕ (ТипЗнч(Игнорировать) = Тип("Структура")) Тогда
		Игнорировать = Новый Структура();
	Иначе

		//Зачистим колонки источника и базиса на игнорируемые колонки
		Для Каждого Колонка Из Игнорировать Цикл

			Если КолонкиИсточника.Свойство(?(ЗначениеНеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение)) тогда
				КолонкиИсточника.Удалить(?(ЗначениеНеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение));
			Конецесли;

			Если КолонкиБазиса.Свойство(Колонка.Ключ) тогда
				КолонкиБазиса.Удалить(Колонка.Ключ);
			Конецесли;

		КонецЦикла;

	КонецЕсли;

	//Зачистим колонки источника на распределяемые колонки. Они учитываются отдельно.
	Для Каждого Колонка Из Распределение Цикл
		Если КолонкиИсточника.Свойство(?(ЗначениеНеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение)) тогда
			 КолонкиИсточника.Удалить(?(ЗначениеНеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение));
		Иначе
			 Если Источник.Колонки.Найти(?(ЗначениеНеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение))=Неопределено тогда
				 //Не хватает колонок к распределению
				 //Но одну и ту же колонку можно распределить дважды
				 Возврат ложь;
			 КонецЕсли;
		Конецесли;
		Если КолонкиБазиса.Свойство(Колонка.Ключ) тогда
			 КолонкиБазиса.Удалить(Колонка.Ключ);
		Иначе
			  //Не хватает колонок базиса распределения
			 Возврат ложь;
		Конецесли;
	КонецЦикла;
	
	Если (ТипЗнч(Дополнить) = Тип("Структура"))
	   И НЕ (Дополнить.Количество() = 0) Тогда
		//Проверим на отсутствие дополняемых колонок!
		Для Каждого Колонка Из Дополнить Цикл
			Если КолонкиБазиса.Свойство(Колонка.Ключ) тогда
				//Такая колонка уже есть, нельзя добавить новую
				Возврат Ложь;
			Конецесли;
		КонецЦикла;
 	КонецЕсли;
	
	//Если фильтр не задан - по всем совпадающим колонкам
	Если Фильтр=Неопределено тогда
		Фильтр = Новый Структура();
		Для каждого Колонка из КолонкиБазиса цикл
			Если КолонкиИсточника.Свойство(Колонка.Ключ)  и не(Игнорировать.Свойство(Колонка.Ключ)) тогда
				Фильтр.Вставить(Колонка.Ключ);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Если НЕ (ТипЗнч(Фильтр) = Тип("Структура") И НЕ (Фильтр.Количество() = 0)) Тогда
		//Должно быть хоть одно объединяющее поле!
		Возврат Ложь;
	КонецЕсли;
	
	Для Каждого Колонка Из Фильтр Цикл
		Если не КолонкиБазиса.Свойство(Колонка.Ключ) тогда
			  //Не хватает колонок базиса распределения
			 Возврат ложь;
		Конецесли;
	КонецЦикла;
	
	//Подготовить сворачивание для источника
	СтрокаСверткиИсточник = ВыгрузитьСтруктуруВСтроку(Фильтр,Истина,КолонкиИсточника);
	Если СтрокаСверткиИсточник = ложь Тогда
		//попытка фильтровать по полю, отсутствующему в источнике!
		Возврат ложь;
	КонецЕсли;
	КолонкиКРаспределениюИсточник = ВыгрузитьСтруктуруВСтроку(Распределение,Истина);
	Если КолонкиКРаспределениюИсточник = ложь Тогда
		//попытка распределить поле, отсутствующее в источнике!
		Возврат ложь;
	КонецЕсли;
	
	//Подготовить сворачивание для базиса
	СтрокаСверткиБазис = ВыгрузитьСтруктуруВСтроку(КолонкиБазиса,Ложь);
	Если СтрокаСверткиБазис = ложь Тогда
		//попытка фильтровать по полю, отсутствующему в базисе!
		Возврат ложь;
	КонецЕсли;
	КолонкиКРаспределениюБазис = ВыгрузитьСтруктуруВСтроку(Распределение,Ложь);
	Если КолонкиКРаспределениюБазис = ложь Тогда
		//попытка распределить поле, отсутствующее в базисе!
		Возврат ложь;
	КонецЕсли;
	
	Временный_Источник = Источник.Скопировать();
	
	Временный_Базис.Свернуть(СтрокаСверткиБазис,КолонкиКРаспределениюБазис);
	Временный_Источник.Свернуть(СтрокаСверткиИсточник,КолонкиКРаспределениюИсточник);
	
	НоваяТаблица = новый ТаблицаЗначений();
	Для каждого Колонка из Временный_Базис.Колонки Цикл
		НоваяТаблица.Колонки.Добавить(Колонка.Имя,Колонка.ТипЗначения,,10);
	КонецЦикла;
	
	ТаблицаБазисовРаспределения = Новый ТаблицаЗначений();
	Для каждого Колонка из Распределение Цикл
		ТаблицаБазисовРаспределения.Колонки.Добавить(Колонка.Ключ);
	КонецЦикла;
	
	Для каждого СтрокаИсточника из Временный_Источник цикл
		Отбор = новый структура();
		Для каждого Колонка из Фильтр цикл
			Отбор.Вставить(Колонка.Ключ,СтрокаИсточника[?(ЗначениеНеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение)]);
		КонецЦикла;
		СтрокиБазиса = Временный_Базис.НайтиСтроки(Отбор);
		ТаблицаБазисовРаспределения.Очистить();
		Для каждого Строка из СтрокиБазиса Цикл
			СтрокаТБР = ТаблицаБазисовРаспределения.Добавить();
			Для каждого Колонка из ТаблицаБазисовРаспределения.Колонки цикл
				СтрокаТБР[Колонка.Имя] = Строка[Колонка.Имя];
			КонецЦикла;
		КонецЦикла;
		Для каждого Колонка из Распределение цикл
			РаспределяемаяСумма =  СтрокаИсточника[?(ЗначениеНеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение)];
			МассивДляРаспределения = ТаблицаБазисовРаспределения.ВыгрузитьКолонку(Колонка.Ключ);
			МассивРезультата = УправлениеПроизводством.РаспределитьПропорционально(РаспределяемаяСумма, МассивДляРаспределения);
			Если МассивРезультата = неопределено тогда
				ТаблицаБазисовРаспределения.ЗаполнитьЗначения(0,Колонка.Ключ);
			Иначе	
				ТаблицаБазисовРаспределения.ЗагрузитьКолонку(МассивРезультата,Колонка.Ключ);
			КонецЕсли;
			
		КонецЦикла;
		
		СтрокаРезультата = 0;
		Для каждого Строка из СтрокиБазиса Цикл
			СтрокаНовая = НоваяТаблица.Добавить();
			СрокаРекультатаРаспределения = ТаблицаБазисовРаспределения[СтрокаРезультата];
			СтрокаРезультата = СтрокаРезультата +1;
			Для каждого Колонка из Временный_Базис.Колонки цикл
				Если Распределение.Свойство(Колонка.Имя) тогда
					СтрокаНовая[Колонка.Имя] = СрокаРекультатаРаспределения[Колонка.Имя];
				Иначе
					СтрокаНовая[Колонка.Имя] = Строка[Колонка.Имя];
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;
	КонецЦикла;
	
	Если (ТипЗнч(Дополнить) = Тип("Структура"))
	   И НЕ (Дополнить.Количество() = 0) Тогда
		Для Каждого Колонка Из Дополнить Цикл
			НоваяТаблица.Колонки.Добавить(Колонка.Ключ,,,10);
			НоваяТаблица.ЗаполнитьЗначения(Колонка.Значение,Колонка.Ключ);
		КонецЦикла;
	КонецЕсли;

	СтрокиС0Распределением = Новый Массив();

	Для каждого Строка из НоваяТаблица цикл

		СуммаРаспределений0 = Истина;

		Для каждого Колонка из распределение цикл
			Если не ЗначениеНеЗаполнено(Строка[Колонка.Ключ]) тогда
				СуммаРаспределений0=Ложь;
				Прервать;
			КонецЕсли;
		КонецЦикла;

		Если СуммаРаспределений0 тогда
			СтрокиС0Распределением.Добавить(Строка);
		Конецесли;

	КонецЦикла;

	Для каждого ПустаяСтрока из СтрокиС0Распределением Цикл 
		НоваяТаблица.Удалить(ПустаяСтрока);
	КонецЦикла;

	//Если не ЗначениеНеЗаполнено(ИсключитьПослеРаспределения) тогда
	//	КолонкиРезультата = Новый Структура();
	//	Для каждого Колонка из НоваяТаблица.Колонки Цикл
	//		Если ИсключитьПослеРаспределения.Свойство(Колонка.Имя) = Истина  или Распределение.Свойство(Колонка.Имя) = Истина Тогда
	//			Продолжить;
	//		Иначе
	//			КолонкиРезультата.Вставить(Колонка.Имя);
	//		КонецЕсли;
	//	КонецЦикла;
	//	КолонкиКСворачиванию = ВыгрузитьСтруктуруВСтроку(КолонкиРезультата,Ложь);
	//	НоваяТаблица.Свернуть(КолонкиКСворачиванию,КолонкиКРаспределениюБазис);
	//КонецЕсли;
	
	Возврат НоваяТаблица;

КонецФункции


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С СТРУКТУРАМИ

Функция ВыгрузитьСтруктуруВСтроку(Структура,ПоЗначениям = Ложь,СтруктураПроверки = Неопределено) Экспорт

	НеПроверять = (СтруктураПроверки = Неопределено);
	НоваяСтрока = "";

	Для каждого Колонка из Структура Цикл

		Если НеПроверять тогда
			НоваяСтрока = НоваяСтрока + ?(ЗначениеНеЗаполнено(Колонка.Значение)или не ПоЗначениям,Колонка.Ключ,Колонка.Значение)+",";

		ИначеЕсли СтруктураПроверки.Свойство(?(ЗначениеНеЗаполнено(Колонка.Значение) или не ПоЗначениям,Колонка.Ключ,Колонка.Значение)) тогда
			НоваяСтрока = НоваяСтрока + ?(ЗначениеНеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение)+",";

		Иначе
			//Нет в проверке!
			Возврат Ложь;

		КонецЕсли;

	КонецЦикла;

	Если не ЗначениеНеЗаполнено(НоваяСтрока) Тогда
		НоваяСтрока = Лев(НоваяСтрока,СтрДлина(НоваяСтрока)-1);
	КонецЕсли;

	Возврат НоваяСтрока;

КонецФункции // ВыгрузитьСтруктуруВСтроку

// Предназначена для получения пустого значения заданного типа:
//	примитивного, или ссылочного. Используется
//
// Параметры:
//	ЗаданныйТип   - тип, пустое значение которого нужно получить
//
Функция ПустоеЗначениеТипа(ЗаданныйТип) Экспорт

	Если ЗаданныйТип = Тип("Число") Тогда
		Возврат 0;

	ИначеЕсли ЗаданныйТип = Тип("Строка") Тогда
		Возврат "";

	ИначеЕсли ЗаданныйТип = Тип("Дата") Тогда
		Возврат '00010101000000';

	ИначеЕсли ЗаданныйТип = Тип("Булево") Тогда
		Возврат Ложь;

	Иначе
		Возврат Новый (ЗаданныйТип);

	КонецЕсли;

КонецФункции // ПустоеЗначениеТипа();


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ СО СЧЕТАМИ И СУБКОНТО

// Эта функция возвращает информацию о счете из переданного соответсвия
// Если в соответствии не найдена информация о счете - она подготавливается и 
// помещается в соответсвие
// Применяется для работы с формами в которых активно требуется получать 
// информащцию о счетах, например, при выводе строки табличного поля
//
// Параметры:      
//	СведенияОСчетах - соответсвие у котрого в качестве ключа - ПланСчетовСсылка, а 
//  				  в качестве значения - структура из 4-х элементов
//					  КоличествоСубконто - число
//                    ТипСубконто1 - описание типа
//                    ТипСубконто2 - описание типа
//                    ТипСубконто3 - описание типа
//					  ВидСубконто1Представление - представление вида субконто
//					  ВидСубконто2Представление - представление вида субконто
//					  ВидСубконто3Представление - представление вида субконто
//
//	Счет - ПланСчетовСсылка
//
// Возвращаемое значение:
//  Описанная выше структура
//
Функция ПолучитьСведенияОСчете(СведенияОСчетах, Счет) Экспорт

	СведенияОСчете = СведенияОСчетах[Счет];

	Если СведенияОСчете = Неопределено Тогда

		СведенияОСчете = Новый Структура("КоличествоСубконто, ВидСубконто1, ВидСубконто2, ВидСубконто3, ТипСубконто1, ТипСубконто2, ТипСубконто3, ВидСубконто1Представление, ВидСубконто2Представление, ВидСубконто3Представление");

		СведенияОСчете.КоличествоСубконто = Счет.ВидыСубконто.Количество();

		Если СведенияОСчете.КоличествоСубконто > 0 Тогда

			ВидСубконто = Счет.ВидыСубконто[0].ВидСубконто;

			СведенияОСчете.ВидСубконто1              = ВидСубконто;
			СведенияОСчете.ТипСубконто1              = ВидСубконто.ТипЗначения;
			СведенияОСчете.ВидСубконто1Представление = ВидСубконто.Наименование;

		КонецЕсли;

		Если СведенияОСчете.КоличествоСубконто > 1 Тогда

			ВидСубконто = Счет.ВидыСубконто[1].ВидСубконто;

			СведенияОСчете.ВидСубконто2              = ВидСубконто;
			СведенияОСчете.ТипСубконто2              = ВидСубконто.ТипЗначения;
			СведенияОСчете.ВидСубконто2Представление = ВидСубконто.Наименование;

		КонецЕсли;

		Если СведенияОСчете.КоличествоСубконто > 2 Тогда

			ВидСубконто = Счет.ВидыСубконто[2].ВидСубконто;

			СведенияОСчете.ВидСубконто3              = ВидСубконто;
			СведенияОСчете.ТипСубконто3              = ВидСубконто.ТипЗначения;
			СведенияОСчете.ВидСубконто3Представление = ВидСубконто.Наименование;

		КонецЕсли;

		СведенияОСчетах[Счет] = СведенияОСчете;

	КонецЕсли;

	Возврат СведенияОСчете;

КонецФункции  // ПолучитьСведенияОСчете

// Выполняет в табличном поле приведение значений субконто к типу, соответствующему счету
// сведения о счете передаются через параметр СведенияОСчете
// используется для табличных полей, содержащих колонки типа Счет и соответствующие ему субконто
//
// Параметры:
//	ТабличноеПоле 	- табличное поле 
//  ДтКт 			- строка "Дт", "Кт" или "" - часть имени колонки табличного поля
// 					для колонок табличного поля поддерживаются имена 
//					типа СубконтоДт1, СубконтоКт1, Субконто1...
//  СведенияОСчете 	- структура
//					  КоличествоСубконто - число
//                    ТипСубконто1 - описание типа
//                    ТипСубконто2 - описание типа
//                    ТипСубконто3 - описание типа
//					  ВидСубконто1Представление - представление вида субконто - в данной процедуре не используется
//					  ВидСубконто2Представление - представление вида субконто - в данной процедуре не используется
//					  ВидСубконто3Представление - представление вида субконто - в данной процедуре не используется
//
Процедура ПривестиЗначениеСубконто(ТабличноеПоле, ДтКт, СведенияОСчете) Экспорт

	Для СчетчикСубконто = 1 По 3 Цикл

		Если СведенияОСчете.КоличествоСубконто >= СчетчикСубконто Тогда
			ТабличноеПоле.ТекущиеДанные["Субконто"+ДтКт+СчетчикСубконто] = СведенияОСчете["ТипСубконто"+СчетчикСубконто].ПривестиЗначение(ТабличноеПоле.ТекущиеДанные["Субконто"+ДтКт+СчетчикСубконто]);

		Иначе
			ТабличноеПоле.ТекущиеДанные["Субконто"+ДтКт+СчетчикСубконто] = Неопределено;

		КонецЕсли;

	КонецЦикла;

КонецПроцедуры   // ПривестиЗначениеСубконто

// Назначает видимость ячейкам строки табличного поля, соответствующим субконто
// в зависимлсти от счета. Сведения о счете передаются через параметр СведенияОСчете
// Используется для табличных полей, содержащих колонки типа Счет и соответствующие ему субконто
// при выводе строки
//
// Параметры:
//	ОформлениеСтроки 	- оформление строки
//  ДтКт 				- строка "Дт", "Кт" или "" - часть имени колонки табличного поля
// 						для колонок табличного поля поддерживаются имена 
//						типа СубконтоДт1, СубконтоКт1, Субконто1...
//  СведенияОСчете 		- структура
//					  	КоличествоСубконто - число
//                    	ТипСубконто1 - описание типа
//                    	ТипСубконто2 - описание типа
//                    	ТипСубконто3 - описание типа
//					    ВидСубконто1Представление - представление вида субконто - в данной процедуре не используется
//					    ВидСубконто2Представление - представление вида субконто - в данной процедуре не используется
//					    ВидСубконто3Представление - представление вида субконто - в данной процедуре не используется
//
Процедура НазначитьВидимостьСубконто(ОформлениеСтроки, ДтКт, СведенияОСчете) Экспорт

	Для СчетчикСубконто = 1 По 3 Цикл
		ОформлениеСтроки.Ячейки["Субконто"+ДтКт+СчетчикСубконто].Видимость = СведенияОСчете.КоличествоСубконто >= СчетчикСубконто;
		ОформлениеСтроки.Ячейки["Субконто"+ДтКт+СчетчикСубконто].ТолькоПросмотр = НЕ СведенияОСчете.КоличествоСубконто >= СчетчикСубконто;
	КонецЦикла;

КонецПроцедуры

// Функция применяется при необходимости получить сведения об учетной политике организации.
//
// Параметры:
// Учет - строка. Определяет регистр сведений, из которого будут получены данные:
//   "НалоговыйУчет" или "БухгалтерскийУчет".
//
// Возвращаемое значение - таблица значений. Таблица, каждая строка которой 
//  соответствует записи регистра. 
//
Функция СоздатьКЭШУчетнойПолитики(Учет) Экспорт
	
	Запрос = Новый Запрос();
	
	Запрос.Текст = 
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	*
	|ИЗ
	|	РегистрСведений.УчетнаяПолитика" + Учет +" КАК УчетнаяПолитика" + Учет;
	
	//Обновление рег. Отчетности на бух. Корп 3.0.37.25	 переименована переменная
	перемУчетнаяПолитика = Запрос.Выполнить().Выгрузить();
	перемУчетнаяПолитика.Сортировать("Период");
	Возврат перемУчетнаяПолитика;
	//<=

	
КонецФункции

// Функция возвращает структуру с параметрами учетной политики на заданную дату.
//
Функция ПолучитьПараметрыУчетнойПолитики(КонДата, Отказ, Организация, Учет = "Бух") Экспорт
	
	СтруктураУчПолитика = Новый Структура;
			
	Если ЗначениеНеЗаполнено(Организация) Тогда
		
		Отказ = Истина;
		Возврат СтруктураУчПолитика;	
		
	КонецЕсли;
	
	Если ЗначениеНеЗаполнено(КонДата) Тогда
		
		Отказ = Истина;
		Возврат СтруктураУчПолитика;	
		
	КонецЕсли;

	Если Учет = "Нал" Тогда
		перемУчетнаяПолитика = ПараметрыСеанса.УчетнаяПолитикаПоНалоговомуУчету.Получить();
		
	Иначе
		перемУчетнаяПолитика = ПараметрыСеанса.УчетнаяПолитикаПоБухгалтерскомуУчету.Получить();
	КонецЕсли; 
		
	УчетнаяПолитикаОрганизации = перемУчетнаяПолитика.НайтиСтроки(Новый Структура("Организация", Организация));
		
	Если УчетнаяПолитикаОрганизации.Количество() = 0 Тогда
		Отказ = Истина;
		СообщитьОбОшибке("Не указаны параметры учетной политики " + ?(Учет = "Нал", "налогового", "бухгалтерского") +" учета ("+СокрЛП(Организация)+") на " + Формат(КонДата, "ДЛФ=DD"), Отказ);
		Возврат СтруктураУчПолитика;	
	Иначе
			
		Номер = 0;
		ФлагОтказа = Истина;
		Для НомерСтроки = 1 По УчетнаяПолитикаОрганизации.Количество() Цикл
				
			Строка = УчетнаяПолитикаОрганизации.Получить(НомерСтроки - 1);
			Если Строка.Период <= КонДата Тогда
				Номер = НомерСтроки;
				ФлагОтказа = Ложь;
					
			Иначе 
				Прервать;
			КонецЕсли;
		КонецЦикла;
			
		Если Номер <> 0 Тогда
			Строка = УчетнаяПолитикаОрганизации.Получить(Номер - 1);
			Для Каждого Колонка Из перемУчетнаяПолитика.Колонки Цикл
				СтруктураУчПолитика.Вставить(Колонка.Имя, Строка[Колонка.Имя]);
			КонецЦикла;
			
			Если КонДата>= '20060101' и СтруктураУчПолитика.Свойство("МоментОпределенияНалоговойБазыНДС") и СтруктураУчПолитика.МоментОпределенияНалоговойБазыНДС = Перечисления.МоментыОпределенияНалоговойБазыНДС.ПоОплате Тогда			
				СтруктураУчПолитика.Вставить("МоментОпределенияНалоговойБазыНДС", Перечисления.МоментыОпределенияНалоговойБазыНДС.ПоОтгрузке);
			КонецЕсли;
			Если КонДата < '20060101' И СтруктураУчПолитика.Свойство("НачислятьНДСПоОтгрузке") И СтруктураУчПолитика.НачислятьНДСПоОтгрузке Тогда
				СтруктураУчПолитика.Свойство("НачислятьНДСПоОтгрузке", Ложь);
			КонецЕсли;
		КонецЕсли;
			
	КонецЕсли;
		
	Если  ФлагОтказа = Истина Тогда
			СообщитьОбОшибке("Не указаны параметры учетной политики " + ?(Учет = "Нал", "налогового", "бухгалтерского") +" учета ("+СокрЛП(Организация)+") на " + Формат(КонДата, "ДЛФ=DD"), Отказ);
			Возврат СтруктураУчПолитика;	
		КонецЕсли; 
		
	Возврат СтруктураУчПолитика;
		
КонецФункции // ПолучитьПараметрыУчетнойПолитики()


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ИНТЕРНЕТ-ПОДДЕРЖКИ ПОЛЬЗОВАТЕЛЕЙ

// Получаем из полного номера версии конфигурации номер релиза без номера сборки.
//
// Параметры
//  НомерВерсии  – Строка – полный номер версии
//
// Возвращаемое значение:
//  Строка – номер релиза без номера сборки
//
Функция ПолучитьНомерРелиза(НомерВерсии) Экспорт

	КоличествоТочек = 0;
	ДлинаОписанияНомераРелиза = 0;

	Для х = 1 По СтрДлина(НомерВерсии) Цикл

		Если Сред(НомерВерсии, х, 1) = "." Тогда
			КоличествоТочек = КоличествоТочек + 1;
		КонецЕсли;

		Если КоличествоТочек = 3 Тогда
			ДлинаОписанияНомераРелиза = х - 1;
			Прервать;
		КонецЕсли;

	КонецЦикла;

	Возврат Лев(НомерВерсии, ДлинаОписанияНомераРелиза);

КонецФункции // ПолучитьНомерРелиза()


///////////////////////////////////////////////////////////////////////////////
// ФУНКЦИИ РАБОТЫ С ЕНВД

Функция ОтноситсяКДеятельностиЕНВД(Счет) Экспорт

	//Если РегистрыСведений.СчетаДоходовИРасходовЕНВД.Выбрать(Новый Структура("Счет", Счет)).Следующий() тогда
	//	Возврат Истина;
	//Иначе
		Возврат Ложь;
	//КонецЕсли;

КонецФункции // ОтноситсяКДеятельностиЕНВД()

Функция МассивСчетовВыручкиЕНВД() Экспорт

	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Счет90_01", Планысчетов.Хозрасчетный.Выручка);

	Запрос.Текст = "
	|ВЫБРАТЬ
	|	Хозрасчетный.Ссылка КАК Счет
	|ИЗ
	|	РегистрСведений.СчетаДоходовИРасходовЕНВД КАК СчетаДоходовИРасходовЕНВД
	|		ЛЕВОЕ СОЕДИНЕНИЕ ПланСчетов.Хозрасчетный КАК Хозрасчетный
	|		ПО СчетаДоходовИРасходовЕНВД.Счет = Хозрасчетный.Ссылка
	|
	|ГДЕ
	|	Хозрасчетный.Ссылка В ИЕРАРХИИ(&Счет90_01)";
	ТаблицаСчетов = Запрос.Выполнить().Выгрузить();

	Возврат ТаблицаСчетов.ВыгрузитьКолонку("Счет");

КонецФункции

Функция МассивСчетовРасходовЕНВД() Экспорт

	Запрос = Новый Запрос;
	
	Массив = Новый Массив;
	Массив.Добавить(ПланыСчетов.Хозрасчетный.Продажи_РасходыНаПродажу);
	Массив.Добавить(ПланыСчетов.Хозрасчетный.Продажи_УправленческиеРасходы);
	Запрос.УстановитьПараметр("Счет90_02", Массив);

	Запрос.Текст = "
	|ВЫБРАТЬ
	|	Хозрасчетный.Ссылка КАК Счет
	|ИЗ
	|	РегистрСведений.СчетаДоходовИРасходовЕНВД КАК СчетаДоходовИРасходовЕНВД
	|		ЛЕВОЕ СОЕДИНЕНИЕ ПланСчетов.Хозрасчетный КАК Хозрасчетный
	|		ПО СчетаДоходовИРасходовЕНВД.Счет = Хозрасчетный.Ссылка
	|
	|ГДЕ
	|	Хозрасчетный.Ссылка В ИЕРАРХИИ(&Счет90_02)";
	ТаблицаСчетов = Запрос.Выполнить().Выгрузить();

	Возврат ТаблицаСчетов.ВыгрузитьКолонку("Счет");

КонецФункции

//Определяет применяется ли упрощенная система налогообложения
//
Функция ПрименениеУСН(Организация, Знач Дата) Экспорт

	Возврат Ложь;

КонецФункции

Функция ПрименениеПБУ18(Организация, Знач Дата) Экспорт

	Если ЗначениеНеЗаполнено(Организация) Тогда
		Возврат Ложь;
	КонецЕсли;
	Если ЗначениеНеЗаполнено(Дата) Тогда
		Дата = ТекущаяДата();
	КонецЕсли;

	перемУчетнаяПолитика = ПолучитьПараметрыУчетнойПолитики(Дата, Ложь, Организация, "Бух");
	Если перемУчетнаяПолитика.Количество() = 0 Тогда
		Возврат Ложь;
	Иначе
		Возврат перемУчетнаяПолитика.ПоддержкаПБУ18;
	КонецЕсли;

КонецФункции


///////////////////////////////////////////////////////////////////////////////
// ФУНКЦИИ РАБОТЫ ПБУ 18/02

// Определяет, установлена ли поддержка ПБУ 18/02.
//
// Параметры:
//  Организация  - Справочник.Ссылка - Организация, по которой
//                 определяется поддержка ПБУ 18/02
//  Дата         - Дата - Дата, на которую получаются сведения
//
// Возвращаемое значение:
//  Булево.
//
Функция ПоддержкаПБУ18(Организация, Знач Дата) Экспорт

	Если ЗначениеНеЗаполнено(Организация) Тогда
		Возврат Ложь;
	КонецЕсли;
	Если ЗначениеНеЗаполнено(Дата) Тогда
		Дата = ТекущаяДата();
	КонецЕсли;

	перемУчетнаяПолитика = ПолучитьПараметрыУчетнойПолитики(Дата, Ложь, Организация);
	Если перемУчетнаяПолитика.Количество() = 0 Тогда
		Возврат Истина;
	Иначе
		Возврат перемУчетнаяПолитика.ПоддержкаПБУ18;
	КонецЕсли;

КонецФункции // ПоддержкаПБУ18()


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ЗАПОЛНЕНИЯ РЕКВИЗИТОВ В ФОРМЕ

// Процедура предназначена для заполнения общих реквизитов документов,
// вызывается в обработчиках событий "ПриОткрытии" в модулех форм всех документов.
//
// Параметры:
//  ДокументОбъект                 - объект редактируемого документа,
//  ТекПользователь                - ссылка на справочник, определяет текущего пользователя  
//  ВалютаРегламентированногоУчета - валюта регламентированного учета
//  ТипОперации                    - необязаетельный, строка вида операции ("Покупка" или "Продажа"),
//                                   если не передан, то реквизиты, зависящие от вида операции, не заполняются
//
Процедура ЗаполнитьШапкуДокумента(ДокументОбъект, ТекПользователь, ВалютаРегламентированногоУчета = Неопределено, ТипОперации = "") Экспорт

	Перем ТипЦен;

	МетаданныеДокумента = ДокументОбъект.Метаданные();

	Если ЕстьРеквизитДокумента("ОтражатьВНалоговомУчете", МетаданныеДокумента) Тогда

		ДокументОбъект.ОтражатьВНалоговомУчете = НЕ УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(ТекПользователь, "НеОтражатьДокументыВНалоговомУчете");

	КонецЕсли;
	
	Если ЕстьРеквизитДокумента("ОтражатьВБухгалтерскомУчете", МетаданныеДокумента) Тогда

		//По умолчанию все документы требуют отражения в бухгалтерском учете
		ДокументОбъект.ОтражатьВБухгалтерскомУчете = Истина;

	КонецЕсли;


	Если ЕстьРеквизитДокумента("Организация", МетаданныеДокумента) 
	  И (ЗначениеНеЗаполнено(ДокументОбъект.Организация)) Тогда
		ДокументОбъект.Организация = УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(ТекПользователь, "ОсновнаяОрганизация");
	КонецЕсли;

	Если ЕстьРеквизитДокумента("ПодразделениеОрганизации", МетаданныеДокумента)
	   И (ЗначениеНеЗаполнено(ДокументОбъект.ПодразделениеОрганизации)) Тогда
		ДокументОбъект.ПодразделениеОрганизации = УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(ТекПользователь, "ОсновноеПодразделениеОрганизации");
	КонецЕсли;
	
	//Изменил Трефиленков Дмитрий, РГ-Софт
	Если ЕстьРеквизитДокумента("НалоговаяРегистрация", МетаданныеДокумента)
	   И (ЗначениеНеЗаполнено(ДокументОбъект.НалоговаяРегистрация)) Тогда
		ДокументОбъект.НалоговаяРегистрация = УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(ТекПользователь, "ОсновноеПодразделениеОрганизации");
	КонецЕсли;
	
	Если ЕстьРеквизитДокумента("ГлавныйБухгалтер", МетаданныеДокумента)
	   И (ЗначениеНеЗаполнено(ДокументОбъект.ГлавныйБухгалтер)) Тогда
		ДокументОбъект.ГлавныйБухгалтер = УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(ТекПользователь, "ГлавныйБухгалтерПоУмолчанию");
	КонецЕсли;

	Если ЕстьРеквизитДокумента("Руководитель", МетаданныеДокумента)
	   И (ЗначениеНеЗаполнено(ДокументОбъект.Руководитель)) Тогда
		ДокументОбъект.Руководитель = УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(ТекПользователь, "ДиректорПоУмолчанию");
	КонецЕсли;

	//Если ЕстьРеквизитДокумента("CashCode", МетаданныеДокумента)
	//   И (ЗначениеНеЗаполнено(ДокументОбъект.CashCode)) Тогда
	//	ДокументОбъект.CashCode = УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(ТекПользователь, "CashCodeПользователя");
	//КонецЕсли;
	
	Если ЕстьРеквизитДокумента("ИнвойсинговыйЦентр", МетаданныеДокумента)
	   И (ЗначениеНеЗаполнено(ДокументОбъект.ИнвойсинговыйЦентр)) Тогда
		ДокументОбъект.ИнвойсинговыйЦентр = УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(ТекПользователь, "ОсновнойИнвойсинговыйЦентр");
	КонецЕсли;
	//конец изменения
	
	Если ЕстьРеквизитДокумента("СтруктурнаяЕдиница", МетаданныеДокумента)
	   И ЗначениеНеЗаполнено(ДокументОбъект.СтруктурнаяЕдиница) 
	   И ЕстьРеквизитДокумента("Организация", МетаданныеДокумента) Тогда
		ДокументОбъект.СтруктурнаяЕдиница = ДокументОбъект.Организация.ОсновнойБанковскийСчет;
	КонецЕсли;

	Если ЕстьРеквизитДокумента("Ответственный", МетаданныеДокумента) Тогда
	  ДокументОбъект.Ответственный = УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(ТекПользователь, "ОсновнойОтветственный");
	КонецЕсли;

	Если ЕстьРеквизитДокумента("ВидОперации", МетаданныеДокумента)
	   И (ЗначениеНеЗаполнено(ДокументОбъект.ВидОперации)) Тогда
		ДокументОбъект.ВидОперации = Перечисления[ДокументОбъект.ВидОперации.Метаданные().Имя][0];
	КонецЕсли;

	Если ЕстьРеквизитДокумента("Склад", МетаданныеДокумента)
	   И (ЗначениеНеЗаполнено(ДокументОбъект.Склад)) Тогда
		ДокументОбъект.Склад = УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(ТекПользователь, "ОсновнойСклад");
	КонецЕсли;

	Если ЕстьРеквизитДокумента("СкладОрдер", МетаданныеДокумента)
	   И ЗначениеНеЗаполнено(ДокументОбъект.СкладОрдер) Тогда
		ДокументОбъект.СкладОрдер = УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(ТекПользователь, "ОсновнойСклад");
	КонецЕсли;

	Если ЕстьРеквизитДокумента("СтавкаНДС", МетаданныеДокумента)
	   И (ЗначениеНеЗаполнено(ДокументОбъект.СтавкаНДС)) Тогда
		ДокументОбъект.СтавкаНДС = УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(ТекПользователь, "ОсновнаяСтавкаНДС");
	КонецЕсли;

	Если ЕстьРеквизитДокумента("БанковскийСчет", МетаданныеДокумента)
	   И ЗначениеНеЗаполнено(ДокументОбъект.БанковскийСчет) Тогда
	    //Изменил Трефиленков Дмитрий, РГ-Софт
		ДокументОбъект.БанковскийСчет = УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(ТекПользователь, "ОсновнойБанковскийСчет");
	    //конец изменения
		Если ЕстьРеквизитДокумента("ВалютаДокумента", МетаданныеДокумента) Тогда
			ДокументОбъект.ВалютаДокумента = ДокументОбъект.Организация.ОсновнойБанковскийСчет.ВалютаДенежныхСредств;
		КонецЕсли;
	КонецЕсли;

	Если ЕстьРеквизитДокумента("СчетОрганизации", МетаданныеДокумента)
	   И ЗначениеНеЗаполнено(ДокументОбъект.СчетОрганизации) Тогда
		ДокументОбъект.СчетОрганизации = ДокументОбъект.Организация.ОсновнойБанковскийСчет;
		ДокументОбъект.ВалютаДокумента = ДокументОбъект.Организация.ОсновнойБанковскийСчет.ВалютаДенежныхСредств;
	КонецЕсли;

	Если ЕстьРеквизитДокумента("ВалютаДокумента", МетаданныеДокумента)
	   И (ЗначениеНеЗаполнено(ДокументОбъект.ВалютаДокумента)) Тогда
		ДокументОбъект.ВалютаДокумента = ВалютаРегламентированногоУчета;
	КонецЕсли;

	Если ЕстьРеквизитДокумента("КурсДокумента", МетаданныеДокумента)
	   И (ЗначениеНеЗаполнено(ДокументОбъект.КурсДокумента)) Тогда
	    СтруктураКурсаДокумента      = ПолучитьКурсВалюты(ДокументОбъект.ВалютаДокумента, ДокументОбъект.Дата);
		ДокументОбъект.КурсДокумента = СтруктураКурсаДокумента.Курс;

		Если ЕстьРеквизитДокумента("КратностьДокумента", МетаданныеДокумента) Тогда
			ДокументОбъект.КратностьДокумента = СтруктураКурсаДокумента.Кратность;
		КонецЕсли;
	КонецЕсли;

	// Если тип цен оказался не заполненным, то берем его из установок пользователя
	Если ЕстьРеквизитДокумента("ТипЦен", МетаданныеДокумента)
	   И (ЗначениеНеЗаполнено(ДокументОбъект.ТипЦен)) Тогда
		Если ТипОперации = "Продажа" Тогда
			ДокументОбъект.ТипЦен = УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(ТекПользователь, "ОсновнойТипЦенПродажи");
			//добавила Петроченко Н.Н. 14.01.13 //Вопрос SLI-0003151
			Если Не ЗначениеЗаполнено(ДокументОбъект.ТипЦен) Тогда 
				ДокументОбъект.ТипЦен = Справочники.ТипыЦенНоменклатуры.НайтиПоНаименованию("Основной");
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;

	Если (ЕстьРеквизитДокумента("ТипЦен", МетаданныеДокумента))
	   И (Не ЗначениеНеЗаполнено(ДокументОбъект.ТипЦен)) Тогда

		// Если ТипЦен - элемент справочника ТипыЦенНоменклатуры и цены выбранного типа расчетные, 
		// то флаги включения налогов надо брать из базовой цены
		ТипЦен = ДокументОбъект.ТипЦен;

		// Флаги учета налогов заполняем, только если флаг УчитыватьНДС не заполнен.
		Если ЕстьРеквизитДокумента("УчитыватьНДС", МетаданныеДокумента) 
		   И (Не ДокументОбъект.УчитыватьНДС) Тогда

			ДокументОбъект.УчитыватьНДС     = Истина;
			ДокументОбъект.СуммаВключаетНДС = ТипЦен.ЦенаВключаетНДС;

		КонецЕсли; 
		
	Иначе

		// Заполним значениями по умолчанию (нет, либо не заполнен ТипЦен).
		// Флаги учета налогов заполняем, только если флаг УчитыватьНДС не заполнен.
		Если ЕстьРеквизитДокумента("УчитыватьНДС", МетаданныеДокумента) 
		   И (Не ДокументОбъект.УчитыватьНДС) Тогда

			ДокументОбъект.УчитыватьНДС     = Истина;
			ДокументОбъект.СуммаВключаетНДС = Истина;
		КонецЕсли; 
	КонецЕсли;

	Если ЕстьРеквизитДокумента("ЗанимаемыхСтавок", МетаданныеДокумента)
	   И (ЗначениеНеЗаполнено(ДокументОбъект.ЗанимаемыхСтавок)) Тогда
		ДокументОбъект.ЗанимаемыхСтавок = 1;
	КонецЕсли;

	Если ЕстьРеквизитДокумента("ДатаС", МетаданныеДокумента)
	   И (ЗначениеНеЗаполнено(ДокументОбъект.ДатаС)) Тогда
		ДокументОбъект.ДатаС = ДокументОбъект.Дата;
	КонецЕсли;

	# Если Клиент Тогда

	Если ЕстьРеквизитДокумента("ПериодРегистрации", МетаданныеДокумента)
	   И (ЗначениеНеЗаполнено(ДокументОбъект.ПериодРегистрации)) Тогда
		ДокументОбъект.ПериодРегистрации = НачалоМесяца(РабочаяДата);
	КонецЕсли;

	#КонецЕсли

КонецПроцедуры // ЗаполнитьШапкуДокумента()

// Процедура предназначена для заполнения общих реквизитов документов по документу основанию,
//	вызывается в обработчиках событий "ОбработкаЗаполнения" в модулях документов.
//
// Параметры:
//  ДокументОбъект  - объект редактируемого документа,
//  ДокументОснование - объект документа основания
//
Процедура ЗаполнитьШапкуДокументаПоОснованию(ДокументОбъект, ДокументОснование) Экспорт

	МетаданныеДокумента          = ДокументОбъект.Метаданные();
	МетаданныеДокументаОснования = ДокументОснование.Метаданные();

	// Организация.
	Если ЕстьРеквизитДокумента("Организация", МетаданныеДокумента)
	   И ЕстьРеквизитДокумента("Организация", МетаданныеДокументаОснования) Тогда
		ДокументОбъект.Организация = ДокументОснование.Организация;
	КонецЕсли;

	//Изменил Трефиленков Дмитрий, РГ-Софт
	
	// Подразделение.
	Если ЕстьРеквизитДокумента("ПодразделениеОрганизации", МетаданныеДокумента)
	   И ЕстьРеквизитДокумента("ПодразделениеОрганизации", МетаданныеДокументаОснования) Тогда
		ДокументОбъект.ПодразделениеОрганизации = ДокументОснование.ПодразделениеОрганизации;
	КонецЕсли;
	
	//конец изменения
	
	// Склад.
	Если ЕстьРеквизитДокумента("Склад", МетаданныеДокумента)
	   И ЕстьРеквизитДокумента("Склад", МетаданныеДокументаОснования) Тогда
		ДокументОбъект.Склад = ДокументОснование.Склад;
	КонецЕсли;

	// Контрагент.
	Если ЕстьРеквизитДокумента("Контрагент", МетаданныеДокумента)
	   И ЕстьРеквизитДокумента("Контрагент", МетаданныеДокументаОснования) Тогда
		ДокументОбъект.Контрагент = ДокументОснование.Контрагент;
	КонецЕсли;

	// ДоговорКонтрагента.
	Если ЕстьРеквизитДокумента("ДоговорКонтрагента", МетаданныеДокумента)
	   И ЕстьРеквизитДокумента("ДоговорКонтрагента", МетаданныеДокументаОснования) 
	   И (НЕ ЕстьРеквизитДокумента("Организация", МетаданныеДокумента) 
	      ИЛИ ДокументОбъект.Организация = ДокументОснование.ДоговорКонтрагента.Организация) Тогда

		ДокументОбъект.ДоговорКонтрагента = ДокументОснование.ДоговорКонтрагента;

		// КурсВзаиморасчетов.
		Если ЕстьРеквизитДокумента("КурсВзаиморасчетов", МетаданныеДокумента) Тогда
			Если ДокументОснование.ДоговорКонтрагента.Курс > 0 Тогда
			    ДокументОбъект.КурсВзаиморасчетов = ДокументОснование.ДоговорКонтрагента.Курс;
				Если ЕстьРеквизитДокумента("КратностьВзаиморасчетов", МетаданныеДокумента) Тогда
					ДокументОбъект.КратностьВзаиморасчетов = 1;
				КонецЕсли;
			Иначе
				СтруктураКурсаВзаиморасчетов = ПолучитьКурсВалюты(ДокументОбъект.ДоговорКонтрагента.ВалютаВзаиморасчетов, ТекущаяДата());
				ДокументОбъект.КурсВзаиморасчетов = СтруктураКурсаВзаиморасчетов.Курс;

				// КратностьВзаиморасчетов.
				Если ЕстьРеквизитДокумента("КратностьВзаиморасчетов", МетаданныеДокумента) Тогда
					ДокументОбъект.КратностьВзаиморасчетов = СтруктураКурсаВзаиморасчетов.Кратность;
				КонецЕсли;
			КонецЕсли; 
		КонецЕсли;
	КонецЕсли;

	// Банковский счет 
	Если ЕстьРеквизитДокумента("БанковскийСчет", МетаданныеДокумента) Тогда

		// Если в документе-основании есть структурная единица, то берем ее оттуда
		Если ЕстьРеквизитДокумента("СтруктурнаяЕдиница", МетаданныеДокументаОснования) Тогда
			Если Не ЗначениеНеЗаполнено(ДокументОснование.СтруктурнаяЕдиница) 
			   И ТипЗнч(ДокументОснование.СтруктурнаяЕдиница) = Тип("СправочникСсылка.БанковскиеСчета") Тогда
				ДокументОбъект.БанковскийСчет = ДокументОснование.СтруктурнаяЕдиница;
			КонецЕсли;
		ИначеЕсли ЕстьРеквизитДокумента("БанковскийСчет", МетаданныеДокументаОснования) Тогда
			Если Не ЗначениеНеЗаполнено(ДокументОснование.БанковскийСчет) Тогда
				ДокументОбъект.БанковскийСчет = ДокументОснование.БанковскийСчет;
			КонецЕсли;

		КонецЕсли;

	КонецЕсли;

	// ВалютаДокумента.
	Если ЕстьРеквизитДокумента("ВалютаДокумента", МетаданныеДокумента)
	   И ЕстьРеквизитДокумента("ВалютаДокумента", МетаданныеДокументаОснования) Тогда

		// Если есть касса или банковский счет, то валюта должна браться только оттуда
		Если ЕстьРеквизитДокумента("Касса", МетаданныеДокумента) Тогда
			Если Не ЗначениеНеЗаполнено(ДокументОбъект.Касса) Тогда
				ДокументОбъект.ВалютаДокумента = ДокументОбъект.Касса.ВалютаДенежныхСредств;
			КонецЕсли;
		ИначеЕсли ЕстьРеквизитДокумента("БанковскийСчет", МетаданныеДокумента) Тогда
			Если Не ЗначениеНеЗаполнено(ДокументОбъект.БанковскийСчет) Тогда
				ДокументОбъект.ВалютаДокумента = ДокументОбъект.БанковскийСчет.ВалютаДенежныхСредств;
		    КонецЕсли;
		Иначе
			ДокументОбъект.ВалютаДокумента = ДокументОснование.ВалютаДокумента;
		КонецЕсли;

		// КурсДокумента.
		Если ЕстьРеквизитДокумента("КурсДокумента", МетаданныеДокумента) Тогда
			СтруктураКурсаДокумента = ПолучитьКурсВалюты(ДокументОбъект.ВалютаДокумента, ТекущаяДата());
			ДокументОбъект.КурсДокумента = СтруктураКурсаДокумента.Курс;

			// КратностьДокумента.
			Если ЕстьРеквизитДокумента("КратностьДокумента", МетаданныеДокумента) Тогда
				ДокументОбъект.КратностьДокумента = СтруктураКурсаДокумента.Кратность;
			КонецЕсли;
		КонецЕсли;

	КонецЕсли;

	// ТипЦен.
	Если ЕстьРеквизитДокумента("ТипЦен", МетаданныеДокумента)
	   И ЕстьРеквизитДокумента("ТипЦен", МетаданныеДокументаОснования) Тогда
		ДокументОбъект.ТипЦен = ДокументОснование.ТипЦен;
	КонецЕсли;

	// УчитыватьНДС.
	Если ЕстьРеквизитДокумента("УчитыватьНДС", МетаданныеДокумента)
	   И ЕстьРеквизитДокумента("УчитыватьНДС", МетаданныеДокументаОснования) Тогда
		ДокументОбъект.УчитыватьНДС = ДокументОснование.УчитыватьНДС;
	КонецЕсли;

	// СуммаВключаетНДС.
	Если ЕстьРеквизитДокумента("СуммаВключаетНДС", МетаданныеДокумента)
	   И ЕстьРеквизитДокумента("СуммаВключаетНДС", МетаданныеДокументаОснования) Тогда
		ДокументОбъект.СуммаВключаетНДС = ДокументОснование.СуммаВключаетНДС;
	КонецЕсли;

	Если ЕстьРеквизитДокумента("ОтражатьВНалоговомУчете", МетаданныеДокумента) Тогда
		Если ЕстьРеквизитДокумента("ОтражатьВНалоговомУчете", МетаданныеДокументаОснования) Тогда
			ДокументОбъект.ОтражатьВНалоговомУчете = ДокументОснование.ОтражатьВНалоговомУчете;
		Иначе
			ДокументОбъект.ОтражатьВНалоговомУчете = Истина;
		КонецЕсли;
	КонецЕсли;

КонецПроцедуры // ЗаполнитьШапкуДокументаПоОснованию()

// Функция формирует фамилию и инициалы
//
// Параметры
//  Фамилия  - фамилия физ. лица.
//  Имя      - имя физ. лица.
//  Отчество - отчество физ. лица.
//
// Возвращаемое значение 
//  Фамилия, имя, отчество одной строкой.
//
Функция ПолучитьФамилиюИмяОтчество(Фамилия = " ", Имя = " ", Отчество = " ") Экспорт

	Возврат ?(НЕ ПустаяСтрока(Фамилия), Фамилия + ?(НЕ ПустаяСтрока(Имя)," " + Лев(Имя,1) + "." + 
			?(НЕ ПустаяСтрока(Отчество) , 
			Лев(Отчество,1)+".", ""), ""), "");

КонецФункции // ПолучитьФамилиюИмяОтчество()

// Функция собирает паспортные данные физ. лица на указанную дату
//
// Параметры: 
//  ФизЛицо.    - физ. лицо, для которго необходимо получить паспортные данные
//  ДатаПериода - дата получения сведений
//
// Возвращаемое значение:
//  Структура с паспортными данными.
//
Функция ПаспортныеДанные(ФизЛицо, ДатаПериода) Экспорт

	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ПарФизЛицо",     ФизЛицо);
	Запрос.УстановитьПараметр("ПарДатаПериода", ДатаПериода);

	Запрос.Текст =
	"ВЫБРАТЬ
	|	ДокументВид        КАК Вид,
	|	ДокументСерия      КАК Серия,
	|	ДокументНомер      КАК Номер,
	|	ДокументДатаВыдачи КАК ДатаВыдачи,
	|	ДокументКемВыдан   КАК Выдан
	|ИЗ
	|	РегистрСведений.ПаспортныеДанныеФизЛиц.СрезПоследних(&ПарДатаПериода, ФизЛицо = &ПарФизЛицо)
	|ГДЕ
	|	ФизЛицо = &ПарФизЛицо";
	Шапка = Запрос.Выполнить().Выбрать();
	Шапка.Следующий();

	Результат = Новый Структура("Вид, Серия, Номер, ДатаВыдачи, Выдан");

	Результат.Вид        = Шапка.Вид;
	Результат.Серия      = Шапка.Серия;
	Результат.Номер      = Шапка.Номер;
	Результат.ДатаВыдачи = Шапка.ДатаВыдачи;
	Результат.Выдан      = Шапка.Выдан;

	Возврат Результат;

КонецФункции // ПаспортныеДанные()

// Функция собирает сведения о 
//
// Параметры:
//  Организация - организация, для которой нужно определить руководящих лиц.
//
Функция ОтветственныеЛица(Организация, ДатаСреза) Экспорт

	Результат = Новый Структура("Руководитель, РуководительДолжность, РуководительФИО, РуководительПредставление, 
								|ГлавныйБухгалтер, ГлавныйБухгалтерФИО, ГлавныйБухгалтерПредставление, 
								|Кассир, КассирФИО, КассирПредставление,  
								|ОтветственныйЗаРегистры, ОтветственныйЗаРегистрыФИО, ОтветственныйЗаРегистрыПредставление");

	Если ТипЗнч(Организация) = Тип("СправочникСсылка.Контрагенты") ТОгда
		Запрос = Новый Запрос("ВЫБРАТЬ
		                      |	КонтактныеЛица.Представление,
		                      |	КонтактныеЛица.Должность,
		                      |	КонтактныеЛица.Роль
		                      |ИЗ
		                      |	Справочник.КонтактныеЛица КАК КонтактныеЛица
		                      |ГДЕ
		                      |	КонтактныеЛица.ОбъектВладелец = &ОбъектВладелец
		                      |	И КонтактныеЛица.Роль В(&Роли)");	
		Запрос.УстановитьПараметр("ОбъектВладелец", Организация);
		Роли = Новый Массив();
		Руководитель = Справочники.РолиКонтактныхЛиц.НайтиПоНаименованию("Руководитель");
		ГлавныйБухгалтер = Справочники.РолиКонтактныхЛиц.НайтиПоНаименованию("Главный бухгалтер");
		Роли.Добавить(Руководитель);
		Роли.Добавить(ГлавныйБухгалтер);
		Запрос.УстановитьПараметр("Роли", Роли);
		Выборка = Запрос.Выполнить().Выбрать();
		Пока Выборка.Следующий() Цикл
			Если Выборка.Роль = Руководитель  Тогда
				Результат.Руководитель               = Выборка.Представление;
				Результат.РуководительДолжность      = Выборка.Должность;
				Результат.РуководительФИО            = Выборка.Представление;
				Результат.РуководительПредставление  = Выборка.Представление;
			ИначеЕсли Выборка.Роль = ГлавныйБухгалтер Тогда
				Результат.ГлавныйБухгалтер               = Выборка.Представление;
				Результат.ГлавныйБухгалтерФИО            = Выборка.Представление;
				Результат.ГлавныйБухгалтерПредставление  = Выборка.Представление;
			КонецЕсли; 
		КонецЦикла; 
	ИначеЕсли Организация <> Неопределено тогда

		ЗапросПоЛицам = Новый Запрос();
		ЗапросПоЛицам.УстановитьПараметр("ДатаСреза",   ДатаСреза);
		ЗапросПоЛицам.УстановитьПараметр("Организация", Организация);
		ЗапросПоЛицам.УстановитьПараметр("ПризнакФизЛица",   Перечисления.ЮридическоеФизическоеЛицо.ФизическоеЛицо);
		
		ЗапросПоЛицам.Текст = "ВЫБРАТЬ
		                      |	ФИОФизическихЛицСрезПоследних.Фамилия,
		                      |	ФИОФизическихЛицСрезПоследних.Имя,
		                      |	ФИОФизическихЛицСрезПоследних.Отчество,
		                      |	ФИОФизическихЛицСрезПоследних.ФизическоеЛицо КАК ФизическоеЛицо
		                      |ИЗ
		                      |	РегистрСведений.ФИОФизическихЛиц.СрезПоследних(&ДатаСреза, ) КАК ФИОФизическихЛицСрезПоследних
		                      |		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.Организации КАК Организации
		                      |		ПО ФИОФизическихЛицСрезПоследних.ФизическоеЛицо = Организации.ИндивидуальныйПредприниматель
		                      |			И (Организации.Ссылка = &Организация)
		                      |			И (Организации.ЮридическоеФизическоеЛицо = &ПризнакФизЛица)";
		
		Руководители = ЗапросПоЛицам.Выполнить().Выбрать();
		
		Пока Руководители.Следующий() Цикл
			
			ФИО = Новый Структура("Фамилия, Имя, Отчество, Представление");
			Если НЕ (ЗначениеНеЗаполнено(Руководители.Фамилия) или Руководители.Фамилия = NULL) Тогда
				ФИО.Фамилия = Руководители.Фамилия;
			КонецЕсли;
			Если НЕ (ЗначениеНеЗаполнено(Руководители.Имя) или Руководители.Имя = NULL) Тогда
				ФИО.Имя = Руководители.Имя;
			КонецЕсли;
			Если НЕ (ЗначениеНеЗаполнено(Руководители.Отчество) или Руководители.Отчество = NULL) Тогда
				ФИО.Отчество = Руководители.Отчество;
			КонецЕсли;
			Представление = ПолучитьФамилиюИмяОтчество(ФИО.Фамилия, ФИО.Имя, ФИО.Отчество);
			
			Результат.Руководитель               = Руководители.ФизическоеЛицо;
			Результат.РуководительДолжность      = "";
			Результат.РуководительФИО            = ФИО;
			Результат.РуководительПредставление  = Представление;
			
		КонецЦикла;
		
		ЗапросПоЛицам.Текст = 
		"ВЫБРАТЬ
		|	ОтветственныеЛицаОрганизацийСрезПоследних.ОтветственноеЛицо,
		|	ОтветственныеЛицаОрганизацийСрезПоследних.ФизическоеЛицо,
		|	ОтветственныеЛицаОрганизацийСрезПоследних.Должность,
		|	ФИОФизическихЛицСрезПоследних.Фамилия,
		|	ФИОФизическихЛицСрезПоследних.Имя,
		|	ФИОФизическихЛицСрезПоследних.Отчество
		|ИЗ
		|	РегистрСведений.ОтветственныеЛицаОрганизаций.СрезПоследних(&ДатаСреза, СтруктурнаяЕдиница = &Организация) КАК ОтветственныеЛицаОрганизацийСрезПоследних
		|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ФИОФизическихЛиц.СрезПоследних(&ДатаСреза, ) КАК ФИОФизическихЛицСрезПоследних
		|		ПО ОтветственныеЛицаОрганизацийСрезПоследних.ФизическоеЛицо = ФИОФизическихЛицСрезПоследних.ФизическоеЛицо";
		Руководители = ЗапросПоЛицам.Выполнить().Выбрать();

		Пока Руководители.Следующий() Цикл

			ФИО = Новый Структура("Фамилия, Имя, Отчество, Представление");
			Если НЕ (ЗначениеНеЗаполнено(Руководители.Фамилия) или Руководители.Фамилия = NULL) Тогда
				ФИО.Фамилия = Руководители.Фамилия;
			КонецЕсли;
			Если НЕ (ЗначениеНеЗаполнено(Руководители.Имя) или Руководители.Имя = NULL) Тогда
				ФИО.Имя = Руководители.Имя;
			КонецЕсли;
			Если НЕ (ЗначениеНеЗаполнено(Руководители.Отчество) или Руководители.Отчество = NULL) Тогда
				ФИО.Отчество = Руководители.Отчество;
			КонецЕсли;
			Представление = ПолучитьФамилиюИмяОтчество(ФИО.Фамилия, ФИО.Имя, ФИО.Отчество);
			
			Если Руководители.ОтветственноеЛицо      = Перечисления.ОтветственныеЛицаОрганизаций.Руководитель Тогда
				Результат.Руководитель               = Руководители.ФизическоеЛицо;
				Результат.РуководительДолжность      = Руководители.Должность;
				Результат.РуководительФИО            = ФИО;
				Результат.РуководительПредставление  = Представление;

			ИначеЕсли Руководители.ОтветственноеЛицо = Перечисления.ОтветственныеЛицаОрганизаций.ГлавныйБухгалтер Тогда
				Результат.ГлавныйБухгалтер           = Руководители.ФизическоеЛицо;
                Результат.ГлавныйБухгалтерФИО        = ФИО;
				Результат.ГлавныйБухгалтерПредставление  = Представление;
				
			ИначеЕсли Руководители.ОтветственноеЛицо = Перечисления.ОтветственныеЛицаОрганизаций.Кассир Тогда
				Результат.Кассир                     = Руководители.ФизическоеЛицо;
                Результат.КассирФИО            		 = ФИО;
				Результат.КассирПредставление  = Представление;
				
			ИначеЕсли Руководители.ОтветственноеЛицо = Перечисления.ОтветственныеЛицаОрганизаций.ОтветственныйЗаНалоговыеРегистры Тогда
				Результат.ОтветственныйЗаРегистры    = Руководители.ФизическоеЛицо;
				Результат.ОтветственныйЗаРегистрыФИО = ФИО;
				Результат.ОтветственныйЗаРегистрыПредставление  = Представление;

			КонецЕсли;

		КонецЦикла;

	КонецЕсли;

	Возврат Результат;

КонецФункции

// Функция возвращает совокупность данных о физическом лице в виде структуры, 
// В совокупность данных входит ФИО, должность в заданной организации, 
// паспортные данные и др.
//
// Параметры:
//  Организация  - СправочникСсылка.Организации - организация, по которой
//                 определяется должность и подразделение работника
//  ФизЛицо      - СправочникСсылка.ФизическиеЛица - физическое лицо,
//                 по которому возвращается совокупность данных
//  ДатаСреза    - Дата - дата, на которую считываются данные
//
// Возвращаемое значение:
//  Структура    - Структура с совокупностью данных о физическом лице:
//                 - Фамилия
//                 - Имя
//                 - Отчетсво
//                 - Представление (Фамилия И.О.)
//                 - Подразделение
//                 - ДокументВид
//                 - ДокументСерия
//                 - ДокументНомер
//                 - ДокументДатаВыдачи
//                 - ДокументКемВыдан
//                 - ДокументКодПодразделения
//
Функция ДанныеФизЛица(Организация, ФизЛицо, ДатаСреза) Экспорт
	
	Результат = Новый Структура("Фамилия, Имя, Отчество, Представление, 
								|ТабельныйНомер, Должность, ПодразделениеОрганизации, 
								|ДокументВид, ДокументСерия, ДокументНомер,  
								|ДокументДатаВыдачи, ДокументКемВыдан, ДокументКодПодразделения");

	ЗапросПоЛицам = Новый Запрос();
	ЗапросПоЛицам.УстановитьПараметр("ДатаСреза",   ДатаСреза);
	ЗапросПоЛицам.УстановитьПараметр("Организация", Организация);
	ЗапросПоЛицам.УстановитьПараметр("ФизЛицо", ФизЛицо);
	ЗапросПоЛицам.Текст =
	"ВЫБРАТЬ
	|	ФИОФизическихЛицСрезПоследних.Фамилия,
	|	ФИОФизическихЛицСрезПоследних.Имя,
	|	ФИОФизическихЛицСрезПоследних.Отчество,
	//|	РаботникиОрганизацийСрезПоследних.ТабельныйНомер,
	//|	ЕСТЬNULL(РаботникиОрганизацийСрезПоследних.Должность, ФИОФизическихЛицСрезПоследних.ФизическоеЛицо.Должность) КАК Должность,
	//|	РаботникиОрганизацийСрезПоследних.ПодразделениеОрганизации,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументВид,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументСерия,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументНомер,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументДатаВыдачи,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументКемВыдан,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументКодПодразделения
	|ИЗ
	|	РегистрСведений.ФИОФизическихЛиц.СрезПоследних(&ДатаСреза, ФизическоеЛицо = &ФизЛицо) КАК ФИОФизическихЛицСрезПоследних
	|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ПаспортныеДанныеФизЛиц.СрезПоследних(&ДатаСреза, ФизЛицо = &ФизЛицо) КАК ПаспортныеДанныеФизЛицСрезПоследних
	|		ПО ФИОФизическихЛицСрезПоследних.ФизическоеЛицо = ПаспортныеДанныеФизЛицСрезПоследних.ФизЛицо";
	//|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.РаботникиОрганизаций.СрезПоследних(
	//|				&ДатаСреза,
	//|				ФизЛицо = &ФизЛицо
	//|					И Организация = &Организация) КАК РаботникиОрганизацийСрезПоследних
	//|		ПО ФИОФизическихЛицСрезПоследних.ФизическоеЛицо = РаботникиОрганизацийСрезПоследних.Физлицо";
	
	Данные = ЗапросПоЛицам.Выполнить().Выбрать();
	Данные.Следующий();

	Результат.Фамилия       			= Данные.Фамилия;
	Результат.Имя      					= Данные.Имя;
	Результат.Отчество      			= Данные.Отчество;
	Результат.Представление 			= ПолучитьФамилиюИмяОтчество(Данные.Фамилия, Данные.Имя, Данные.Отчество);
	
	//Результат.ТабельныйНомер  			= Данные.ТабельныйНомер;
	//Результат.Должность      			= Данные.Должность;
	//Результат.ПодразделениеОрганизации  = Данные.ПодразделениеОрганизации;
	
	Результат.ДокументВид        		= Данные.ДокументВид;
	Результат.ДокументСерия      		= Данные.ДокументСерия;
	Результат.ДокументНомер      		= Данные.ДокументНомер;
	Результат.ДокументДатаВыдачи 		= Данные.ДокументДатаВыдачи;
	Результат.ДокументКемВыдан      	= Данные.ДокументКемВыдан;
	Результат.ДокументКодПодразделения	= Данные.ДокументКодПодразделения;

	Возврат Результат;
	
КонецФункции // ДанныеФизЛица

// Функция возвращает совокупность данных о физических лицах в виде таблицы
// значений. В совокупность данных входит ФИО, должность в заданной 
// организации, паспортные данные и др.
//
// Параметры:
//  Организация  - СправочникСсылка.Организации - организация, по которой
//                 определяется должность и подразделение работника(ов)
//  ФизЛицо      - СправочникСсылка.ФизическиеЛица или Массив - физическое лицо
//                 или список физ. лиц, по которым возвращается совокупность 
//                 данных
//  ДатаСреза    - Дата - дата, на которую считываются данные
//
// Возвращаемое значение:
//  ТаблицаЗначений - Таблица с совокупностью данных о физическом лице. 
//                  Колонки: возвращаемой таблицы:
//                  - Фамилия
//                  - Имя
//                  - Отчетсво
//                  - Представление (Фамилия И.О.)
//                  - Подразделение
//                  - ДокументВид
//                  - ДокументСерия
//                  - ДокументНомер
//                  - ДокументДатаВыдачи
//                  - ДокументКемВыдан
//                  - ДокументКодПодразделения
//
Функция ДанныеФизЛиц(Организация, ФизЛицо, ДатаСреза) Экспорт

	ТабРезультат = Новый ТаблицаЗначений();
	ТабРезультат.Колонки.Добавить("Фамилия");
	ТабРезультат.Колонки.Добавить("Имя");
	ТабРезультат.Колонки.Добавить("Отчество");
	ТабРезультат.Колонки.Добавить("Представление");
	//ТабРезультат.Колонки.Добавить("ТабельныйНомер");
	//ТабРезультат.Колонки.Добавить("Должность");
	//ТабРезультат.Колонки.Добавить("ПодразделениеОрганизации");
	ТабРезультат.Колонки.Добавить("ДокументВид");
	ТабРезультат.Колонки.Добавить("ДокументСерия");
	ТабРезультат.Колонки.Добавить("ДокументНомер");
	ТабРезультат.Колонки.Добавить("ДокументДатаВыдачи");
	ТабРезультат.Колонки.Добавить("ДокументКемВыдан");
	ТабРезультат.Колонки.Добавить("ДокументКодПодразделения");
								
	ЗапросПоЛицам = Новый Запрос();
	ЗапросПоЛицам.УстановитьПараметр("ДатаСреза",   ДатаСреза);
	ЗапросПоЛицам.УстановитьПараметр("Организация", Организация);
	ЗапросПоЛицам.УстановитьПараметр("ФизЛицо", ФизЛицо);
	ЗапросПоЛицам.Текст =
	"ВЫБРАТЬ
	|	ФИОФизическихЛицСрезПоследних.Фамилия,
	|	ФИОФизическихЛицСрезПоследних.Имя,
	|	ФИОФизическихЛицСрезПоследних.Отчество,
	//|	РаботникиОрганизацийСрезПоследних.ТабельныйНомер,
	//|	РаботникиОрганизацийСрезПоследних.Должность,
	//|	РаботникиОрганизацийСрезПоследних.ПодразделениеОрганизации,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументВид,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументСерия,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументНомер,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументДатаВыдачи,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументКемВыдан,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументКодПодразделения
	|ИЗ
	|	РегистрСведений.ФИОФизическихЛиц.СрезПоследних(&ДатаСреза, ФизическоеЛицо В(&ФизЛицо)) КАК ФИОФизическихЛицСрезПоследних
	|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ПаспортныеДанныеФизЛиц.СрезПоследних(&ДатаСреза, ФизЛицо В(&ФизЛицо)) КАК ПаспортныеДанныеФизЛицСрезПоследних
	|		ПО ФИОФизическихЛицСрезПоследних.ФизическоеЛицо = ПаспортныеДанныеФизЛицСрезПоследних.ФизЛицо";
	//|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.РаботникиОрганизаций.СрезПоследних(&ДатаСреза, ФизЛицо В(&ФизЛицо) И Организация = &Организация) КАК РаботникиОрганизацийСрезПоследних
	//|		ПО ФИОФизическихЛицСрезПоследних.ФизическоеЛицо = РаботникиОрганизацийСрезПоследних.Физлицо
	
	Данные = ЗапросПоЛицам.Выполнить().Выбрать();
	
	Пока Данные.Следующий() Цикл
		
		Результат = ТабРезультат.Добавить();

		Результат.Фамилия       			= Данные.Фамилия;
		Результат.Имя      					= Данные.Имя;
		Результат.Отчество      			= Данные.Отчество;
		Результат.Представление 			= ПолучитьФамилиюИмяОтчество(Данные.Фамилия, Данные.Имя, Данные.Отчество);
		
		//Результат.ТабельныйНомер  			= Данные.ТабельныйНомер;
		//Результат.Должность      			= Данные.Должность;
		//Результат.ПодразделениеОрганизации  = Данные.ПодразделениеОрганизации;
		
		Результат.ДокументВид        		= Данные.ДокументВид;
		Результат.ДокументСерия      		= Данные.ДокументСерия;
		Результат.ДокументНомер      		= Данные.ДокументНомер;
		Результат.ДокументДатаВыдачи 		= Данные.ДокументДатаВыдачи;
		Результат.ДокументКемВыдан      	= Данные.ДокументКемВыдан;
		Результат.ДокументКодПодразделения	= Данные.ДокументКодПодразделения;
		
	КонецЦикла;

	Возврат ТабРезультат;
	
КонецФункции // ДанныеФизЛиц


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ПАРАМЕТРОВ СЕАНСА

#Если НЕ Клиент И НЕ ВнешнееСоединение Тогда
	
// Функция возвращает значение экспортных переменных модуля приложений из параметра сеанса
// Необходмо для возможности создания объектов на сервере
//Функция глЗначениеПеременной(ИмяПеременой) Экспорт
//	ЗначениеИзПараметраСеанса = ПараметрыСеанса[Сред(ИмяПеременой, 3)];
//	Если ТипЗнч(ЗначениеИзПараметраСеанса) = Тип("ХранилищеЗначения") Тогда
//		 Возврат ЗначениеИзПараметраСеанса.Получить();
//	 Иначе
//		 Возврат ЗначениеИзПараметраСеанса;
//	КонецЕсли;
//КонецФункции

#КонецЕсли

// Функция дополняет структуру шапки документа положениями учетной политики.
Процедура ДополнитьПоложениямиУчетнойПолитики(СтруктураШапкиДокумента, КонДата, Отказ, Организация, Учет = "Нал", СтруктураПолейУчетнойПолитикиНУ = Неопределено) Экспорт
	
	СтруктураУП = ПолучитьПараметрыУчетнойПолитики(КонДата, Отказ, Организация, Учет);
	
	Для Каждого ПараметрУП Из СтруктураУП Цикл
		
		Если (ТипЗнч(СтруктураПолейУчетнойПолитикиНУ) = Тип("Структура"))
		   И НЕ (СтруктураПолейУчетнойПолитикиНУ.Количество() = 0) Тогда
		   
			// Заполнение определенными полями
			Если СтруктураПолейУчетнойПолитикиНУ.Свойство(ПараметрУП.Ключ) Тогда
				
				Если ЗначениеНеЗаполнено(СтруктураПолейУчетнойПолитикиНУ[ПараметрУП.Ключ]) Тогда
					
					СтруктураШапкиДокумента.Вставить(ПараметрУП.Ключ,ПараметрУП.Значение);
					
				Иначе
					
					СтруктураШапкиДокумента.Вставить(СтруктураПолейУчетнойПолитикиНУ[ПараметрУП.Ключ],ПараметрУП.Значение);
					
				КонецЕсли; 
				
			КонецЕсли; 
			
		Иначе	
			
			// Дополняем всеми параметрами учетной политики
			СтруктураШапкиДокумента.Вставить(ПараметрУП.Ключ, ПараметрУП.Значение);  
			
		КонецЕсли; 
		
	КонецЦикла; 
	
КонецПроцедуры // ДополнитьПоложениямиУчетнойПолитики()

// Разворачивает таблицу  значений по вложенной таблице
//
// Параметры
//  ТаблицаЗначений  – <ТаблицаЗначений> – базовая таблица
//  КолонкаВложеннойТаблицы  – <Строка> – Наименование колонки влолженной таблицы
//  СписокРаспределяемыхКолонок  – <Структура> – Структура с именами колонок базовой таблицы, значения которых будут распределяться по колонке вложенной таблицы
//         						Ключ - Имя колонки базовой таблицы
//         						Значение - Имя колонки вложенной таблицы. Если во вложенной таблице колонка не обнаружена - обработка прекращается.
// Возвращаемое значение:
//   <ТаблицаЗначений>   – таблица значений, развернутая по значениям вложенной таблицы.
//
// При совпадении имен базовой и вложенной таблиц - если  
Функция РазвернутьПоВложеннойТаблице(ТаблицаЗначений, КолонкаВложеннойТаблицы,СписокРаспределяемыхКолонок, СписокИсключаемыхКолонок, СообщатьОбОшибке = Истина) Экспорт

	Если ТаблицаЗначений.Количество()=0 Тогда
		// Таблица не заполнена, софрмировать новую таблицу не представляется возможнным
		// Отсуттствует вложенная таблица, структуру данных выходной таблицы сформировать невозможно
		Если СообщатьОбОшибке Тогда
			СообщитьОбОшибке("Отстутствуют строки в базовой таблице, распределение по вложенной таблице невозможно.",,,СтатусСообщения.Внимание);
		КонецЕсли; 
		Возврат Неопределено;
	КонецЕсли; 
	
	КолонкиВложеннойТаблицы = ТаблицаЗначений[0][КолонкаВложеннойТаблицы].Колонки;
	//Заполним значения по тем колонкам, по которым не были заполены значения ранее
	Для каждого Колонка Из СписокРаспределяемыхКолонок Цикл
		Если ЗначениеНеЗаполнено(Колонка.Значение) Тогда
			СписокРаспределяемыхКолонок.Вставить(Колонка.Ключ,Колонка.Ключ);
		КонецЕсли;
		Если КолонкиВложеннойТаблицы.Найти(?(ЗначениеНеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение))=Неопределено Тогда
			// Во вложенной таблице не обнаружена колонка, по которой производится распределение.
			Если СообщатьОбОшибке Тогда
				СообщитьОбОшибке("Во вложенной таблице не обнаружена колонка ("+?(ЗначениеНеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение)+"), по которой производится распределение.",,,СтатусСообщения.Внимание);
			КонецЕсли; 
			Возврат Неопределено;
		КонецЕсли; 
	КонецЦикла;
	
	НоваяТаблицаЗначений = Новый ТаблицаЗначений();
	Для каждого Колонка Из ТаблицаЗначений.Колонки Цикл
	    Если Колонка.Имя = КолонкаВложеннойТаблицы Тогда
			Продолжить;
	    ИначеЕсли СписокИсключаемыхКолонок.Свойство(Колонка.Имя) Тогда
			Продолжить;
		КонецЕсли; 
		НоваяТаблицаЗначений.Колонки.Добавить(Колонка.Имя,Колонка.ТипЗначения);
	КонецЦикла; 
	
	Для каждого Колонка Из КолонкиВложеннойТаблицы Цикл
		Если не НоваяТаблицаЗначений.Колонки.Найти(Колонка.Имя) = неопределено Тогда
			Продолжить;
		ИначеЕсли СписокИсключаемыхКолонок.Свойство(Колонка.Имя) Тогда
			Продолжить;
		КонецЕсли; 
		НоваяТаблицаЗначений.Колонки.Добавить(Колонка.Имя,Колонка.ТипЗначения);
	КонецЦикла; 
	
	Для каждого СтрокаБазовойТаблицы Из ТаблицаЗначений Цикл 

		ТаблицаДляРаспределения = СтрокаБазовойТаблицы[КолонкаВложеннойТаблицы];

		Для каждого СтрокаТаблицыРаспределения из ТаблицаДляРаспределения Цикл

			СтрокаНовойТаблицы = НоваяТаблицаЗначений.Добавить();

			Для каждого Колонка из НоваяТаблицаЗначений.Колонки Цикл

				Если СписокРаспределяемыхКолонок.Свойство(Колонка.Имя) тогда
					СтрокаНовойТаблицы[Колонка.Имя]= СтрокаТаблицыРаспределения[СписокРаспределяемыхКолонок[Колонка.Имя]];

				ИначеЕсли не КолонкиВложеннойТаблицы.Найти(Колонка.Имя) = Неопределено тогда
					СтрокаНовойТаблицы[Колонка.Имя]= СтрокаТаблицыРаспределения[Колонка.Имя];

				ИначеЕсли Не(ТаблицаЗначений.Колонки.Найти(Колонка.Имя)=Неопределено) тогда
					СтрокаНовойТаблицы[Колонка.Имя] = СтрокаБазовойТаблицы[Колонка.Имя];

				Иначе
					// Колонка не найдена... Неизвестно, как такое может произойти
		  			Если СообщатьОбОшибке Тогда
						СообщитьОбОшибке("при распределении по вложенной таблице невозможно определить значение для колонки :"+Колонка.Имя+".",,,СтатусСообщения.Внимание);
					КонецЕсли; 

				КонецЕсли;

			КонецЦикла; // Для каждого Колонка из НоваяТаблицаЗначений.Колонки Цикл

		КонецЦикла; // Для каждого СтрокаТаблицыРаспределения из ТаблицаДляРаспределения Цикл

	КонецЦикла; // Для каждого СтрокаБазовойТаблицы Из ТаблицаЗначений Цикл 
	
	Для каждого Колонка Из СписокРаспределяемыхКолонок Цикл
		СписокРаспределяемыхКолонок.Вставить(Колонка.Ключ,Колонка.Ключ);
	КонецЦикла;
	
	// Распределение базовых данных по распределяемым колонкам
	НоваяТаблицаЗначений = СформироватьКорректирующиеЗаписи(ТаблицаЗначений,НоваяТаблицаЗначений,СписокРаспределяемыхКолонок);
	
	Возврат НоваяТаблицаЗначений;

КонецФункции // РазвернутьПоВложеннойТаблице()

Функция ПолучитьЗначениеПеременной(ИмяПараметра, Кэш = Неопределено, КэшИзменен = Ложь) Экспорт
	
	Если Кэш = Неопределено Тогда
		// Кэш не был проинициализирован
		Кэш = Новый Структура;
	Иначе
		// Ищем значение в структуре
		НайденноеЗначение = Неопределено;
		Если Кэш.Свойство(ИмяПараметра, НайденноеЗначение) Тогда
			Возврат НайденноеЗначение;
		КонецЕсли;
	КонецЕсли;
	
	Если ВРег(ИмяПараметра) = ВРег("глТекущийПользователь") Тогда
		НайденноеЗначение = ПараметрыСеанса.ТекущийПользователь;
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("УчетПоВсемОрганизациям") Тогда
		НайденноеЗначение = УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(Пользователи.ТекущийПользователь(), "УчетПоВсемОрганизациям");
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("ОсновнаяОрганизация") Тогда
		НайденноеЗначение = УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(Пользователи.ТекущийПользователь(), "ОсновнаяОрганизация");
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("УчетПоВсемОтветственным") Тогда
		НайденноеЗначение = УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(Пользователи.ТекущийПользователь(), "УчетПоВсемОтветственным");

	ИначеЕсли ВРег(ИмяПараметра) = ВРег("ОсновнойОтветственный") Тогда
		НайденноеЗначение = УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(Пользователи.ТекущийПользователь(), "ОсновнойОтветственный");

	ИначеЕсли ВРег(ИмяПараметра) = ВРег("УчетПоВсемИнвойсинговымЦентрам") Тогда
		НайденноеЗначение = УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(Пользователи.ТекущийПользователь(), "УчетПоВсемИнвойсинговымЦентрам");

	ИначеЕсли ВРег(ИмяПараметра) = ВРег("ОсновнойИнвойсинговыйЦентр") Тогда
		НайденноеЗначение = УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(Пользователи.ТекущийПользователь(), "ОсновнойИнвойсинговыйЦентр");

	ИначеЕсли ВРег(ИмяПараметра) = ВРег("глОбработкаАвтоОбменДанными") Тогда
		//	НайденноеЗначение = ПроцедурыОбменаДанными.ВыполнитьИнициализациюАвтообменаПриНачалеРаботы();
		
	Иначе
		СтрокаИсключения = "Невозможно обработать параметр " + """" + ИмяПараметра + """" + " для получения значения";
		НайденноеЗначение = Неопределено;
		ВызватьИсключение СтрокаИсключения;
		
	КонецЕсли;
	
	Кэш.Вставить(ИмяПараметра, НайденноеЗначение);
	КэшИзменен = Истина;
	
	Возврат НайденноеЗначение;
	
КонецФункции


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ МЕХАНИЗМА РИБ

Процедура ДобавитьПрефиксУзла(Префикс) Экспорт
	
	Если ПараметрыСеанса.ИспользованиеРИБ Тогда
		ПрефиксУзла = ПланыОбмена.Полный.ЭтотУзел().ПрефиксУзла;
		Префикс = ПрефиксУзла + Префикс;
	КонецЕсли;
	
КонецПроцедуры


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ФАЙЛАМИ

// функция возвращает часть строки после последнего встреченного символа в строке
Функция ПолучитьЧастьСтрокиОтделеннойСимволом(Знач ИсходнаяСтрока, Знач СимволПоиска)
	
	ПозицияСимвола = СтрДлина(ИсходнаяСтрока);
	Пока ПозицияСимвола >= 1 Цикл
		
		Если Сред(ИсходнаяСтрока, ПозицияСимвола, 1) = СимволПоиска Тогда
						
			Возврат Сред(ИсходнаяСтрока, ПозицияСимвола + 1); 
			
		КонецЕсли;
		
		ПозицияСимвола = ПозицияСимвола - 1;	
	КонецЦикла;

	Возврат "";
  	
КонецФункции

// Выделяет из имени файла его расширение (набор символов после последней точки).
//
// Параметры
//  ИмяФайла     – Строка, содержащая имя файла, неважно с именем каталога или без.
//
// Возвращаемое значение:
//   Строка – расширение файла.
//
Функция ПолучитьРасширениеФайла(Знач ИмяФайла) Экспорт
	
	Расширение = ПолучитьЧастьСтрокиОтделеннойСимволом(ИмяФайла, ".");
	Возврат Расширение;
	
КонецФункции

// Выделяет из полного пути к файлу его имя (набор символов после последней \).
//
// Параметры
//  ПутьКФайлу     – Строка, содержащая имя файла, неважно с именем каталога или без.
//
// Возвращаемое значение:
//   Строка – расширение файла.
//
Функция ПолучитьИмяФайлаИзПолногоПути(Знач ПутьКФайлу) Экспорт
	
	ИмяФайла = ПолучитьЧастьСтрокиОтделеннойСимволом(ПутьКФайлу, "\");
	Возврат ИмяФайла;
	
КонецФункции


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ОБНОВЛЕНИЯ КОНФИГУРАЦИИ

Функция ВопросДаНет(ТекстВопроса) Экспорт
	
	#Если Клиент Тогда
	
	КодВозврата = Вопрос(ТекстВопроса, РежимДиалогаВопрос.ДаНет, , КодВозвратаДиалога.Нет);
						 
	Возврат (КодВозврата = КодВозвратаДиалога.Да);
	 
 	#Иначе
	 
	Возврат Истина;
	
	#КонецЕсли

КонецФункции // ВопросДаНет()
 
Процедура ПредупреждениеОбОшибке(ТекстСообщения) Экспорт
	 
	#Если Клиент Тогда
		
		Предупреждение(ТекстСообщения);
	
	#Иначе
		
		ВызватьИсключение(ТекстСообщения);
		
	#КонецЕсли
	 
КонецПроцедуры // ПредупреждениеОбОшибке()

Процедура ЗапуститьПрограмму(ПутьКПрограмме, РабочийКаталог = Неопределено) Экспорт
	
	#Если Клиент Тогда
		
		ЗапуститьПриложение(ПутьКПрограмме, РабочийКаталог);
	
	#КонецЕсли
	
КонецПроцедуры // ЗапуститьПрограмму()


/////////////////////////////////////////////////////////////////////////////////
// ПРОЧЕЕ

//Добавил РГ-Софт - Иванов Антон - 2008-10-23
//Для регламентированной отчетности
// Определяет наличие видов деятельности, облагаемых ЕНВД.
//
// Параметры:
//  Организация  - Справочник.Ссылка - Организация, по которой
//                 определяется наличие видов деятельности, облагаемых ЕНВД
//  Дата         - Дата - Дата, на которую получаются сведения
//
// Возвращаемое значение:
//  Булево.
//
Функция ПрименениеЕНВД(Организация, Знач Дата) Экспорт

	Если НЕ ЗначениеЗаполнено(Организация) Тогда
		Возврат Ложь;
	КонецЕсли;
	Если НЕ ЗначениеЗаполнено(Дата) Тогда
		Дата = ТекущаяДата();
	КонецЕсли;

	перемУчетнаяПолитика = ПолучитьПараметрыУчетнойПолитики(Дата, Ложь, Организация);
	Если перемУчетнаяПолитика.Количество() = 0 Тогда
		Возврат Истина;
	Иначе
		//Изменил - РГ-Софт - Иванов Антон - 2008-10-23
		//Не было в ТЗ перемУчетнаяПолитика колонки ОрганизацияЯвляетсяПлательщикомЕНВД
		Возврат Ложь;
		//Возврат перемУчетнаяПолитика.ОрганизацияЯвляетсяПлательщикомЕНВД;
	КонецЕсли;

КонецФункции // ПоддержкаПБУ18()

//Добавил РГ-Софт - Иванов Антон - 2008-10-23
//Для регламентированной отчетности
Процедура ДобавитьПрефиксОрганизации(ДокументОбъект, Префикс) Экспорт
	
	// Если  нет реквизита "Организация" или для нее не задан префикс, то 
	// используем пустой префикс,
	// иначе используем префикс организации.
	МетаданныеДокумента = ДокументОбъект.Метаданные();

	Если Не ЕстьРеквизитДокумента("Организация", МетаданныеДокумента)
		 ИЛИ НЕ ЗначениеЗаполнено(ДокументОбъект.Организация.Префикс)  Тогда
		Префикс = "0";
	Иначе
                                
		Префикс = ДокументОбъект.Организация.Префикс;
        		
	КонецЕсли;
Конецпроцедуры

// ДОРАБОТАТЬ ИНВОЙС И ЗАЯВКУ НА ДОСТАВКУ И УДАЛИТЬ ЭТУ ПРОЦЕДУРУ
Процедура ПроверитьУникальностьНомераДокумента(Номер, Ссылка, Отказ) Экспорт
	
	МетаданныеОбъекта = Ссылка.Метаданные();
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Номер", Номер);
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	// СДЕЛАТЬ ЛИБО ПОМЕТКУ НА УДАЛЕНИЕ ЛИБО ОТМЕНЕННОСТЬ
	Запрос.Текст = РГСофт.ПолучитьТекстЗапросаУникальностиДокумента(МетаданныеОбъекта); 	
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл		
		
		ТекстОшибки = "Не уникальный номер! Номер используется в """ + Выборка.Представление + """";
		РГСофтКлиентСервер.СообщитьОбОшибке(ТекстОшибки, Отказ);
		
	КонецЦикла;
	
КонецПроцедуры

// Добавил РГ-Софт - Булавский - 2010-09-30

// Обработчик подписки на событие, регистрирующей документы для пересчета разниц
Процедура ПерезаписьДокументовДляРазницПриЗаписи(Источник, Отказ) Экспорт
	ЗарегистрироватьДокументДляПересчетаРазниц(Источник.Ссылка);
КонецПроцедуры

Процедура ЗарегистрироватьДокументДляПересчетаРазниц(Документ) Экспорт
	 	
	ОтметкаПересчетаРазниц = РегистрыСведений.ПересчетРазницПоДокументам.СоздатьНаборЗаписей();
	ОтметкаПересчетаРазниц.Отбор.Документ.Установить(Документ);
	
	Если ТранзакцияАктивна() Тогда
				
		БлокировкаДанных = Новый БлокировкаДанных;
		ЭлементБлокировки = БлокировкаДанных.Добавить("РегистрСведений.ПересчетРазницПоДокументам");
		ЭлементБлокировки.УстановитьЗначение("Документ", Документ);
		ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
				
	КонецЕсли;
	
	ОтметкаПересчетаРазниц.Прочитать();
	// Если отметка в регистре уже есть, то ничего не делаем.
	Если ОтметкаПересчетаРазниц.Количество() = 0 Тогда
		
		ЗаписьОтметки = ОтметкаПересчетаРазниц.Добавить();
		ЗаписьОтметки.Документ = Документ;
		ЗаписьОтметки.НаличиеОшибки = Ложь;
		ЗаписьОтметки.КоличествоПопыток = 0;
		
		ОтметкаПересчетаРазниц.Записать();
		
	КонецЕсли; 
	
КонецПроцедуры

Процедура ПопыткаЗаписиОбъекта(Объект, Отказ) Экспорт
	
	Попытка
		Объект.Записать();
	Исключение
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
			"Не удалось записать """ + Объект + """! См. сообщения выше.",
			Объект, , , Отказ);
	КонецПопытки;
	
КонецПроцедуры


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С КРИТЕРИЯМИ ОТБОРА

// Функция разбирает строку вида
// ТипОбъектаМетаданных.ИмяДокумента.ТабличнаяЧасть.ИмяТабличнойЧасти.Реквизит.ИмяРеквизита.
// ТипОбъектаМетаданных должен быть Справочник или Документ.
//
// Параметры:
//  ПутьКДанным - строка.
//  МетаданныеОбъекта - Объект метаданных
//
// Возвращаемое значение:
//  Структура - путь к объекту метаданных
//
Функция РазобратьПутьКОбъектуМетаданных(ПутьКДанным, МетаданныеОбъекта = Неопределено) Экспорт
	
	Структура = Новый Структура;
	
	СоответствиеИмен = Новый Массив();
	СоответствиеИмен.Добавить("ТипОбъекта");
	СоответствиеИмен.Добавить("ВидОбъекта");
	СоответствиеИмен.Добавить("ПутьКДанным");
	СоответствиеИмен.Добавить("ИмяТаблЧасти");
	СоответствиеИмен.Добавить("ИмяРеквизита");
	
	Для индекс = 1 по 3 Цикл
		
		Точка = СтрНайти(ПутьКДанным, ".");
		ТекущееЗначение = Лев(ПутьКДанным, Точка-1);
		Структура.Вставить(СоответствиеИмен[индекс-1], ТекущееЗначение);
		ПутьКДанным = Сред(ПутьКДанным, Точка+1);
		
	КонецЦикла;
	
	ПутьКДанным = СтрЗаменить(ПутьКДанным, "Реквизит.", "");
	
	Если Структура.ПутьКДанным = "ТабличнаяЧасть" Тогда
		
		Для индекс = 4 по 5  Цикл 
			
			Точка = СтрНайти(ПутьКДанным, ".");
			Если Точка = 0 Тогда
				ТекущееЗначение = ПутьКДанным;
			Иначе
				ТекущееЗначение = Лев(ПутьКДанным, Точка-1);
			КонецЕсли;
			
			Структура.Вставить(СоответствиеИмен[индекс-1], ТекущееЗначение);
			ПутьКДанным = Сред(ПутьКДанным,  Точка+1);
			
		КонецЦикла;
		
	Иначе
		
		Структура.Вставить(СоответствиеИмен[3], "");
		Структура.Вставить(СоответствиеИмен[4], ПутьКДанным);
		
	КонецЕсли;
	
	Если МетаданныеОбъекта <> Неопределено Тогда
		Структура.Вставить("Метаданные", МетаданныеОбъекта);
	Иначе
		Если Структура.ТипОбъекта = "Документ" Тогда
			Структура.Вставить("Метаданные", Метаданные.Документы[Структура.ВидОбъекта]);
		Иначе
			Структура.Вставить("Метаданные", Метаданные.Справочники[Структура.ВидОбъекта]);
		КонецЕсли;
	КонецЕсли;
	
	Возврат Структура;
	
КонецФункции // РазобратьПутьКОбъектуМетаданных()


/////////////////////////////////////////////////////////////////////////////////
// РАБОТА С ФОРМАМИ

//Добавил РГ-Софт - Шилов Денис - 2010-11-19
//  
Процедура УстановитьДоступностьКнопокОкЗаписать(ДоступностьКнопки, КнопкаОК = Неопределено, КнопкаЗаписать = Неопределено) Экспорт
	
	КнопкаОК.Доступность		= ДоступностьКнопки;
	КнопкаЗаписать.Доступность	= ДоступностьКнопки;
	
КонецПроцедуры

// Проверка того, что тип имеет ссылочный тип данных
//
Функция ТипСсылочногоТипа(Тип) Экспорт
	
	Возврат Справочники.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ Документы.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ Перечисления.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ ПланыСчетов.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ БизнесПроцессы.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ БизнесПроцессы.ТипВсеСсылкиТочекМаршрутаБизнесПроцессов().СодержитТип(Тип)
		ИЛИ Задачи.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ ПланыОбмена.ТипВсеСсылки().СодержитТип(Тип);
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Вспомогательные функции для установки расширения работы с файлами в веб-клиенте.

// Возвращает значение параметра сеанса ПредлагатьУстановкуРасширенияРаботыСФайлами.
// Возвращаемое значение:
//  Булево - значение параметра сеанса ПредлагатьУстановкуРасширенияРаботыСФайлами.
//
Функция ПараметрыСеансаПредлагатьУстановкуРасширенияРаботыСФайлами() Экспорт
	УстановитьПривилегированныйРежим(Истина);   
	Возврат Ложь; //ПараметрыСеанса.ПредлагатьУстановкуРасширенияРаботыСФайлами; 
КонецФункции

// Устанавливает значение параметра сеанса ПредлагатьУстановкуРасширенияРаботыСФайлами.
// Параметры:
//  Предлагать  - Булево - новое значение параметра сеанса ПредлагатьУстановкуРасширенияРаботыСФайлами.
//
Процедура УстановитьПараметрСеансаПредлагатьУстановкуРасширенияРаботыСФайлами(Предлагать) Экспорт
	УстановитьПривилегированныйРежим(Истина);   
	//ПараметрыСеанса.ПредлагатьУстановкуРасширенияРаботыСФайлами = Предлагать;
КонецПроцедуры	

// Сохраняет ПредлагатьУстановкуРасширенияРаботыСФайлами в настройках и параметре сеанса
Процедура СохранитьПредлагатьУстановкуРасширенияРаботыСФайлами(Предлагать) Экспорт
	
	ХранилищеОбщихНастроек.Сохранить("НастройкиПрограммы", "ПредлагатьУстановкуРасширенияРаботыСФайлами", 
		Предлагать);	
	
	 // здесь всегда ставим Ложь, чтобы в этом сеансе больше не беспокоить.
	 //  а вот в ХранилищеОбщихНастроек можем записать и Истина
	 //   - и на следующем запуске снова будем предлагать установку
	УстановитьПараметрСеансаПредлагатьУстановкуРасширенияРаботыСФайлами(Ложь);
КонецПроцедуры	

// Выполняет установку параметра сеанса ПредлагатьУстановкуРасширенияРаботыСФайлами 
// при начале работы системы.
//
// Параметры
//  ИмяПараметра  			- Строка - имя устанавливаемого параметра
//  УстановленныеПараметры  - Массив - массив, в котором собираются 
//                 имена установленных параметров сеанса
//
Процедура НачальнаяУстановкаПараметраСеанса(ИмяПараметра, УстановленныеПараметры) Экспорт

	Если ИмяПараметра <> "ПредлагатьУстановкуРасширенияРаботыСФайлами" Тогда
		Возврат;
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);   
	
	Если ИмяПараметра = "ПредлагатьУстановкуРасширенияРаботыСФайлами" Тогда
		
		ПредлагатьУстановку = ХранилищеОбщихНастроек.Загрузить("НастройкиПрограммы", 
			"ПредлагатьУстановкуРасширенияРаботыСФайлами");
		Если ПредлагатьУстановку = Неопределено Тогда
			ПредлагатьУстановку = Истина;
			ХранилищеОбщихНастроек.Сохранить("НастройкиПрограммы", 
				"ПредлагатьУстановкуРасширенияРаботыСФайлами", ПредлагатьУстановку);
		КонецЕсли;
		
		//ПараметрыСеанса.ПредлагатьУстановкуРасширенияРаботыСФайлами = ПредлагатьУстановку;
		УстановленныеПараметры.Добавить(ИмяПараметра);
		
	КонецЕсли;
	
КонецПроцедуры 

// заполняет справочник НазначенияСертификатовЭЦП значениями из макета
Процедура ЗаполнитьНазначенияСертификатовЭЦП() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	Макет = Справочники.НазначенияСертификатовЭП.ПолучитьМакет("НазначенияСертификатов");
	ТабЗначений = ОбщегоНазначения.ПрочитатьXMLВТаблицу(Макет.ПолучитьТекст()).Данные;
	
	НачатьТранзакцию();
	Попытка
		
		Для Каждого Запись Из ТабЗначений Цикл
			
			СпрСсылка = Справочники.НазначенияСертификатовЭП.НайтиПоКоду(Запись.Code);
			Если СпрСсылка = Неопределено ИЛИ СпрСсылка.Пустая() Тогда
				Элемент = Справочники.НазначенияСертификатовЭП.СоздатьЭлемент();
				Элемент.Код = Запись.Code;
				Элемент.Наименование = Запись.Name;
				Элемент.Записать();
			КонецЕсли;	
			
		КонецЦикла;	
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры	

// преобразует назначения сертификатов в дружественный вид
Процедура ЗаполнитьНазначениеСертификата(Назначение, НовоеНазначение, ПисатьКодНазначения = Ложь) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	НовоеНазначение = "";
	
	Для Индекс = 1 По СтрЧислоСтрок(Назначение) Цикл
		
		Строка = СтрПолучитьСтроку(Назначение, Индекс); 		
		Представление = Назначение;
		Код = "";
		
		Позиция = СтрНайти(Строка, "(");
		Если Позиция <> 0 Тогда
			
			Представление = Лев(Строка, Позиция - 1);
			Код = Сред(Строка, Позиция + 1, СтрДлина(Строка) - Позиция - 1);
			
			СпрСсылка = Справочники.НазначенияСертификатовЭП.НайтиПоКоду(Код);
			Если СпрСсылка <> Неопределено И НЕ СпрСсылка.Пустая() Тогда
				Представление = СпрСсылка.Наименование;
			КонецЕсли;	
			
			Если ПисатьКодНазначения Тогда
				Представление = Представление  + " (" + Код + ")";
			КонецЕсли;
			
		КонецЕсли;		
		
		НовоеНазначение = НовоеНазначение + Представление;
		НовоеНазначение = НовоеНазначение + Символы.ПС;
		
	КонецЦикла;	
	
КонецПроцедуры

// Позволяет определить есть ли среди реквизитов справочника
// реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита - строковое имя искомого реквизита, 
//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьРеквизитСправочника(ИмяРеквизита, МетаданныеСправочника) Экспорт

	Возврат НЕ (МетаданныеСправочника.Реквизиты.Найти(ИмяРеквизита) = Неопределено);

КонецФункции // ЕстьРеквизитДокумента()
//RG Soft Михайлов Д.В. 12.11.11
Функция УдалитьПовторяющиесяЭлементыМассива(Массив, НеИспользоватьНеопределено = Ложь) Экспорт
	
	ОписаниеТиповСправочники  = Справочники.ТипВсеСсылки(); 
	ОписаниеТиповДокументы    = Документы.ТипВсеСсылки(); 
	ОписаниеТиповПВХ          = ПланыВидовХарактеристик.ТипВсеСсылки(); 
	ОписаниеТиповПланыСчетов  = ПланыСчетов.ТипВсеСсылки(); 
	ОписаниеТиповПланыРасчета = ПланыВидовРасчета.ТипВсеСсылки(); 
	
	Если ТипЗнч(Массив) = Тип("Массив") Тогда 
		
		УжеВМассиве = Новый Соответствие; 
		БылоНеопределено = Ложь;
		
		КолвоЭлементовВМассиве = Массив.Количество(); 
		
		Для ОбратныйИндекс = 1 По КолвоЭлементовВМассиве Цикл 
			ЭлементМассива = Массив[КолвоЭлементовВМассиве - ОбратныйИндекс]; 
			ТипЭлемента = ТипЗнч(ЭлементМассива); 
			Если ЭлементМассива = Неопределено Тогда
				Если БылоНеопределено или НеИспользоватьНеопределено Тогда
					Массив.Удалить(КолвоЭлементовВМассиве - ОбратныйИндекс); 
				Иначе
					БылоНеопределено = Истина;
				КонецЕсли;
				Продолжить;
			ИначеЕсли ОписаниеТиповСправочники.СодержитТип(ТипЭлемента) 
				ИЛИ ОписаниеТиповДокументы.СодержитТип(ТипЭлемента) 
				ИЛИ ОписаниеТиповПВХ.СодержитТип(ТипЭлемента) 
				ИЛИ ОписаниеТиповПланыСчетов.СодержитТип(ТипЭлемента) 
				ИЛИ ОписаниеТиповПланыРасчета.СодержитТип(ТипЭлемента) Тогда 
				
				ИДЭлемента = Строка(ЭлементМассива.УникальныйИдентификатор()); 
				
			Иначе 
				
				ИДЭлемента = ЭлементМассива; 
				
			КонецЕсли; 
			
			Если УжеВМассиве[ИДЭлемента] = Истина Тогда 
				Массив.Удалить(КолвоЭлементовВМассиве - ОбратныйИндекс); 
			Иначе 
				УжеВМассиве[ИДЭлемента] = Истина; 
			КонецЕсли; 
		КонецЦикла;      
		
	КонецЕсли;
	
	Возврат Массив;
	
КонецФункции
//Конец RG Soft Михайлов Д.В. 12.11.11

//////////////////////////////////////////////////////////
//РГ-СОФТ добавил - Ставров Илья - 2012-01-16
//При переброске модуля регламентированной отчетности

Функция ЭтоОбособленноеПодразделение(Организация) Экспорт
	
	Возврат ГоловнаяОрганизация(Организация) <> Организация;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ СО СТРОКАМИ

// Функция "расщепляет" строку на подстроки, используя заданный 
//		разделитель. Разделитель может иметь любую длину. 
//		Если в качестве разделителя задан пробел, рядом стоящие пробелы 
//		считаются одним разделителем, а ведущие и хвостовые пробелы параметра Стр
//		игнорируются.
//		Например, 
//		РазложитьСтрокуВМассивПодстрок(",строка 1,,,строка 2", ",") возвратит массив значений из пяти элементов, 
//		три из которых - пустые строки, а 
//		РазложитьСтрокуВМассивПодстрок(" строка1   строка 2", " ") возвратит массив значений из двух элементов
//
//	Параметры: 
//		Стр - 			строка, которую необходимо разложить на подстроки. 
//						Параметр передается по значению.
//		Разделитель - 	строка-разделитель, по умолчанию - запятая.
//
//
//	Возвращаемое значение:
//		массив значений, элементы которого - подстроки
//
Функция РазложитьСтрокуВМассивПодстрок(Знач Стр, Разделитель = ",") Экспорт
	
	МассивСтрок = Новый Массив();
	Если Разделитель = " " Тогда
		Стр = СокрЛП(Стр);
		Пока 1=1 Цикл
			Поз = СтрНайти(Стр,Разделитель);
			Если Поз=0 Тогда
				МассивСтрок.Добавить(Стр);
				Возврат МассивСтрок;
			КонецЕсли;
			МассивСтрок.Добавить(Лев(Стр,Поз-1));
			Стр = СокрЛ(Сред(Стр,Поз));
		КонецЦикла;
	Иначе
		ДлинаРазделителя = СтрДлина(Разделитель);
		Пока 1=1 Цикл
			Поз = СтрНайти(Стр,Разделитель);
			Если Поз=0 Тогда
				МассивСтрок.Добавить(Стр);
				Возврат МассивСтрок;
			КонецЕсли;
			МассивСтрок.Добавить(Лев(Стр,Поз-1));
			Стр = Сред(Стр,Поз+ДлинаРазделителя);
		КонецЦикла;
	КонецЕсли;
	
КонецФункции 

//Добавил Карпов Стас РГ-Софт
// Функция формирует представление суммы прописью в указанной валюте
//
// Возвращаемое значение:
//  Строка - сумма прописью
//
Функция СформироватьСуммуПрописью(Сумма, Валюта) Экспорт

	Возврат ЧислоПрописью(Сумма);
	

КонецФункции // СформироватьСуммуПрописью()

// { РГ-Софт Пахоменков А. 12.12.2014
// ТипРегистра - тип в строковом формате, например "РегистрыНакопления"
// ИмяРегистра - имя в строковом формате, например "НДСПредъявленный"
// СтандартныеРеквизиты, Измерения,Ресурсы - строки (с перечислением имен через запятую), если заполнены, то строки будут составляться тольпо по находящимся в массивах данным
// Функция возвращает структуру группировки по стандартным реквизитам и измерениям (Группа) и итогам по ресурсам (Итог)
// для регистра
Функция ПолучитьСтруктуруСверткиРегистра(ТипРегистра, ИмяРегистра, СтандартныеРеквизиты = "", Измерения = "", Ресурсы = "") Экспорт
	               	
	Если НЕ СтандартныеРеквизиты = "" Тогда
		СтандартныеРеквизиты = ОбщегоНазначения.РазложитьСтрокуВМассивПодстрок(СтандартныеРеквизиты,",");
	Иначе
		СтандартныеРеквизиты 	= Новый Массив; 
	КонецЕсли;
	
	Если НЕ Измерения = "" Тогда
		Измерения = ОбщегоНазначения.РазложитьСтрокуВМассивПодстрок(Измерения,",");
	Иначе
		Измерения 	= Новый Массив; 
	КонецЕсли;
	
	Если НЕ Ресурсы = "" Тогда
		Ресурсы = ОбщегоНазначения.РазложитьСтрокуВМассивПодстрок(Ресурсы,",");
	Иначе
		Ресурсы 	= Новый Массив; 
	КонецЕсли;
	                                   
	Регистр = Метаданные[ТипРегистра][ИмяРегистра]; 	
	СтрокаГрупировки = "";   
	
	СтандартныеРеквизитыОграниченныйСписок = СтандартныеРеквизиты.Количество() > 0; 	
	Для каждого СтандартныйРеквизит из Регистр.СтандартныеРеквизиты Цикл
		ТекИмя = СтандартныйРеквизит.Имя;
		Если СтандартныеРеквизитыОграниченныйСписок Тогда
			Если НЕ СтандартныеРеквизиты.Найти(ТекИмя) = Неопределено Тогда
				СтрокаГрупировки = СтрокаГрупировки + ?(СтрокаГрупировки = "","",",") + СтандартныйРеквизит.Имя;	
			КонецЕсли;
		Иначе
			СтрокаГрупировки = СтрокаГрупировки + ?(СтрокаГрупировки = "","",",") + СтандартныйРеквизит.Имя;
		КонецЕсли;
	КонецЦикла;
	
	ИзмеренияОграниченныйСписок = Измерения.Количество() > 0; 	
	Для каждого Измерение из Регистр.Измерения Цикл
		ТекИмя = Измерение.Имя;
		Если ИзмеренияОграниченныйСписок Тогда
			Если НЕ Измерения.Найти(ТекИмя) = Неопределено Тогда
				СтрокаГрупировки = СтрокаГрупировки + ?(СтрокаГрупировки = "","",",") + Измерение.Имя;	
			КонецЕсли;
		Иначе
			СтрокаГрупировки = СтрокаГрупировки + ?(СтрокаГрупировки = "","",",") + Измерение.Имя;
		КонецЕсли;
	КонецЦикла;
	
	СтрокаИтогов = ""; 
	РесурсыОграниченныйСписок = Ресурсы.Количество() > 0; 	
	Для каждого Ресурс из Регистр.Ресурсы Цикл
		ТекИмя = Ресурс.Имя;
		Если РесурсыОграниченныйСписок Тогда
			Если НЕ Ресурсы.Найти(ТекИмя) = Неопределено Тогда
				СтрокаИтогов = СтрокаИтогов + ?(СтрокаИтогов = "","",",") + Ресурс.Имя;	
			КонецЕсли;
		Иначе
			СтрокаИтогов = СтрокаИтогов + ?(СтрокаИтогов = "","",",") + Ресурс.Имя;
		КонецЕсли;
	КонецЦикла;

	Структура = Новый Структура;
	Структура.Вставить("Группа", СтрокаГрупировки);
	Структура.Вставить("Итог",    СтрокаИтогов);
	
	Возврат Структура;

КонецФункции

#КонецОбласти
